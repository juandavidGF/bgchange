ðŸ“ Project Tree:

â”œâ”€â”€ README.md
â”œâ”€â”€ TODO.md
â”œâ”€â”€ docs
â”‚   â””â”€â”€ sse-implementation.md
â”œâ”€â”€ instructions.md
â”œâ”€â”€ next.config.mjs
â”œâ”€â”€ package.json
â”œâ”€â”€ playground
â”‚   â”œâ”€â”€ image.png
â”‚   â”œâ”€â”€ index.mjs
â”‚   â”œâ”€â”€ parts.mjs
â”‚   â”œâ”€â”€ references.md
â”‚   â”œâ”€â”€ talker.mjs
â”‚   â”œâ”€â”€ test-curl.mjs
â”‚   â””â”€â”€ test.mjs
â”œâ”€â”€ postcss.config.mjs
â”œâ”€â”€ productSpec.md
â”œâ”€â”€ project_documentation.md
â”œâ”€â”€ project_dump.txt
â”œâ”€â”€ public
â”‚   â”œâ”€â”€ next.svg
â”‚   â””â”€â”€ vercel.svg
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”œâ”€â”€ ClientSidebarWrapper.tsx
â”‚   â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [slug]
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ get
â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ create
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ fetch-model-details
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ get
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ enhancebg
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ experimental
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ sse
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ init
â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ predict
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ stream
â”‚   â”‚   â”‚   â”‚           â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ illuminai
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ inter-design
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ preview
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ get
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ removebg
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ simpson
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â””â”€â”€ upscale
â”‚   â”‚   â”‚       â””â”€â”€ route.ts
â”‚   â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”‚   â””â”€â”€ [slug]
â”‚   â”‚   â”‚       â”œâ”€â”€ ClientPage.tsx
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ chat
â”‚   â”‚   â”‚   â””â”€â”€ [slug]
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ create
â”‚   â”‚   â”‚   â”œâ”€â”€ list
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ desktop-sidebar.tsx
â”‚   â”‚   â”œâ”€â”€ enhancebg
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â”œâ”€â”€ header.tsx
â”‚   â”‚   â”œâ”€â”€ illuminai
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”œâ”€â”€ mobile-sidebar.tsx
â”‚   â”‚   â”œâ”€â”€ on-device
â”‚   â”‚   â”‚   â””â”€â”€ [slug]
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ providers.tsx
â”‚   â”‚   â”œâ”€â”€ removebg
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ selectmenu.tsx
â”‚   â”‚   â”œâ”€â”€ sidebar.tsx
â”‚   â”‚   â”œâ”€â”€ simpson
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â””â”€â”€ upscaler
â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ common
â”‚   â”‚   â”œâ”€â”€ configuration.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”œâ”€â”€ AppPreview.tsx
â”‚   â”‚   â”œâ”€â”€ audioOutput.tsx
â”‚   â”‚   â”œâ”€â”€ numericInput.tsx
â”‚   â”‚   â”œâ”€â”€ prompt.tsx
â”‚   â”‚   â””â”€â”€ textOutput.tsx
â”‚   â”œâ”€â”€ experimental
â”‚   â”‚   â””â”€â”€ sse-handler
â”‚   â”‚       â”œâ”€â”€ client.ts
â”‚   â”‚       â”œâ”€â”€ route.ts
â”‚   â”‚       â””â”€â”€ utils.ts
â”‚   â”œâ”€â”€ lib
â”‚   â”‚   â””â”€â”€ mongodb.ts
â”‚   â”œâ”€â”€ types
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ utils
â”‚       â”œâ”€â”€ gradio.ts
â”‚       â””â”€â”€ index.ts
â”œâ”€â”€ tailwind.config.ts
â”œâ”€â”€ tmp
â”‚   â”œâ”€â”€ gradio_test.ts
â”‚   â”œâ”€â”€ playground.ts
â”‚   â”œâ”€â”€ response_app_info.json
â”‚   â”œâ”€â”€ test.ts
â”‚   â”œâ”€â”€ test2.ts
â”‚   â””â”€â”€ test3.ts
â””â”€â”€ tsconfig.json


ðŸ“„ File Contents:

==== README.md ====
https://pyramid-flow-pyramid-flow.hf.space/gradio_api/info
https://www.gradio.app/guides/getting-started-with-the-js-client#inspecting-the-api-endpoints


This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.


==== TODO.md ====
(Skipped binary or unreadable file)

==== docs/sse-implementation.md ====
# Server-Sent Events (SSE) Integration

## Overview
This document describes the experimental SSE implementation for real-time Gradio API interactions.

```mermaid
graph TD
    A[Frontend] -->|POST /discover| B[SSE Discovery]
    B -->|Success| C[SSE Connection]
    B -->|Fallback| D[Polling]
    C --> E[Event Stream]
    D --> F[Interval Requests]
```

## File Structure
```
src/experimental/sse-handler/
â”œâ”€â”€ route.ts         # API endpoints
â”œâ”€â”€ client.ts        # Frontend utilities
â”œâ”€â”€ utils.ts         # Shared functions
â””â”€â”€ types.ts         # Type definitions
```

## API Reference

### Discovery Endpoint
`POST /api/experimental/sse/discover`

**Request:**
```typescript
interface DiscoverRequest {
  baseUrl: string;  // Gradio app URL
}
```

**Response:**
```typescript
interface DiscoverResponse {
  success: boolean;
  supportsSSE: boolean;
  endpoints: string[];
  error?: string;
}
```

### SSE Client API

```typescript
class SSEClient {
  constructor(url: string);
  
  // Connect to SSE stream
  connect(): Promise<EventSource>;
  
  // Process messages
  onMessage(callback: (data: SSEMessage) => void): void;
  
  // Error handling  
  onError(callback: (error: Error) => void): void;
}
```

## Implementation Details

### Sequence Diagram
```mermaid
sequenceDiagram
    Frontend->>+Backend: POST /discover
    Backend->>+Gradio: GET /info
    Gradio-->>-Backend: API Info
    Backend-->>-Frontend: Endpoints List
    Frontend->>+Gradio: SSE Connect
    Gradio->>Frontend: Event Stream
```

### Error Handling
1. **Discovery Failure**:
   - Retry with `/gradio_api/info`
   - Fallback to polling if both fail

2. **Connection Issues**:
   ```javascript
   eventSource.onerror = () => {
     if (eventSource.readyState === EventSource.CLOSED) {
       startPollingFallback();
     }
   };
   ```

## Usage Example

### Frontend Implementation
```typescript
import { discoverSSE, SSEClient } from '@/experimental/sse-handler/client';

async function runProcess() {
  const discovery = await discoverSSE('https://app.hf.space');
  
  if (discovery.supportsSSE) {
    const client = new SSEClient(discovery.endpoints[0]);
    client.onMessage((data) => {
      console.log('Update:', data);
    });
    await client.connect();
  } else {
    // Fallback to polling
  }
}
```

## Testing

### Test Cases
1. **Discovery Test**:
   ```javascript
   test('discovers SSE endpoints', async () => {
     const result = await discoverSSE(validUrl);
     expect(result.supportsSSE).toBeTruthy();
   });
   ```

2. **Connection Test**:
   ```javascript
   test('handles SSE connection', async () => {
     const client = new SSEClient(testUrl);
     const mockCallback = jest.fn();
     client.onMessage(mockCallback);
     await client.connect();
     expect(mockCallback).toHaveBeenCalled();
   });
   ```

## Migration Guide

### Enabling in Production
1. Set feature flag in `.env`:
   ```
   USE_SSE_EXPERIMENTAL=true
   ```
2. Update API routes to include SSE handlers
3. Deploy with monitoring


==== instructions.md ====
INSTRUCTIONS FOR CLAUDE 3.5: IMPLEMENTING APP PREVIEW FEATURE

Overview: Add an interactive preview feature to the app creation page that allows users to see and test their configurations in real-time before saving them.

Implementation Steps:

STEP 1: ADD PREVIEW MODE TO EDIT MODE STATE âœ“
- Add implementation progress tracking
- Update editMode state to include 'preview' option
- Add Preview tab button alongside Form and JSON tabs
- Basic preview mode switching functionality

STEP 2: CREATE A STANDALONE PREVIEW COMPONENT âœ“
- Build component that takes a configuration object
- Add proper input/output component types matching production app:
  * Use Dropzone for image uploads
  * Use Prompt component for text inputs
  * Use NumberInput/Slider for numeric values
  * Use Checkbox/CheckboxGroup for boolean inputs
- Match production app styling and layout
- Include state management for inputs, outputs, and loading

STEP 3: ADD API PREVIEW FLAG âœ“
- Include 'X-Preview-Mode': 'true' header in API requests
- Keep the same API endpoints but mark requests as previews
- Ensure preview requests are isolated from production data

STEP 4: INTEGRATE PREVIEW INTO CREATE PAGE âœ“
- Create draft configuration object from form values
- Add conditional rendering for preview mode
- Seamlessly switch between edit and preview modes
- Clean, production-like UI without preview banners

STEP 5: IMPLEMENT PREVIEW FUNCTIONALITY âœ“
- Full support for all input types:
  * File upload handling for images
  * Text input for prompts
  * Numeric inputs with validation
  * Checkbox and selection inputs
- Real-time preview updates
- Proper error handling and validation
- Loading states during API calls

STEP 6: ADD FINAL UI POLISH âœ“
- Clean, consistent styling matching production app
- Proper loading indicators
- Error message handling
- Download functionality for outputs
- Responsive layout and grid system

IMPLEMENTATION NOTES:
- Use the same component types as ClientPage.tsx for consistency
- Keep preview mode seamlessly integrated with the creation flow
- Maintain full functionality while staying isolated from production
- Focus on clean, professional UI without preview indicators


==== next.config.mjs ====
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    domains: ['replicate.delivery']
  },
  async headers() {
    return [
      // {
      //   source: '/(.*)',
      //   headers: [
      //     {
      //       key: 'Cross-Origin-Opener-Policy',
      //       value: 'same-origin',
      //     },
      //     {
      //       key: 'Cross-Origin-Embedder-Policy',
      //       value: 'require-corp',
      //     },
      //     {
      //       key: 'Cross-Origin-Resource-Policy',
      //       value: 'cross-origin',
      //     },

      //   ],
      // },
    ];
  },
  env: {
    BASE_URL_CHAT_AGENT_PY: process.env.BASE_URL_CHAT_AGENT_PY,
  }
};

export default nextConfig;


==== package.json ====
{
  "name": "changebg",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@diffusionstudio/vits-web": "^1.0.2",
    "@headlessui/react": "^2.1.0",
    "@heroicons/react": "^2.1.4",
    "@types/file-saver": "^2.0.7",
    "@vercel/analytics": "^1.3.1",
    "axios": "^1.7.4",
    "eventsource": "^3.0.6",
    "file-saver": "^2.0.5",
    "lucide-react": "^0.435.0",
    "mongodb": "^6.8.0",
    "next": "^14.2.5",
    "next-themes": "^0.3.0",
    "react": "^18",
    "react-dom": "^18",
    "react-dropzone": "^14.2.3",
    "react-icons": "^5.2.1",
    "react-loader-spinner": "^6.1.6",
    "react-markdown": "^9.0.1",
    "replicate": "^0.31.1"
  },
  "devDependencies": {
    "@gradio/client": "^1.4.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "dotenv": "^16.4.5",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}


==== playground/image.png ====
(Skipped binary or unreadable file)

==== playground/index.mjs ====
import { Client, handle_file } from "@gradio/client";
import { readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import "dotenv/config";

const CLIENT = "sesame/csm-1b";

const formatedEndpoints = [
  {
      "key": "/update_audio",
      "inputs": [
          {
              "key": "speaker",
              "component": "dropdown",
              "type": "string",
              "label": "Select a predefined speaker",
              "value": "conversational_a",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "speaker_prompt",
              "component": "audio",
              "type": "string",
              "title": "Speaker prompt",
              "show": true,
              "formatItem": "filepath"
          }
      ]
  },
  {
      "key": "/update_audio_1",
      "inputs": [
          {
              "key": "speaker",
              "component": "dropdown",
              "type": "string",
              "label": "Select a predefined speaker",
              "value": "conversational_b",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "speaker_prompt",
              "component": "audio",
              "type": "string",
              "title": "Speaker prompt",
              "show": true,
              "formatItem": "filepath"
          }
      ]
  },
  {
      "key": "/update_text",
      "inputs": [
          {
              "key": "speaker",
              "component": "dropdown",
              "type": "string",
              "label": "Select a predefined speaker",
              "value": "conversational_a",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "speaker_prompt",
              "component": "Textbox",
              "type": "string",
              "title": "Speaker prompt",
              "show": true,
              "formatItem": "str"
          }
      ]
  },
  {
      "key": "/update_text_1",
      "inputs": [
          {
              "key": "speaker",
              "component": "dropdown",
              "type": "string",
              "label": "Select a predefined speaker",
              "value": "conversational_b",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "speaker_prompt",
              "component": "Textbox",
              "type": "string",
              "title": "Speaker prompt",
              "show": true,
              "formatItem": "str"
          }
      ]
  },
  {
      "key": "/infer",
      "inputs": [
          {
              "key": "text_prompt_speaker_a",
              "component": "Textbox",
              "type": "string",
              "label": "Speaker prompt",
              "value": "like revising for an exam I'd have to try and like keep up the momentum because I'd start really early I'd be like okay I'm gonna start revising now and then like you're revising for ages and then I just like start losing steam I didn't do that for the exam we had recently to be fair that was a more of a last minute scenario but like yeah I'm trying to like yeah I noticed this yesterday that like Mondays I sort of start the day with this not like a panic but like a",
              "show": true,
              "required": false
          },
          {
              "key": "text_prompt_speaker_b",
              "component": "Textbox",
              "type": "string",
              "label": "Speaker prompt",
              "value": "like a super Mario level. Like it's very like high detail. And like, once you get into the park, it just like, everything looks like a computer game and they have all these, like, you know, if, if there's like a, you know, like in a Mario game, they will have like a question block. And if you like, you know, punch it, a coin will come out. So like everyone, when they come into the park, they get like this little bracelet and then you can go punching question blocks around.",
              "show": true,
              "required": false
          },
          {
              "key": "audio_prompt_speaker_a",
              "component": "audio",
              "type": "string",
              "label": "Speaker prompt",
              "value": {
                  "path": "/tmp/gradio/5b5ce26817597fa754ef96dedc86f448c1bac998d19a7cf4b0d79fcd0ca1ab16/conversational_a.wav",
                  "url": "https://github.com/gradio-app/gradio/raw/main/test/test_files/audio_sample.wav",
                  "size": null,
                  "orig_name": "conversational_a.wav",
                  "mime_type": null,
                  "is_stream": false,
                  "meta": {
                      "_type": "gradio.FileData"
                  }
              },
              "show": true,
              "required": false
          },
          {
              "key": "audio_prompt_speaker_b",
              "component": "audio",
              "type": "string",
              "label": "Speaker prompt",
              "value": {
                  "path": "/tmp/gradio/c8275e46be95249d7869f6290a90f1073a1182f62f9153ed0434513bd630d58f/conversational_b.wav",
                  "url": "https://github.com/gradio-app/gradio/raw/main/test/test_files/audio_sample.wav",
                  "size": null,
                  "orig_name": "conversational_b.wav",
                  "mime_type": null,
                  "is_stream": false,
                  "meta": {
                      "_type": "gradio.FileData"
                  }
              },
              "show": true,
              "required": false
          },
          {
              "key": "gen_conversation_input",
              "component": "Textbox",
              "type": "string",
              "label": "conversation",
              "value": "Hey how are you doing.\nPretty good, pretty good.\nI'm great, so happy to be speaking to you.\nMe too, this is some cool stuff huh?\nYeah, I've been reading more about speech generation, and it really seems like context is important.\nDefinitely.\n",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "synthesized_audio",
              "component": "audio",
              "type": "string",
              "title": "Synthesized audio",
              "show": true,
              "formatItem": "filepath"
          }
      ]
  }
];

// Function to get endpoint configuration
function getEndpointConfig(endpointKey) {
  return formatedEndpoints.find(endpoint => endpoint.key === endpointKey);
}

// Function to prepare parameters for an endpoint
function prepareParams(endpointConfig, params = {}) {
  const processedParams = {};
  
  for (const input of endpointConfig.inputs) {
    // If a param value is provided, use it
    if (params[input.key] !== undefined) {
      processedParams[input.key] = params[input.key];
      continue;
    }
    
    // Otherwise use the default value if available
    if (input.value !== undefined) {
      processedParams[input.key] = input.value;
    }
  }
  
  return processedParams;
}

async function processFile(filePath) {
  const buffer = await readFile(filePath);
  return handle_file(new Blob([buffer]));
}

// Main test function
async function testEndpoint(endpointKey, customParams = {}) {
  try {
    // Get endpoint configuration
    const endpointConfig = getEndpointConfig(endpointKey);
    if (!endpointConfig) {
      throw new Error(`Endpoint ${endpointKey} not found`);
    }
    
    console.log(`Testing endpoint: ${endpointKey}`);
    console.log('Endpoint configuration:', endpointConfig);
    
    // Connect to client
    const app = await Client.connect(CLIENT);
    console.log('Connected to client:', CLIENT);
    
    // Prepare parameters
    const params = prepareParams(endpointConfig, customParams);
    console.log('Prepared parameters:', params);
    
    // Make prediction
    const result = await app.predict(endpointKey, params);
    console.log('Prediction result:', result);
    
    return result;
  } catch (error) {
    console.error('Error:', error.message);
    throw error;
  }
}

// Example usage
async function run(endpoint) {
  try {
    // Example: Test the /infer endpoint with default values
    await testEndpoint(endpoint);
    
  } catch (e) {
    console.error('Test execution failed:', e.message);
  }
}


async function testClient() {
    try {
        const app = await Client.connect(CLIENT);
        console.log('Connected to client:', {CLIENT, app});
    } catch (e) {
        console.error('Test execution failed:', e.message);
    }
}

// Run the test
run("/infer");


// fetch("https://sesame-csm-1b.hf.space/gradio_api/queue/join?__theme=system", {
//     "headers": {
//       "accept": "*/*",
//       "accept-language": "en-US,en;q=0.6",
//       "content-type": "application/json",
//       "priority": "u=1, i",
//       "sec-ch-ua": "\"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Brave\";v=\"134\"",
//       "sec-ch-ua-mobile": "?0",
//       "sec-ch-ua-platform": "\"macOS\"",
//       "sec-fetch-dest": "empty",
//       "sec-fetch-mode": "cors",
//       "sec-fetch-site": "same-origin",
//       "sec-fetch-storage-access": "none",
//       "sec-gpc": "1",
//       "x-zerogpu-token": "eyJhbGciOiJFZERTQSJ9.eyJyZWFkIjp0cnVlLCJwZXJtaXNzaW9ucyI6eyJyZXBvLmNvbnRlbnQucmVhZCI6dHJ1ZX0sIm9uQmVoYWxmT2YiOnsia2luZCI6InVzZXIiLCJfaWQiOiI2MzNiNzFiNDdhZjYzM2NiY2QwNjcxZDgiLCJ1c2VyIjoianVhbmRhdmlkZ2YiLCJpc1BybyI6dHJ1ZSwiaXNFbnRlcnByaXNlTWVtYmVyIjpmYWxzZX0sImlhdCI6MTc0MjI0MDU0OCwic3ViIjoiL3NwYWNlcy9zZXNhbWUvY3NtLTFiIiwiZXhwIjoxNzQyMjQwNzI4LCJpc3MiOiJodHRwczovL2h1Z2dpbmdmYWNlLmNvIn0.THiebhLHNENDNgEe7HhrxHDNqhuR1BMmSSr8WlRjKpm8asa39ZPxszsU3wu67UeZr-mJUX9LHWAJDrwwxUUABA",
//       "x-zerogpu-uuid": "MWNH2WDkdwd7ZybKDRxD2",
//       "Referer": "https://sesame-csm-1b.hf.space/?__theme=system",
//       "Referrer-Policy": "strict-origin-when-cross-origin"
//     },
//     "body": "{\"data\":[\"like revising for an exam I'd have to try and like keep up the momentum because I'd start really early I'd be like okay I'm gonna start revising now and then like you're revising for ages and then I just like start losing steam I didn't do that for the exam we had recently to be fair that was a more of a last minute scenario but like yeah I'm trying to like yeah I noticed this yesterday that like Mondays I sort of start the day with this not like a panic but like a\",\"like a super Mario level. Like it's very like high detail. And like, once you get into the park, it just like, everything looks like a computer game and they have all these, like, you know, if, if there's like a, you know, like in a Mario game, they will have like a question block. And if you like, you know, punch it, a coin will come out. So like everyone, when they come into the park, they get like this little bracelet and then you can go punching question blocks around.\",{\"path\":\"/tmp/gradio/5b5ce26817597fa754ef96dedc86f448c1bac998d19a7cf4b0d79fcd0ca1ab16/conversational_a.wav\",\"url\":\"https://sesame-csm-1b.hf.space/gradio_api/file=/tmp/gradio/5b5ce26817597fa754ef96dedc86f448c1bac998d19a7cf4b0d79fcd0ca1ab16/conversational_a.wav\",\"size\":null,\"orig_name\":\"conversational_a.wav\",\"mime_type\":null,\"is_stream\":false,\"meta\":{\"_type\":\"gradio.FileData\"}},{\"path\":\"/tmp/gradio/c8275e46be95249d7869f6290a90f1073a1182f62f9153ed0434513bd630d58f/conversational_b.wav\",\"url\":\"https://sesame-csm-1b.hf.space/gradio_api/file=/tmp/gradio/c8275e46be95249d7869f6290a90f1073a1182f62f9153ed0434513bd630d58f/conversational_b.wav\",\"size\":null,\"orig_name\":\"conversational_b.wav\",\"mime_type\":null,\"is_stream\":false,\"meta\":{\"_type\":\"gradio.FileData\"}},\"Hey how are you doing.\\nPretty good, pretty good.\\nI'm great, so happy to be speaking to you.\\nMe too, this is some cool stuff huh?\\nYeah, I've been reading more about speech generation, and it really seems like context is important.\\nDefinitely.\\n\"],\"event_data\":null,\"fn_index\":4,\"trigger_id\":22,\"session_hash\":\"8oy7w3p41\"}",
//     "method": "POST"
//   });

==== playground/parts.mjs ====
import { Client, handle_file } from "@gradio/client";

const CLIENT = "https://wondervictor-evf-sam2.hf.space";

(async() => {
  try {
    const app = await Client.connect(CLIENT);
    console.log("Client connected:", !!app);
    const apiInfo = await app.view_api();
    console.log(JSON.stringify(apiInfo, null, 2));
  } catch (error) {
    console.error("Error in main function:", error);
  }
})();

==== playground/references.md ====

https://bytedance-research-uno-flux.hf.space/gradio_api/info
https://bytedance-research-uno-flux.hf.space/info

general info?
https://huggingface.co/api/spaces/by-subdomain/bytedance-research-uno-flux

==== playground/talker.mjs ====
import { Client, handle_file } from "@gradio/client";

import "dotenv/config";


const CLIENT = "/fffiloni/KDTalker";

function main() {
  try { 
    const client = new Client(CLIENT);
    console.log("Client:", client);

  } catch (error) {
    console.error("Error initializing client:", error);
  }
}
main();


==== playground/test-curl.mjs ====
import dotenv from 'dotenv';
import { EventSource } from 'eventsource';

// Load environment variables from .env.local
dotenv.config();

const BASE_URL = "https://bytedance-research-uno-flux.hf.space/";
const USE_HF_TOKEN = true; // Set to false to disable token usage
const API_ENDPOINT = "gradio_api/call/gradio_generate";
const HF_TOKEN = process.env.HF_TOKEN || null;
const IMAGE_URLS = [
  "https://bytedance-research-uno-flux.hf.space/file=/assets/examples/4two2one/ref1.png",
  "https://bytedance-research-uno-flux.hf.space/file=/assets/examples/4two2one/ref2.png"
];


if (!HF_TOKEN && USE_HF_TOKEN) {
  console.warn("Warning: HF_TOKEN not set. Some features may not work. " +  HF_TOKEN);
}

async function readStreamWithTimeout(reader, timeoutMs = 5000) {
  const chunks = [];
  let timeout;
  
  try {
    const timeoutPromise = new Promise((_, reject) => {
      timeout = setTimeout(() => reject(new Error('Stream read timeout')), timeoutMs);
    });

    while (true) {
      const readPromise = reader.read();
      const {done, value} = await Promise.race([readPromise, timeoutPromise]);
      
      if (done) break;
      chunks.push(value);
    }
    
    return Buffer.concat(chunks).toString('utf8');
  } finally {
    clearTimeout(timeout);
  }
}

async function runCurlStyleTest() {
  console.log("Starting curl-style Gradio test...");
  
  try {
    // 1. Make initial POST request
    console.log("Making POST request to:", BASE_URL + API_ENDPOINT);
    const headers = { "Content-Type": "application/json" };
    if (USE_HF_TOKEN && process.env.HF_TOKEN) {
      headers["Authorization"] = `Bearer ${process.env.HF_TOKEN}`;
      console.log("Using HF Token for authentication");
    }

    const postResponse = await fetch(BASE_URL + API_ENDPOINT, {
      method: "POST",
      headers: headers,
      body: JSON.stringify({
        data: [
          "The logo is printed on the cup",
          512, 512, 4, 25, 61733557,
          { name: "ref1.png", data: IMAGE_URLS[0], is_file: true },
          { name: "ref2.png", data: IMAGE_URLS[1], is_file: true },
          null, null
        ]
      })
    });

    console.log("POST response status:", postResponse.status);
    
    if (!postResponse.ok) {
      const error = await postResponse.text();
      console.error("POST failed:", error);
      throw new Error(`POST failed: ${postResponse.status}`);
    }

    const { event_id } = await postResponse.json();
    if (!event_id) throw new Error("No event_id received");
    console.log("Received event_id:", event_id);

    // 2. Try SSE first, fallback to polling if needed
    return new Promise(async (resolve, reject) => {
      const getUrl = `${BASE_URL}${API_ENDPOINT}/${event_id}`;
      
      // First try SSE
      try {
        console.log("Attempting SSE connection to:", getUrl);
        const eventSource = new EventSource(getUrl, {
          withCredentials: false
        });

        eventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log("SSE event:", data.msg);
            
            if (data.msg === "process_completed") {
              eventSource.close();
              resolve(data.data || data.output?.data);
            } else if (data.msg === "process_failed") {
              eventSource.close();
              reject(new Error(data.output?.error || "Prediction failed"));
            }
          } catch (e) {
            console.error("Error parsing SSE data:", e);
          }
        };

        eventSource.onerror = (err) => {
          console.error("SSE error - falling back to polling:", err);
          eventSource.close();
          startPolling(getUrl, resolve, reject);
        };
      } catch (sseError) {
        console.error("SSE init failed - falling back to polling:", sseError);
        startPolling(getUrl, resolve, reject);
      }

      // Polling fallback
      async function startPolling(url, resolve, reject) {
        const MAX_RETRIES = 30;
        const POLL_INTERVAL = 2000;
        let retries = 0;
        console.log("Starting polling...");

        const poll = async () => {
          try {
            console.log(`Polling attempt ${retries + 1}/${MAX_RETRIES}`);
            const headers = { "Content-Type": "application/json" };
            if (USE_HF_TOKEN && process.env.HF_TOKEN) {
              headers["Authorization"] = `Bearer ${process.env.HF_TOKEN}`;
            }

            const response = await fetch(url, {
              headers: headers
            });
            console.log("Polling response status:", response.status);

            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            // Read response as stream and parse SSE messages
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let doneReading = false;

            while (!doneReading) {
              const { done, value } = await reader.read().catch(err => {
                // Handle potential read errors (like connection closed)
                console.error("Stream read error:", err);
                return { done: true, value: undefined }; // Treat as done
              });

              if (done) {
                doneReading = true;
                // Process any remaining buffer content if stream closes unexpectedly
                if (buffer.trim()) {
                   console.warn("Stream ended with unprocessed buffer:", buffer);
                }
                break;
              }

              buffer += decoder.decode(value, { stream: true });
              console.log(`Received chunk (${value.length} bytes), buffer size: ${buffer.length}`);

              // Process complete SSE messages (separated by \n\n)
              let messageEndIndex;
              while ((messageEndIndex = buffer.indexOf('\n\n')) !== -1) {
                const message = buffer.substring(0, messageEndIndex);
                buffer = buffer.substring(messageEndIndex + 2); // Consume message from buffer

                let eventType = null;
                let eventData = null;

                for (const line of message.split('\n')) {
                  if (line.startsWith('event:')) {
                    eventType = line.substring(6).trim();
                  } else if (line.startsWith('data:')) {
                    eventData = line.substring(5).trim();
                  }
                }

                console.log(`Parsed SSE Message: event=${eventType}, data=${eventData}`);

                if (eventType === 'error' && eventData?.includes('Session not found')) {
                  console.error("Explicit Session Not Found error received.");
                  reader.cancel(); // Stop reading
                  reject(new Error('Session not found (received from server)'));
                  return; // Exit poll function immediately
                } else if (eventType === 'complete') {
                   console.log("Process completed event received.");
                   reader.cancel();
                   try {
                     // Attempt to parse the data as JSON for the final result
                     const finalResult = JSON.parse(eventData || '{}');
                     resolve(finalResult.data || finalResult.output?.data || finalResult);
                   } catch (parseError) {
                     console.error("Failed to parse 'complete' event data:", parseError, "Raw data:", eventData);
                     reject(new Error("Failed to parse completion data"));
                   }
                   return; // Exit poll function
                } else if (eventType === 'generating') {
                   console.log("Generating event:", eventData);
                   // Could potentially update UI here in a real app
                } else if (eventType === 'heartbeat') {
                   console.log("Heartbeat received.");
                } else {
                   console.log("Received unknown/unhandled event type:", eventType);
                }
              }
            } // end while(!doneReading)

            // If the stream finished without a 'complete' or specific 'error' event
            if (doneReading) {
               console.warn("Stream ended without a definitive 'complete' or 'Session not found' event.");
               // Decide whether to retry based on what happened
               if (retries < MAX_RETRIES) {
                 // Allow retry if stream just ended cleanly without a result
                 console.log("Allowing retry as stream ended cleanly.");
               } else {
                 reject(new Error("Stream ended after max retries without completion"));
                 return;
               }
            }

            // If we fall through here, it means the stream ended cleanly OR
            // an error occurred that wasn't 'Session not found', allow retry logic below
            if (retries < MAX_RETRIES) {
                retries++;
                setTimeout(poll, POLL_INTERVAL);
              } else {
                reject(new Error("Max polling retries reached"));
              }
            } catch (error) {
              console.error("Polling error:", error);
              if (retries < MAX_RETRIES) {
                retries++;
                setTimeout(poll, POLL_INTERVAL);
              } else {
                reject(error);
              }
            }
        };

        await poll();
      }
    });
  } catch (error) {
    console.error("Test failed:", error);
    throw error;
  }
}

// Run test
runCurlStyleTest()
  .then(data => console.log("\n--- SUCCESS ---\nResult:", data))
  .catch(err => console.error("\n--- ERROR ---\n", err));


==== playground/test.mjs ====
import { Client, handle_file } from "@gradio/client";

const CLIENT = "bytedance-research/UNO-FLUX";

const IMAGE_URLS = [
  "https://images.unsplash.com/photo-1570784332176-fdd73da66f03?fm=jpg&q=60&w=3000&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
  "https://images.unsplash.com/photo-1567446537708-ac4aa75c9c28?fm=jpg&q=60&w=3000&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
];

// The function exposed by Gradio app (often at index 0)
const FUNCTION_INDEX = "gradio_api/gradio_generate";

(async function () {
  try {
    console.log("Starting @gradio/client test (by index, with static images)...");

    // Spoof headers to make it look like a browser request
    const browserHeaders = {
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/110.0.0.0 Safari/537.36",
      "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8",
      "Referer": "https://bytedance-research-uno-flux.hf.space/"
    };

    // Fetch images with headers
    const responses = await Promise.all(IMAGE_URLS.map(url =>
      fetch(url, { headers: browserHeaders })
    ));

    if (!responses.every(r => r.ok)) {
      const failedResponses = responses.filter(r => !r.ok);
      console.error("Failed response details:", failedResponses.map(r => ({
        url: r.url,
        status: r.status,
        statusText: r.statusText
      })));
      throw new Error(`Failed to fetch one or more example images (status not OK).`);
    }

    const images = await Promise.all(responses.map(r => r.blob()));
    console.log(`Successfully fetched ${images.length} example images.`);

    const params = {
      prompt: "The logo is printed on the cup",
      width: 512,
      height: 512,
      guidance: 4,
      num_steps: 25,
      seed: 61733557,
      image_prompt1: images[0],
      image_prompt2: images[1],
      image_prompt3: null,
      image_prompt4: null,
    };
    console.log("Parameters prepared:", params);

    const app = await Client.connect(CLIENT);
    console.log("Client connected:", !!app);

    const apiInfo = await app.view_api();
    console.log({apiInfo});

    console.log({FUNCTION_INDEX});
    const submission = app.submit(FUNCTION_INDEX, params);
    console.log("Submission started:", submission);

    for await (const msg of submission) {
      if (msg.type === "data") {
        console.log("Received data chunk:", msg.data);
        // msg.data = [generated_image_data, download_filepath]
      }

      if (msg.type === "status") {
        console.log("Status update:", msg);
        if (msg.stage === "complete") {
          console.log("Prediction complete.");
        } else if (msg.stage === "error") {
          console.error("Prediction failed:", msg.detail);
          throw new Error(`Prediction failed at stage ${msg.stage}: ${msg.detail}`);
        }
      }
    }

    console.log("@gradio/client test finished successfully.");

  } catch (error) {
    console.error("@gradio/client test failed:", error.message);
  }
})();


==== postcss.config.mjs ====
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;


==== productSpec.md ====
# Product Spec

The idea is to my to be able to create apps faster, the problem I face generally is that I 
use so much time for build apps, so with this platform, the idea is be able to connect 
replicate or gradio demos and endpoits super easy, given a form.

Desire Output: The idea is to just have to put the url, or just copy the API document, like
the one for vercel nodejs, or any no?, and it generate the app. And inclusivily some AI could
complete the fields, and the user just edit.

In that way, I can 'build' an app every day,
that help my grow my audience,
Or showcase to a clients, and get clients easier, because I need money, and this is a way
to show my worth, and get more clients, in any case.
But in the end, it could be amazing to be able to connect apps and build like modules, to 
build more complex, or even AI apps, that could be like a AI assembly, where you can just
connect things. ðŸ¤¯

Finally maybe it could be a no-code AI platform,

Some alternative is comfyUI, the problem is that need a setup, and configuration, the amazing
thing about this platform, is that relay on serverless platforms, so the people doesn't need
to take care or any configuration, is the vercel of the fronted ... So maybe better if calling a
endpoint.

Maybe is so complex to be build by myself, but at least help me build faster, and in that 
way validate ideas super quickly and in that way, have more time for  make Marketing, something
super important, given that idk mucho how to do that, and is super important if I really want
to be able to build and market, and make a business like indie hacker, and solopreuner.

Maybe I could open source it, in that way I get help for others, on why not init a VC, if 
I see that necessary, for now I think is easy to make the form work, and launch it like the
30 product.
Of course if I wanto to productizate it, I need to make it more streighforward, and easy to use,
for example, be able to deploy a specific version of it, and not all the code, but the principal
components,

And when create the app have the posibility to see the result and test the endpoints, in the same view,

As maybe the continuation of this is to connect with the possibility to create chatbots,
and it to be integrated, in a node base platform, where the people can just connect different
modules like text based, or image based, or of any type, like sound, video, etc. And be able
to build apps like a AI assembly, where you can just connect things. And it deploy and app,
just like the wordpress, or etc, for no code, That is super ambitions, 
Maybe never is going to be developed fully, but I can at least solve my first order problem, be able to generate MVPs super fast, and validate that in the market, having more time to focus on marketing, and sales. And if something works, go full on finish of develop the idea.

Other problem, and because I started this project, is to be able to copy and paste the code,
when I build apps, instead of re make all from scratch, the problem is that I create apps like
I walk, so I have so much projects and files on my computer, I dont remember where each
specific part of the code of moduler, or functionallity I have, so it could be amazing to
have a boilerplate, that always could be updating, a system and a way a time I build a code,
it always remain and can use easly, maybe creating a github repo, that I get the modules I need,
and it update for this boilerplate, when I update something.

Now something super insteresting, is that now I use cursor, so the AI build super fast by me,
But inclusivily it fail a lot (other is understand very well each thing I do, and because I
know how it works very well, I can create code very fast), other point is that a lot of code
has been made already, the idea is not to re make the wheel. So in the end a boilerplate,
connected with the AI could be amazing, yes a github repo, with all my code, and be able
to fetch parts, like ok I need a grid cards, no, I need a flex cards, etc. Maybe the most
manually way is just to have a repo, with components, for example. But in another way it
could be amazing to habe the ability to not just for UI components, but for functionallity, like
for example integrate mongoDB database, create a CRUD, add auth0, that are libraries no?,
Are different problems, but is the way the create apps from a js object.

Now other challenge for create an app from a js object, is modify the UI, I need to build the
different components, but it is a little bit strict, but what if I need create a side bar,
with text area, with other inputs, and the outputs to save the results, that is basicly photoai,
or magnific, no?, ok when I build that, I'll update that, and ideally integrate that on my
apps generator, this one.
And integrate other functionallyties, like change the colors, styles.

And other incredible functionality is the AI to edit and help to build thigs, that is amazing,
just like I said to help to complete the fields, or the form/json generator. and as I said to be able to connect different type of models, like text, images, audiot, any ... that is amazing.
Generating Super Agentic Workflows. And in the end, just like j4Next that create chatbots at
one conversation deployed on wahtsapp (what is incredible because could give the power of anyone
to create complex AIs, democratizate AI creation, democratizate AI creation), or my idea of
integrate the UI to be UI/AI interaction.

The problem whit all this, is that is super complex, is a visionary project. But in the end, in 
what always I have been, so not matter what direction take it, I need to concentrate on Marketing, and monetizate each step, start smaller as possible, and monetizate that step.
It's like, instead of first create the super system, first create a simple chatbot that make 
a terapist, with a simple prompt, and monetizate that ... build by modules, monetizate each step.
And that is my salvation ...



## Summary 

Organized Summary of Projects from Product Spec
1. Rapid App Creation Platform
Main Goal
Create a platform to build apps faster by easily connecting to existing AI models and APIs.
Key Features

Connect to replicate or gradio demos and endpoints easily
Generate app structure from API documentation
AI-assisted form completion
Serverless architecture (like Vercel for frontend)

Benefits

Build an app every day
Grow audience
Showcase to clients
Validate ideas quickly

Future Scope

Connect apps and build modules
AI assembly for complex AI apps
Potential to become a no-code AI platform

2. Personal Code Boilerplate System
Main Goal
Efficiently reuse and manage personal code across projects.
Key Features

GitHub repo with reusable code modules
Easy fetching of specific code parts (e.g., grid cards, flex cards)
Integration with AI for faster code generation
Includes both UI components and functionalities (e.g., MongoDB integration, CRUD operations, Auth0)

Connection to Project 1
Could be integrated into the Rapid App Creation Platform to provide pre-built components and functionalities.
3. AI-Assisted App Customization
Main Goal
Enhance app creation with AI-powered customization and editing.
Key Features

AI helps complete fields in app generation forms
Edit and customize UI elements (e.g., sidebars, text areas, inputs)
Change colors and styles easily
Connect different types of AI models (text, images, audio)

Connection to Projects 1 & 2
This could be an advanced feature of the Rapid App Creation Platform, utilizing components from the Personal Code Boilerplate.
4. Super Agentive Workflows
Main Goal
Create a system for generating complex AI workflows.
Key Features

Connect different types of AI models
Create chatbots deployable on platforms like WhatsApp
Integrate UI for AI interaction

Connection to Other Projects
This is an advanced concept that could be the ultimate evolution of the Rapid App Creation Platform.
5. Monetization Strategy
Main Goal
Focus on marketing and monetizing each step of development.
Key Features

Start with smaller, manageable projects
Monetize each step or module
Example: Create a simple chatbot therapist with a basic prompt

Relevance to All Projects
This is a crucial strategy to apply across all project developments, ensuring sustainability and growth.
Overall Vision
The overarching goal is to create a comprehensive system for rapid AI app development and deployment, with a focus on user-friendly interfaces, reusability, and AI assistance throughout the process. The strategy involves starting small, monetizing each step, and gradually building towards more complex and integrated systems.


==== project_documentation.md ====
# AI App Generation Platform (Project "changebg")

## Table of Contents
- [Overview](#overview)
- [Architecture](#architecture)
- [Core Features & Modules](#core-features--modules)
- [Key Technologies & Libraries](#key-technologies--libraries)
- [Directory Structure](#directory-structure)
- [Important Files & Their Roles](#important-files--their-roles)
- [API Endpoints](#api-endpoints)
- [Data Flow Examples](#data-flow-examples)
- [Code Examples](#code-examples)
- [Future/Experimental Features](#futureexperimental-features)
- [Notes & Potential Improvements](#notes--potential-improvements)

## Overview

This Next.js project serves as a platform for rapidly creating and deploying web applications that interface with AI models, primarily from **Replicate** and **Gradio**. The core concept is to define an "app" via a configuration (specifying inputs, outputs, and backend model details), store this configuration, and then dynamically render a UI for users to interact with the AI model.

### Key Functionalities

- **Dynamic App Creation**: Users can define new "apps" through a UI or JSON configuration
- **Dynamic App Rendering**: Generated apps are accessible via unique slugs (`/app/[slug]`)
- **AI Model Integration**: Supports both Replicate and Gradio models
- **App Preview**: Allows testing configurations before saving
- **Server-Sent Events (SSE)**: Experimental support for real-time updates from Gradio
- **Database Storage**: MongoDB for storing app configurations
- **Pre-built Tools**: Several standalone AI tools (IlluminAI, Upscaler, etc.)

## Architecture

- **Frontend**: Next.js (App Router), React, Tailwind CSS
- **Backend**: Next.js API Routes
- **Database**: MongoDB
- **AI Model Providers**:
  - Replicate (via `replicate` npm package and direct API calls)
  - Gradio (via `@gradio/client` npm package and direct API calls, including SSE)

## Core Features & Modules

### 3.1. App Creation & Configuration

**UI Components:**
- Main UI: `/create` (`src/app/create/page.tsx`)
- Preview Component: `src/components/AppPreview.tsx`

**API Endpoints:**
- `POST /api/create` - Save configurations (`src/app/api/create/route.ts`)
- `GET /api/create/get` - Fetch configurations (`src/app/api/create/get/route.ts`)
- `POST /api/create/fetch-model-details` - Model schema introspection (`src/app/api/create/fetch-model-details/route.ts`)

**Data Storage:**
- MongoDB integration via `src/lib/mongodb.ts`
- Configuration schema defined in `src/types/index.ts` (InputItem, OutputItem, Configuration)

#### Workflow

1. **Navigation**: User navigates to `/create`
2. **Model Selection**: User selects app type (Replicate/Gradio) and provides model/client details
3. **Schema Fetching**: 
   - For **Replicate**: Fetches model schema from `https://api.replicate.com/v1/models/{model}/versions/{version}`
   - For **Gradio**: Uses `@gradio/client`'s `Client.connect(client).view_api()` or fetches from `{gradio_space_url}/info`
4. **Configuration**: Fetched schema populates input/output fields, user can edit properties
5. **Preview/Edit**: User can switch between "Form" and "JSON" views
6. **Save**: Final configuration is submitted and saved to MongoDB

#### Configuration Merging

- `src/common/configuration.ts` defines `configurationsObj` (hardcoded configurations)
- `getConfigurations(forceRefresh?: boolean)` merges database configurations with hardcoded ones
- This serves as the primary source of app definitions for the entire application

### 3.2. Dynamic App Rendering

**Components:**
- Page Template: `/app/[slug]` (`src/app/app/[slug]/page.tsx` and `ClientPage.tsx`)

**API Endpoints:**
- `POST /api/app/[slug]` - Execute predictions (`src/app/api/app/[slug]/route.ts`)
- `POST /api/app/[slug]/get` - Status check for Replicate (`src/app/api/app/[slug]/get/route.ts`)

#### Workflow

1. **Page Load**: User navigates to `/app/[slug]`
2. **Server Component**: Fetches `initialConfigurations` using `getConfigurations()`
3. **Client Component**: `ClientPage.tsx` renders dynamic UI based on configuration
4. **Input Handling**: User provides inputs (text, file uploads converted to base64)
5. **Prediction Execution**:
   - **Replicate**: Creates prediction, returns prediction ID, polls for results
   - **Gradio**: Executes prediction directly, returns immediate results
6. **Results Display**: Updates UI with outputs based on `config.outputs`

### 3.3. App Preview Feature

**Integration**: Within `/create` page via "Preview" tab
**Component**: `src/components/AppPreview.tsx`
**API Endpoints:**
- `POST /api/preview` - Preview predictions (`src/app/api/preview/route.ts`)
- `GET /api/preview/get` - Preview status check (`src/app/api/preview/get/route.ts`)

#### Workflow

1. **Preview Mode**: User selects "Preview" tab in `/create`
2. **Dynamic Rendering**: `AppPreview.tsx` renders inputs based on current draft config
3. **Testing**: User interacts with inputs and clicks "Test Configuration"
4. **Execution Options**:
   - **SSE Enabled**: For Gradio with experimental SSE support
   - **Standard**: Uses preview API endpoints for polling-based results
5. **Results**: Displays outputs based on configuration

### 3.4. Server-Sent Events (SSE) for Gradio (Experimental)

**Documentation**: `docs/sse-implementation.md`
**API Endpoints:**
- `POST /api/experimental/sse/init` - Initiate SSE prediction
- `GET /api/experimental/sse/stream` - Stream SSE data
**Utilities**: `src/utils/gradio.ts`

#### Workflow

1. **Initiation**: `AppPreview.tsx` sends POST to `/api/experimental/sse/init`
2. **Event ID**: Gradio API returns an `event_id`
3. **Stream Connection**: Client creates EventSource to `/api/experimental/sse/stream`
4. **Real-time Updates**: Server pipes Gradio stream directly to client
5. **Event Handling**: Client listens for messages and updates UI progressively

### 3.5. Static/Specific Tools

Pre-defined applications with dedicated pages and API routes:

| Tool | UI Route | API Route | Model |
|------|----------|-----------|--------|
| IlluminAI | `/illuminai` | `POST /api/illuminai` | `zsxkib/ic-light` |
| Upscaler | `/upscaler` | `POST /api/upscale` | `philz1337x/clarity-upscaler` |
| Remove Background | `/removebg` | `POST /api/removebg` | `codeplugtech/background_remover` |
| Enhance Background | `/enhancebg` | `POST /api/enhancebg` | Various models |
| Simpson | `/simpson` | `POST /api/simpson` | Simpson-style generation |
| Interior Design | `/` (homepage) | `POST /api/inter-design` | Interior design models |

## Key Technologies & Libraries

### Core Framework
- **Next.js 14+** (App Router)
- **React 18**
- **TypeScript**
- **Tailwind CSS**

### AI Integration
- **Replicate Client** (`replicate` npm) - Replicate model interactions
- **Gradio Client** (`@gradio/client` npm) - Gradio space/API interactions

### Database & Storage
- **MongoDB** (`mongodb` npm) - Configuration storage

### UI Components & Utilities
- **React Dropzone** (`react-dropzone` npm) - File uploads
- **FileSaver.js** (`file-saver` npm) - Client-side downloads
- **React Loader Spinner** - Loading indicators
- **Axios** - HTTP requests (alongside native `fetch`)

### Icons & Styling
- **Heroicons**
- **Lucide React**
- **React Icons**

### Experimental Features
- **EventSource Polyfill** (`eventsource` npm) - SSE support

## Directory Structure

```
src/
â”œâ”€â”€ app/                          # Next.js App Router
â”‚   â”œâ”€â”€ (pages)/                  # Main UI pages
â”‚   â”œâ”€â”€ app/[slug]/              # Dynamic app rendering
â”‚   â”œâ”€â”€ api/                     # Backend API routes
â”‚   â”‚   â”œâ”€â”€ app/[slug]/          # Dynamic app APIs
â”‚   â”‚   â”œâ”€â”€ create/              # App creation APIs
â”‚   â”‚   â”œâ”€â”€ experimental/sse/    # SSE APIs
â”‚   â”‚   â””â”€â”€ [tool-apis]/         # Specific tool APIs
â”‚   â””â”€â”€ create/                  # App creation UI
â”œâ”€â”€ common/                      # Shared configurations
â”‚   â”œâ”€â”€ configuration.ts         # Central app definitions
â”‚   â””â”€â”€ index.ts                 # Navigation items
â”œâ”€â”€ components/                  # Reusable React components
â”œâ”€â”€ lib/                         # Utility modules
â”‚   â””â”€â”€ mongodb.ts              # MongoDB connection
â”œâ”€â”€ types/                       # TypeScript definitions
â”œâ”€â”€ utils/                       # General utilities
â””â”€â”€ experimental/sse-handler/    # SSE placeholder files

docs/                            # Project documentation
playground/                      # Testing scripts
public/                         # Static assets
```

## Important Files & Their Roles

| File | Purpose |
|------|---------|
| `src/common/configuration.ts` | Central logic for app definitions, merges hardcoded configs with DB-fetched ones |
| `src/app/create/page.tsx` | UI for creating new app configurations |
| `src/app/api/create/fetch-model-details/route.ts` | Backend logic to get schema/info from Replicate/Gradio |
| `src/app/app/[slug]/ClientPage.tsx` | Renders UI for dynamically configured apps |
| `src/app/api/app/[slug]/route.ts` | Backend logic for running predictions for dynamic apps |
| `src/components/AppPreview.tsx` | Real-time app preview component during creation |
| `src/app/api/preview/route.ts` | Backend logic for handling preview requests |
| `src/app/api/experimental/sse/init/route.ts` | SSE initiation for Gradio |
| `src/app/api/experimental/sse/stream/route.ts` | SSE streaming for Gradio |
| `src/types/index.ts` | Defines `Configuration`, `InputItem`, `OutputItem` types |

## API Endpoints

### Core Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| `POST` | `/api/create` | Create new app configuration in MongoDB |
| `GET` | `/api/create/get` | Fetch all app configurations |
| `POST` | `/api/create/fetch-model-details` | Fetch schema/info for Replicate/Gradio models |
| `POST` | `/api/app/[slug]` | Run prediction for app identified by slug |
| `POST` | `/api/app/[slug]/get` | Get status/result of Replicate prediction |
| `POST` | `/api/preview` | Run prediction in preview mode |
| `GET` | `/api/preview/get` | Get status/result for preview prediction |

### Experimental Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| `POST` | `/api/experimental/sse/init` | Initiate SSE-based Gradio prediction |
| `GET` | `/api/experimental/sse/stream` | Stream Gradio prediction events |

### Tool-Specific Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| `POST` | `/api/illuminai` | IlluminAI tool prediction |
| `POST` | `/api/upscale` | Image upscaling |
| `POST` | `/api/removebg` | Background removal |
| `POST` | `/api/enhancebg` | Background enhancement |
| `POST` | `/api/simpson` | Simpson-style generation |
| `POST` | `/api/inter-design` | Interior design generation |

## Data Flow Examples

### Dynamic App Execution (Replicate)

```mermaid
sequenceDiagram
    participant User
    participant ClientPage
    participant API
    participant Replicate
    participant MongoDB

    User->>ClientPage: Navigate to /app/my-replicate-app
    ClientPage->>MongoDB: Fetch configuration
    ClientPage->>User: Render input form
    User->>ClientPage: Fill inputs, click Submit
    ClientPage->>API: POST /api/app/my-replicate-app
    API->>MongoDB: Look up configuration
    API->>Replicate: Create prediction
    Replicate->>API: Return prediction ID
    API->>ClientPage: Return prediction ID
    
    loop Poll for results
        ClientPage->>API: POST /api/app/my-replicate-app/get
        API->>Replicate: Check prediction status
        Replicate->>API: Return status/output
        API->>ClientPage: Return status/output
    end
    
    ClientPage->>User: Display results when succeeded
```

### SSE-Based Gradio Execution

```mermaid
sequenceDiagram
    participant Client
    participant SSE_Init
    participant SSE_Stream
    participant Gradio

    Client->>SSE_Init: POST /api/experimental/sse/init
    SSE_Init->>Gradio: POST prediction request
    Gradio->>SSE_Init: Return event_id
    SSE_Init->>Client: Return event_id
    
    Client->>SSE_Stream: EventSource connection
    SSE_Stream->>Gradio: GET stream endpoint
    
    loop Real-time updates
        Gradio->>SSE_Stream: Stream events
        SSE_Stream->>Client: Forward events
        Client->>Client: Update UI progressively
    end
```

## Code Examples

### Replicate Prediction (from `src/app/api/app/[slug]/route.ts`)

```typescript
// Inside POST /api/app/[slug] when config.type === 'replicate'
const replicate = new Replicate({ auth: REPLICATE_API_TOKEN });
const model: `${string}/${string}` | `${string}/${string}:${string}` | undefined = config.model;
const version = config.version as string | undefined;
const input: { [key: string]: any } = {}; // Constructed from req and config.inputs

// ... logic to populate 'input' object ...

const output = await replicate.predictions.create({
  model,
  version,
  input,
});
return NextResponse.json(output, { status: 201 });
```

### Configuration Type Definition

```typescript
interface Configuration {
  name: string;
  type: 'replicate' | 'gradio';
  model?: string;
  version?: string;
  client?: string;
  endpoint?: string;
  inputs: InputItem[];
  outputs: OutputItem[];
}

interface InputItem {
  name: string;
  type: string;
  component: string;
  show: boolean;
  label: string;
  defaultValue?: any;
  // ... additional properties
}

interface OutputItem {
  name: string;
  type: string;
  component: string;
  show: boolean;
  label: string;
}
```

## Future/Experimental Features

### SSE Implementation
- **Status**: Experimental
- **Purpose**: Provide real-time progress updates instead of polling
- **Target**: Gradio models with streaming support
- **Documentation**: `docs/sse-implementation.md`

### Vision & Roadmap
According to `productSpec.md`, the project has ambitious goals including:
- AI assembly capabilities
- No-code AI platform
- Super agentic workflows
- Enhanced user experience for AI interaction

## Notes & Potential Improvements

### Security Considerations
- âœ… **API Keys**: Properly managed via environment variables
- âš ï¸ **Input Validation**: Could be enhanced across API routes
- âš ï¸ **Rate Limiting**: Not currently implemented

### Code Quality
- **Shared Logic**: `ClientPage.tsx` and `AppPreview.tsx` could benefit from more shared components
- **Error Handling**: Present but could be more standardized
- **TypeScript**: Well-typed throughout the application

### Performance
- **Caching**: `getConfigurations()` uses 3600s revalidation with cache-busting support
- **File Handling**: Base64 conversion for files could be optimized for large uploads
- **Database**: MongoDB queries could benefit from indexing strategies

### Architecture
- **Separation of Concerns**: Clear separation between static tools and dynamic apps
- **Modularity**: Good component structure with reusable elements
- **Scalability**: Current architecture supports adding new AI providers

### Development Experience
- **Documentation**: Well-documented with inline comments and separate docs
- **Testing**: `playground/` directory provides good examples for testing integrations
- **Debugging**: SSE implementation includes comprehensive error handling

### Known Limitations
- **File Size**: Large file uploads may face browser/server limits with base64 encoding
- **SSE Support**: Currently experimental and limited to Gradio
- **Model Discovery**: Manual model configuration required (no automatic discovery)
- **Preview Isolation**: Uses `X-Preview-Mode` header concept but implements via separate endpoints

This documentation provides a comprehensive overview of the AI App Generation Platform, serving as both a technical reference and architectural guide for developers working with the system.


==== project_dump.txt ====
ðŸ“ Project Tree:

â”œâ”€â”€ README.md
â”œâ”€â”€ TODO.md
â”œâ”€â”€ docs
â”‚   â””â”€â”€ sse-implementation.md
â”œâ”€â”€ instructions.md
â”œâ”€â”€ next.config.mjs
â”œâ”€â”€ package.json
â”œâ”€â”€ playground
â”‚   â”œâ”€â”€ image.png
â”‚   â”œâ”€â”€ index.mjs
â”‚   â”œâ”€â”€ parts.mjs
â”‚   â”œâ”€â”€ references.md
â”‚   â”œâ”€â”€ talker.mjs
â”‚   â”œâ”€â”€ test-curl.mjs
â”‚   â””â”€â”€ test.mjs
â”œâ”€â”€ postcss.config.mjs
â”œâ”€â”€ productSpec.md
â”œâ”€â”€ project_documentation.md
â”œâ”€â”€ public
â”‚   â”œâ”€â”€ next.svg
â”‚   â””â”€â”€ vercel.svg
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”œâ”€â”€ ClientSidebarWrapper.tsx
â”‚   â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [slug]
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ get
â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ create
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ fetch-model-details
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ get
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ enhancebg
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ experimental
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ sse
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ init
â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ predict
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ stream
â”‚   â”‚   â”‚   â”‚           â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ illuminai
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ inter-design
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ preview
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ get
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ removebg
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ simpson
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â””â”€â”€ upscale
â”‚   â”‚   â”‚       â””â”€â”€ route.ts
â”‚   â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”‚   â””â”€â”€ [slug]
â”‚   â”‚   â”‚       â”œâ”€â”€ ClientPage.tsx
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ chat
â”‚   â”‚   â”‚   â””â”€â”€ [slug]
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ create
â”‚   â”‚   â”‚   â”œâ”€â”€ list
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ desktop-sidebar.tsx
â”‚   â”‚   â”œâ”€â”€ enhancebg
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â”œâ”€â”€ header.tsx
â”‚   â”‚   â”œâ”€â”€ illuminai
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”œâ”€â”€ mobile-sidebar.tsx
â”‚   â”‚   â”œâ”€â”€ on-device
â”‚   â”‚   â”‚   â””â”€â”€ [slug]
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ providers.tsx
â”‚   â”‚   â”œâ”€â”€ removebg
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ selectmenu.tsx
â”‚   â”‚   â”œâ”€â”€ sidebar.tsx
â”‚   â”‚   â”œâ”€â”€ simpson
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â””â”€â”€ upscaler
â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ common
â”‚   â”‚   â”œâ”€â”€ configuration.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”œâ”€â”€ AppPreview.tsx
â”‚   â”‚   â”œâ”€â”€ audioOutput.tsx
â”‚   â”‚   â”œâ”€â”€ numericInput.tsx
â”‚   â”‚   â”œâ”€â”€ prompt.tsx
â”‚   â”‚   â””â”€â”€ textOutput.tsx
â”‚   â”œâ”€â”€ experimental
â”‚   â”‚   â””â”€â”€ sse-handler
â”‚   â”‚       â”œâ”€â”€ client.ts
â”‚   â”‚       â”œâ”€â”€ route.ts
â”‚   â”‚       â””â”€â”€ utils.ts
â”‚   â”œâ”€â”€ lib
â”‚   â”‚   â””â”€â”€ mongodb.ts
â”‚   â”œâ”€â”€ types
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ utils
â”‚       â”œâ”€â”€ gradio.ts
â”‚       â””â”€â”€ index.ts
â”œâ”€â”€ tailwind.config.ts
â”œâ”€â”€ tmp
â”‚   â”œâ”€â”€ gradio_test.ts
â”‚   â”œâ”€â”€ playground.ts
â”‚   â”œâ”€â”€ response_app_info.json
â”‚   â”œâ”€â”€ test.ts
â”‚   â”œâ”€â”€ test2.ts
â”‚   â””â”€â”€ test3.ts
â””â”€â”€ tsconfig.json


ðŸ“„ File Contents:

==== README.md ====
https://pyramid-flow-pyramid-flow.hf.space/gradio_api/info
https://www.gradio.app/guides/getting-started-with-the-js-client#inspecting-the-api-endpoints


This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.


==== TODO.md ====
(Skipped binary or unreadable file)

==== docs/sse-implementation.md ====
# Server-Sent Events (SSE) Integration

## Overview
This document describes the experimental SSE implementation for real-time Gradio API interactions.

```mermaid
graph TD
    A[Frontend] -->|POST /discover| B[SSE Discovery]
    B -->|Success| C[SSE Connection]
    B -->|Fallback| D[Polling]
    C --> E[Event Stream]
    D --> F[Interval Requests]
```

## File Structure
```
src/experimental/sse-handler/
â”œâ”€â”€ route.ts         # API endpoints
â”œâ”€â”€ client.ts        # Frontend utilities
â”œâ”€â”€ utils.ts         # Shared functions
â””â”€â”€ types.ts         # Type definitions
```

## API Reference

### Discovery Endpoint
`POST /api/experimental/sse/discover`

**Request:**
```typescript
interface DiscoverRequest {
  baseUrl: string;  // Gradio app URL
}
```

**Response:**
```typescript
interface DiscoverResponse {
  success: boolean;
  supportsSSE: boolean;
  endpoints: string[];
  error?: string;
}
```

### SSE Client API

```typescript
class SSEClient {
  constructor(url: string);
  
  // Connect to SSE stream
  connect(): Promise<EventSource>;
  
  // Process messages
  onMessage(callback: (data: SSEMessage) => void): void;
  
  // Error handling  
  onError(callback: (error: Error) => void): void;
}
```

## Implementation Details

### Sequence Diagram
```mermaid
sequenceDiagram
    Frontend->>+Backend: POST /discover
    Backend->>+Gradio: GET /info
    Gradio-->>-Backend: API Info
    Backend-->>-Frontend: Endpoints List
    Frontend->>+Gradio: SSE Connect
    Gradio->>Frontend: Event Stream
```

### Error Handling
1. **Discovery Failure**:
   - Retry with `/gradio_api/info`
   - Fallback to polling if both fail

2. **Connection Issues**:
   ```javascript
   eventSource.onerror = () => {
     if (eventSource.readyState === EventSource.CLOSED) {
       startPollingFallback();
     }
   };
   ```

## Usage Example

### Frontend Implementation
```typescript
import { discoverSSE, SSEClient } from '@/experimental/sse-handler/client';

async function runProcess() {
  const discovery = await discoverSSE('https://app.hf.space');
  
  if (discovery.supportsSSE) {
    const client = new SSEClient(discovery.endpoints[0]);
    client.onMessage((data) => {
      console.log('Update:', data);
    });
    await client.connect();
  } else {
    // Fallback to polling
  }
}
```

## Testing

### Test Cases
1. **Discovery Test**:
   ```javascript
   test('discovers SSE endpoints', async () => {
     const result = await discoverSSE(validUrl);
     expect(result.supportsSSE).toBeTruthy();
   });
   ```

2. **Connection Test**:
   ```javascript
   test('handles SSE connection', async () => {
     const client = new SSEClient(testUrl);
     const mockCallback = jest.fn();
     client.onMessage(mockCallback);
     await client.connect();
     expect(mockCallback).toHaveBeenCalled();
   });
   ```

## Migration Guide

### Enabling in Production
1. Set feature flag in `.env`:
   ```
   USE_SSE_EXPERIMENTAL=true
   ```
2. Update API routes to include SSE handlers
3. Deploy with monitoring


==== instructions.md ====
INSTRUCTIONS FOR CLAUDE 3.5: IMPLEMENTING APP PREVIEW FEATURE

Overview: Add an interactive preview feature to the app creation page that allows users to see and test their configurations in real-time before saving them.

Implementation Steps:

STEP 1: ADD PREVIEW MODE TO EDIT MODE STATE âœ“
- Add implementation progress tracking
- Update editMode state to include 'preview' option
- Add Preview tab button alongside Form and JSON tabs
- Basic preview mode switching functionality

STEP 2: CREATE A STANDALONE PREVIEW COMPONENT âœ“
- Build component that takes a configuration object
- Add proper input/output component types matching production app:
  * Use Dropzone for image uploads
  * Use Prompt component for text inputs
  * Use NumberInput/Slider for numeric values
  * Use Checkbox/CheckboxGroup for boolean inputs
- Match production app styling and layout
- Include state management for inputs, outputs, and loading

STEP 3: ADD API PREVIEW FLAG âœ“
- Include 'X-Preview-Mode': 'true' header in API requests
- Keep the same API endpoints but mark requests as previews
- Ensure preview requests are isolated from production data

STEP 4: INTEGRATE PREVIEW INTO CREATE PAGE âœ“
- Create draft configuration object from form values
- Add conditional rendering for preview mode
- Seamlessly switch between edit and preview modes
- Clean, production-like UI without preview banners

STEP 5: IMPLEMENT PREVIEW FUNCTIONALITY âœ“
- Full support for all input types:
  * File upload handling for images
  * Text input for prompts
  * Numeric inputs with validation
  * Checkbox and selection inputs
- Real-time preview updates
- Proper error handling and validation
- Loading states during API calls

STEP 6: ADD FINAL UI POLISH âœ“
- Clean, consistent styling matching production app
- Proper loading indicators
- Error message handling
- Download functionality for outputs
- Responsive layout and grid system

IMPLEMENTATION NOTES:
- Use the same component types as ClientPage.tsx for consistency
- Keep preview mode seamlessly integrated with the creation flow
- Maintain full functionality while staying isolated from production
- Focus on clean, professional UI without preview indicators


==== next.config.mjs ====
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    domains: ['replicate.delivery']
  },
  async headers() {
    return [
      // {
      //   source: '/(.*)',
      //   headers: [
      //     {
      //       key: 'Cross-Origin-Opener-Policy',
      //       value: 'same-origin',
      //     },
      //     {
      //       key: 'Cross-Origin-Embedder-Policy',
      //       value: 'require-corp',
      //     },
      //     {
      //       key: 'Cross-Origin-Resource-Policy',
      //       value: 'cross-origin',
      //     },

      //   ],
      // },
    ];
  },
  env: {
    BASE_URL_CHAT_AGENT_PY: process.env.BASE_URL_CHAT_AGENT_PY,
  }
};

export default nextConfig;


==== package.json ====
{
  "name": "changebg",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@diffusionstudio/vits-web": "^1.0.2",
    "@headlessui/react": "^2.1.0",
    "@heroicons/react": "^2.1.4",
    "@types/file-saver": "^2.0.7",
    "@vercel/analytics": "^1.3.1",
    "axios": "^1.7.4",
    "eventsource": "^3.0.6",
    "file-saver": "^2.0.5",
    "lucide-react": "^0.435.0",
    "mongodb": "^6.8.0",
    "next": "^14.2.5",
    "next-themes": "^0.3.0",
    "react": "^18",
    "react-dom": "^18",
    "react-dropzone": "^14.2.3",
    "react-icons": "^5.2.1",
    "react-loader-spinner": "^6.1.6",
    "react-markdown": "^9.0.1",
    "replicate": "^0.31.1"
  },
  "devDependencies": {
    "@gradio/client": "^1.4.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "dotenv": "^16.4.5",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}


==== playground/image.png ====
(Skipped binary or unreadable file)

==== playground/index.mjs ====
import { Client, handle_file } from "@gradio/client";
import { readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import "dotenv/config";

const CLIENT = "sesame/csm-1b";

const formatedEndpoints = [
  {
      "key": "/update_audio",
      "inputs": [
          {
              "key": "speaker",
              "component": "dropdown",
              "type": "string",
              "label": "Select a predefined speaker",
              "value": "conversational_a",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "speaker_prompt",
              "component": "audio",
              "type": "string",
              "title": "Speaker prompt",
              "show": true,
              "formatItem": "filepath"
          }
      ]
  },
  {
      "key": "/update_audio_1",
      "inputs": [
          {
              "key": "speaker",
              "component": "dropdown",
              "type": "string",
              "label": "Select a predefined speaker",
              "value": "conversational_b",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "speaker_prompt",
              "component": "audio",
              "type": "string",
              "title": "Speaker prompt",
              "show": true,
              "formatItem": "filepath"
          }
      ]
  },
  {
      "key": "/update_text",
      "inputs": [
          {
              "key": "speaker",
              "component": "dropdown",
              "type": "string",
              "label": "Select a predefined speaker",
              "value": "conversational_a",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "speaker_prompt",
              "component": "Textbox",
              "type": "string",
              "title": "Speaker prompt",
              "show": true,
              "formatItem": "str"
          }
      ]
  },
  {
      "key": "/update_text_1",
      "inputs": [
          {
              "key": "speaker",
              "component": "dropdown",
              "type": "string",
              "label": "Select a predefined speaker",
              "value": "conversational_b",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "speaker_prompt",
              "component": "Textbox",
              "type": "string",
              "title": "Speaker prompt",
              "show": true,
              "formatItem": "str"
          }
      ]
  },
  {
      "key": "/infer",
      "inputs": [
          {
              "key": "text_prompt_speaker_a",
              "component": "Textbox",
              "type": "string",
              "label": "Speaker prompt",
              "value": "like revising for an exam I'd have to try and like keep up the momentum because I'd start really early I'd be like okay I'm gonna start revising now and then like you're revising for ages and then I just like start losing steam I didn't do that for the exam we had recently to be fair that was a more of a last minute scenario but like yeah I'm trying to like yeah I noticed this yesterday that like Mondays I sort of start the day with this not like a panic but like a",
              "show": true,
              "required": false
          },
          {
              "key": "text_prompt_speaker_b",
              "component": "Textbox",
              "type": "string",
              "label": "Speaker prompt",
              "value": "like a super Mario level. Like it's very like high detail. And like, once you get into the park, it just like, everything looks like a computer game and they have all these, like, you know, if, if there's like a, you know, like in a Mario game, they will have like a question block. And if you like, you know, punch it, a coin will come out. So like everyone, when they come into the park, they get like this little bracelet and then you can go punching question blocks around.",
              "show": true,
              "required": false
          },
          {
              "key": "audio_prompt_speaker_a",
              "component": "audio",
              "type": "string",
              "label": "Speaker prompt",
              "value": {
                  "path": "/tmp/gradio/5b5ce26817597fa754ef96dedc86f448c1bac998d19a7cf4b0d79fcd0ca1ab16/conversational_a.wav",
                  "url": "https://github.com/gradio-app/gradio/raw/main/test/test_files/audio_sample.wav",
                  "size": null,
                  "orig_name": "conversational_a.wav",
                  "mime_type": null,
                  "is_stream": false,
                  "meta": {
                      "_type": "gradio.FileData"
                  }
              },
              "show": true,
              "required": false
          },
          {
              "key": "audio_prompt_speaker_b",
              "component": "audio",
              "type": "string",
              "label": "Speaker prompt",
              "value": {
                  "path": "/tmp/gradio/c8275e46be95249d7869f6290a90f1073a1182f62f9153ed0434513bd630d58f/conversational_b.wav",
                  "url": "https://github.com/gradio-app/gradio/raw/main/test/test_files/audio_sample.wav",
                  "size": null,
                  "orig_name": "conversational_b.wav",
                  "mime_type": null,
                  "is_stream": false,
                  "meta": {
                      "_type": "gradio.FileData"
                  }
              },
              "show": true,
              "required": false
          },
          {
              "key": "gen_conversation_input",
              "component": "Textbox",
              "type": "string",
              "label": "conversation",
              "value": "Hey how are you doing.\nPretty good, pretty good.\nI'm great, so happy to be speaking to you.\nMe too, this is some cool stuff huh?\nYeah, I've been reading more about speech generation, and it really seems like context is important.\nDefinitely.\n",
              "show": true,
              "required": false
          }
      ],
      "outputs": [
          {
              "key": "synthesized_audio",
              "component": "audio",
              "type": "string",
              "title": "Synthesized audio",
              "show": true,
              "formatItem": "filepath"
          }
      ]
  }
];

// Function to get endpoint configuration
function getEndpointConfig(endpointKey) {
  return formatedEndpoints.find(endpoint => endpoint.key === endpointKey);
}

// Function to prepare parameters for an endpoint
function prepareParams(endpointConfig, params = {}) {
  const processedParams = {};
  
  for (const input of endpointConfig.inputs) {
    // If a param value is provided, use it
    if (params[input.key] !== undefined) {
      processedParams[input.key] = params[input.key];
      continue;
    }
    
    // Otherwise use the default value if available
    if (input.value !== undefined) {
      processedParams[input.key] = input.value;
    }
  }
  
  return processedParams;
}

async function processFile(filePath) {
  const buffer = await readFile(filePath);
  return handle_file(new Blob([buffer]));
}

// Main test function
async function testEndpoint(endpointKey, customParams = {}) {
  try {
    // Get endpoint configuration
    const endpointConfig = getEndpointConfig(endpointKey);
    if (!endpointConfig) {
      throw new Error(`Endpoint ${endpointKey} not found`);
    }
    
    console.log(`Testing endpoint: ${endpointKey}`);
    console.log('Endpoint configuration:', endpointConfig);
    
    // Connect to client
    const app = await Client.connect(CLIENT);
    console.log('Connected to client:', CLIENT);
    
    // Prepare parameters
    const params = prepareParams(endpointConfig, customParams);
    console.log('Prepared parameters:', params);
    
    // Make prediction
    const result = await app.predict(endpointKey, params);
    console.log('Prediction result:', result);
    
    return result;
  } catch (error) {
    console.error('Error:', error.message);
    throw error;
  }
}

// Example usage
async function run(endpoint) {
  try {
    // Example: Test the /infer endpoint with default values
    await testEndpoint(endpoint);
    
  } catch (e) {
    console.error('Test execution failed:', e.message);
  }
}


async function testClient() {
    try {
        const app = await Client.connect(CLIENT);
        console.log('Connected to client:', {CLIENT, app});
    } catch (e) {
        console.error('Test execution failed:', e.message);
    }
}

// Run the test
run("/infer");


// fetch("https://sesame-csm-1b.hf.space/gradio_api/queue/join?__theme=system", {
//     "headers": {
//       "accept": "*/*",
//       "accept-language": "en-US,en;q=0.6",
//       "content-type": "application/json",
//       "priority": "u=1, i",
//       "sec-ch-ua": "\"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Brave\";v=\"134\"",
//       "sec-ch-ua-mobile": "?0",
//       "sec-ch-ua-platform": "\"macOS\"",
//       "sec-fetch-dest": "empty",
//       "sec-fetch-mode": "cors",
//       "sec-fetch-site": "same-origin",
//       "sec-fetch-storage-access": "none",
//       "sec-gpc": "1",
//       "x-zerogpu-token": "eyJhbGciOiJFZERTQSJ9.eyJyZWFkIjp0cnVlLCJwZXJtaXNzaW9ucyI6eyJyZXBvLmNvbnRlbnQucmVhZCI6dHJ1ZX0sIm9uQmVoYWxmT2YiOnsia2luZCI6InVzZXIiLCJfaWQiOiI2MzNiNzFiNDdhZjYzM2NiY2QwNjcxZDgiLCJ1c2VyIjoianVhbmRhdmlkZ2YiLCJpc1BybyI6dHJ1ZSwiaXNFbnRlcnByaXNlTWVtYmVyIjpmYWxzZX0sImlhdCI6MTc0MjI0MDU0OCwic3ViIjoiL3NwYWNlcy9zZXNhbWUvY3NtLTFiIiwiZXhwIjoxNzQyMjQwNzI4LCJpc3MiOiJodHRwczovL2h1Z2dpbmdmYWNlLmNvIn0.THiebhLHNENDNgEe7HhrxHDNqhuR1BMmSSr8WlRjKpm8asa39ZPxszsU3wu67UeZr-mJUX9LHWAJDrwwxUUABA",
//       "x-zerogpu-uuid": "MWNH2WDkdwd7ZybKDRxD2",
//       "Referer": "https://sesame-csm-1b.hf.space/?__theme=system",
//       "Referrer-Policy": "strict-origin-when-cross-origin"
//     },
//     "body": "{\"data\":[\"like revising for an exam I'd have to try and like keep up the momentum because I'd start really early I'd be like okay I'm gonna start revising now and then like you're revising for ages and then I just like start losing steam I didn't do that for the exam we had recently to be fair that was a more of a last minute scenario but like yeah I'm trying to like yeah I noticed this yesterday that like Mondays I sort of start the day with this not like a panic but like a\",\"like a super Mario level. Like it's very like high detail. And like, once you get into the park, it just like, everything looks like a computer game and they have all these, like, you know, if, if there's like a, you know, like in a Mario game, they will have like a question block. And if you like, you know, punch it, a coin will come out. So like everyone, when they come into the park, they get like this little bracelet and then you can go punching question blocks around.\",{\"path\":\"/tmp/gradio/5b5ce26817597fa754ef96dedc86f448c1bac998d19a7cf4b0d79fcd0ca1ab16/conversational_a.wav\",\"url\":\"https://sesame-csm-1b.hf.space/gradio_api/file=/tmp/gradio/5b5ce26817597fa754ef96dedc86f448c1bac998d19a7cf4b0d79fcd0ca1ab16/conversational_a.wav\",\"size\":null,\"orig_name\":\"conversational_a.wav\",\"mime_type\":null,\"is_stream\":false,\"meta\":{\"_type\":\"gradio.FileData\"}},{\"path\":\"/tmp/gradio/c8275e46be95249d7869f6290a90f1073a1182f62f9153ed0434513bd630d58f/conversational_b.wav\",\"url\":\"https://sesame-csm-1b.hf.space/gradio_api/file=/tmp/gradio/c8275e46be95249d7869f6290a90f1073a1182f62f9153ed0434513bd630d58f/conversational_b.wav\",\"size\":null,\"orig_name\":\"conversational_b.wav\",\"mime_type\":null,\"is_stream\":false,\"meta\":{\"_type\":\"gradio.FileData\"}},\"Hey how are you doing.\\nPretty good, pretty good.\\nI'm great, so happy to be speaking to you.\\nMe too, this is some cool stuff huh?\\nYeah, I've been reading more about speech generation, and it really seems like context is important.\\nDefinitely.\\n\"],\"event_data\":null,\"fn_index\":4,\"trigger_id\":22,\"session_hash\":\"8oy7w3p41\"}",
//     "method": "POST"
//   });

==== playground/parts.mjs ====
import { Client, handle_file } from "@gradio/client";

const CLIENT = "https://wondervictor-evf-sam2.hf.space";

(async() => {
  try {
    const app = await Client.connect(CLIENT);
    console.log("Client connected:", !!app);
    const apiInfo = await app.view_api();
    console.log(JSON.stringify(apiInfo, null, 2));
  } catch (error) {
    console.error("Error in main function:", error);
  }
})();

==== playground/references.md ====

https://bytedance-research-uno-flux.hf.space/gradio_api/info
https://bytedance-research-uno-flux.hf.space/info

general info?
https://huggingface.co/api/spaces/by-subdomain/bytedance-research-uno-flux

==== playground/talker.mjs ====
import { Client, handle_file } from "@gradio/client";

import "dotenv/config";


const CLIENT = "/fffiloni/KDTalker";

function main() {
  try { 
    const client = new Client(CLIENT);
    console.log("Client:", client);

  } catch (error) {
    console.error("Error initializing client:", error);
  }
}
main();


==== playground/test-curl.mjs ====
import dotenv from 'dotenv';
import { EventSource } from 'eventsource';

// Load environment variables from .env.local
dotenv.config();

const BASE_URL = "https://bytedance-research-uno-flux.hf.space/";
const USE_HF_TOKEN = true; // Set to false to disable token usage
const API_ENDPOINT = "gradio_api/call/gradio_generate";
const HF_TOKEN = process.env.HF_TOKEN || null;
const IMAGE_URLS = [
  "https://bytedance-research-uno-flux.hf.space/file=/assets/examples/4two2one/ref1.png",
  "https://bytedance-research-uno-flux.hf.space/file=/assets/examples/4two2one/ref2.png"
];


if (!HF_TOKEN && USE_HF_TOKEN) {
  console.warn("Warning: HF_TOKEN not set. Some features may not work. " +  HF_TOKEN);
}

async function readStreamWithTimeout(reader, timeoutMs = 5000) {
  const chunks = [];
  let timeout;
  
  try {
    const timeoutPromise = new Promise((_, reject) => {
      timeout = setTimeout(() => reject(new Error('Stream read timeout')), timeoutMs);
    });

    while (true) {
      const readPromise = reader.read();
      const {done, value} = await Promise.race([readPromise, timeoutPromise]);
      
      if (done) break;
      chunks.push(value);
    }
    
    return Buffer.concat(chunks).toString('utf8');
  } finally {
    clearTimeout(timeout);
  }
}

async function runCurlStyleTest() {
  console.log("Starting curl-style Gradio test...");
  
  try {
    // 1. Make initial POST request
    console.log("Making POST request to:", BASE_URL + API_ENDPOINT);
    const headers = { "Content-Type": "application/json" };
    if (USE_HF_TOKEN && process.env.HF_TOKEN) {
      headers["Authorization"] = `Bearer ${process.env.HF_TOKEN}`;
      console.log("Using HF Token for authentication");
    }

    const postResponse = await fetch(BASE_URL + API_ENDPOINT, {
      method: "POST",
      headers: headers,
      body: JSON.stringify({
        data: [
          "The logo is printed on the cup",
          512, 512, 4, 25, 61733557,
          { name: "ref1.png", data: IMAGE_URLS[0], is_file: true },
          { name: "ref2.png", data: IMAGE_URLS[1], is_file: true },
          null, null
        ]
      })
    });

    console.log("POST response status:", postResponse.status);
    
    if (!postResponse.ok) {
      const error = await postResponse.text();
      console.error("POST failed:", error);
      throw new Error(`POST failed: ${postResponse.status}`);
    }

    const { event_id } = await postResponse.json();
    if (!event_id) throw new Error("No event_id received");
    console.log("Received event_id:", event_id);

    // 2. Try SSE first, fallback to polling if needed
    return new Promise(async (resolve, reject) => {
      const getUrl = `${BASE_URL}${API_ENDPOINT}/${event_id}`;
      
      // First try SSE
      try {
        console.log("Attempting SSE connection to:", getUrl);
        const eventSource = new EventSource(getUrl, {
          withCredentials: false
        });

        eventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log("SSE event:", data.msg);
            
            if (data.msg === "process_completed") {
              eventSource.close();
              resolve(data.data || data.output?.data);
            } else if (data.msg === "process_failed") {
              eventSource.close();
              reject(new Error(data.output?.error || "Prediction failed"));
            }
          } catch (e) {
            console.error("Error parsing SSE data:", e);
          }
        };

        eventSource.onerror = (err) => {
          console.error("SSE error - falling back to polling:", err);
          eventSource.close();
          startPolling(getUrl, resolve, reject);
        };
      } catch (sseError) {
        console.error("SSE init failed - falling back to polling:", sseError);
        startPolling(getUrl, resolve, reject);
      }

      // Polling fallback
      async function startPolling(url, resolve, reject) {
        const MAX_RETRIES = 30;
        const POLL_INTERVAL = 2000;
        let retries = 0;
        console.log("Starting polling...");

        const poll = async () => {
          try {
            console.log(`Polling attempt ${retries + 1}/${MAX_RETRIES}`);
            const headers = { "Content-Type": "application/json" };
            if (USE_HF_TOKEN && process.env.HF_TOKEN) {
              headers["Authorization"] = `Bearer ${process.env.HF_TOKEN}`;
            }

            const response = await fetch(url, {
              headers: headers
            });
            console.log("Polling response status:", response.status);

            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            // Read response as stream and parse SSE messages
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let doneReading = false;

            while (!doneReading) {
              const { done, value } = await reader.read().catch(err => {
                // Handle potential read errors (like connection closed)
                console.error("Stream read error:", err);
                return { done: true, value: undefined }; // Treat as done
              });

              if (done) {
                doneReading = true;
                // Process any remaining buffer content if stream closes unexpectedly
                if (buffer.trim()) {
                   console.warn("Stream ended with unprocessed buffer:", buffer);
                }
                break;
              }

              buffer += decoder.decode(value, { stream: true });
              console.log(`Received chunk (${value.length} bytes), buffer size: ${buffer.length}`);

              // Process complete SSE messages (separated by \n\n)
              let messageEndIndex;
              while ((messageEndIndex = buffer.indexOf('\n\n')) !== -1) {
                const message = buffer.substring(0, messageEndIndex);
                buffer = buffer.substring(messageEndIndex + 2); // Consume message from buffer

                let eventType = null;
                let eventData = null;

                for (const line of message.split('\n')) {
                  if (line.startsWith('event:')) {
                    eventType = line.substring(6).trim();
                  } else if (line.startsWith('data:')) {
                    eventData = line.substring(5).trim();
                  }
                }

                console.log(`Parsed SSE Message: event=${eventType}, data=${eventData}`);

                if (eventType === 'error' && eventData?.includes('Session not found')) {
                  console.error("Explicit Session Not Found error received.");
                  reader.cancel(); // Stop reading
                  reject(new Error('Session not found (received from server)'));
                  return; // Exit poll function immediately
                } else if (eventType === 'complete') {
                   console.log("Process completed event received.");
                   reader.cancel();
                   try {
                     // Attempt to parse the data as JSON for the final result
                     const finalResult = JSON.parse(eventData || '{}');
                     resolve(finalResult.data || finalResult.output?.data || finalResult);
                   } catch (parseError) {
                     console.error("Failed to parse 'complete' event data:", parseError, "Raw data:", eventData);
                     reject(new Error("Failed to parse completion data"));
                   }
                   return; // Exit poll function
                } else if (eventType === 'generating') {
                   console.log("Generating event:", eventData);
                   // Could potentially update UI here in a real app
                } else if (eventType === 'heartbeat') {
                   console.log("Heartbeat received.");
                } else {
                   console.log("Received unknown/unhandled event type:", eventType);
                }
              }
            } // end while(!doneReading)

            // If the stream finished without a 'complete' or specific 'error' event
            if (doneReading) {
               console.warn("Stream ended without a definitive 'complete' or 'Session not found' event.");
               // Decide whether to retry based on what happened
               if (retries < MAX_RETRIES) {
                 // Allow retry if stream just ended cleanly without a result
                 console.log("Allowing retry as stream ended cleanly.");
               } else {
                 reject(new Error("Stream ended after max retries without completion"));
                 return;
               }
            }

            // If we fall through here, it means the stream ended cleanly OR
            // an error occurred that wasn't 'Session not found', allow retry logic below
            if (retries < MAX_RETRIES) {
                retries++;
                setTimeout(poll, POLL_INTERVAL);
              } else {
                reject(new Error("Max polling retries reached"));
              }
            } catch (error) {
              console.error("Polling error:", error);
              if (retries < MAX_RETRIES) {
                retries++;
                setTimeout(poll, POLL_INTERVAL);
              } else {
                reject(error);
              }
            }
        };

        await poll();
      }
    });
  } catch (error) {
    console.error("Test failed:", error);
    throw error;
  }
}

// Run test
runCurlStyleTest()
  .then(data => console.log("\n--- SUCCESS ---\nResult:", data))
  .catch(err => console.error("\n--- ERROR ---\n", err));


==== playground/test.mjs ====
import { Client, handle_file } from "@gradio/client";

const CLIENT = "bytedance-research/UNO-FLUX";

const IMAGE_URLS = [
  "https://images.unsplash.com/photo-1570784332176-fdd73da66f03?fm=jpg&q=60&w=3000&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
  "https://images.unsplash.com/photo-1567446537708-ac4aa75c9c28?fm=jpg&q=60&w=3000&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
];

// The function exposed by Gradio app (often at index 0)
const FUNCTION_INDEX = "gradio_api/gradio_generate";

(async function () {
  try {
    console.log("Starting @gradio/client test (by index, with static images)...");

    // Spoof headers to make it look like a browser request
    const browserHeaders = {
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/110.0.0.0 Safari/537.36",
      "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8",
      "Referer": "https://bytedance-research-uno-flux.hf.space/"
    };

    // Fetch images with headers
    const responses = await Promise.all(IMAGE_URLS.map(url =>
      fetch(url, { headers: browserHeaders })
    ));

    if (!responses.every(r => r.ok)) {
      const failedResponses = responses.filter(r => !r.ok);
      console.error("Failed response details:", failedResponses.map(r => ({
        url: r.url,
        status: r.status,
        statusText: r.statusText
      })));
      throw new Error(`Failed to fetch one or more example images (status not OK).`);
    }

    const images = await Promise.all(responses.map(r => r.blob()));
    console.log(`Successfully fetched ${images.length} example images.`);

    const params = {
      prompt: "The logo is printed on the cup",
      width: 512,
      height: 512,
      guidance: 4,
      num_steps: 25,
      seed: 61733557,
      image_prompt1: images[0],
      image_prompt2: images[1],
      image_prompt3: null,
      image_prompt4: null,
    };
    console.log("Parameters prepared:", params);

    const app = await Client.connect(CLIENT);
    console.log("Client connected:", !!app);

    const apiInfo = await app.view_api();
    console.log({apiInfo});

    console.log({FUNCTION_INDEX});
    const submission = app.submit(FUNCTION_INDEX, params);
    console.log("Submission started:", submission);

    for await (const msg of submission) {
      if (msg.type === "data") {
        console.log("Received data chunk:", msg.data);
        // msg.data = [generated_image_data, download_filepath]
      }

      if (msg.type === "status") {
        console.log("Status update:", msg);
        if (msg.stage === "complete") {
          console.log("Prediction complete.");
        } else if (msg.stage === "error") {
          console.error("Prediction failed:", msg.detail);
          throw new Error(`Prediction failed at stage ${msg.stage}: ${msg.detail}`);
        }
      }
    }

    console.log("@gradio/client test finished successfully.");

  } catch (error) {
    console.error("@gradio/client test failed:", error.message);
  }
})();


==== postcss.config.mjs ====
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;


==== productSpec.md ====
# Product Spec

The idea is to my to be able to create apps faster, the problem I face generally is that I 
use so much time for build apps, so with this platform, the idea is be able to connect 
replicate or gradio demos and endpoits super easy, given a form.

Desire Output: The idea is to just have to put the url, or just copy the API document, like
the one for vercel nodejs, or any no?, and it generate the app. And inclusivily some AI could
complete the fields, and the user just edit.

In that way, I can 'build' an app every day,
that help my grow my audience,
Or showcase to a clients, and get clients easier, because I need money, and this is a way
to show my worth, and get more clients, in any case.
But in the end, it could be amazing to be able to connect apps and build like modules, to 
build more complex, or even AI apps, that could be like a AI assembly, where you can just
connect things. ðŸ¤¯

Finally maybe it could be a no-code AI platform,

Some alternative is comfyUI, the problem is that need a setup, and configuration, the amazing
thing about this platform, is that relay on serverless platforms, so the people doesn't need
to take care or any configuration, is the vercel of the fronted ... So maybe better if calling a
endpoint.

Maybe is so complex to be build by myself, but at least help me build faster, and in that 
way validate ideas super quickly and in that way, have more time for  make Marketing, something
super important, given that idk mucho how to do that, and is super important if I really want
to be able to build and market, and make a business like indie hacker, and solopreuner.

Maybe I could open source it, in that way I get help for others, on why not init a VC, if 
I see that necessary, for now I think is easy to make the form work, and launch it like the
30 product.
Of course if I wanto to productizate it, I need to make it more streighforward, and easy to use,
for example, be able to deploy a specific version of it, and not all the code, but the principal
components,

And when create the app have the posibility to see the result and test the endpoints, in the same view,

As maybe the continuation of this is to connect with the possibility to create chatbots,
and it to be integrated, in a node base platform, where the people can just connect different
modules like text based, or image based, or of any type, like sound, video, etc. And be able
to build apps like a AI assembly, where you can just connect things. And it deploy and app,
just like the wordpress, or etc, for no code, That is super ambitions, 
Maybe never is going to be developed fully, but I can at least solve my first order problem, be able to generate MVPs super fast, and validate that in the market, having more time to focus on marketing, and sales. And if something works, go full on finish of develop the idea.

Other problem, and because I started this project, is to be able to copy and paste the code,
when I build apps, instead of re make all from scratch, the problem is that I create apps like
I walk, so I have so much projects and files on my computer, I dont remember where each
specific part of the code of moduler, or functionallity I have, so it could be amazing to
have a boilerplate, that always could be updating, a system and a way a time I build a code,
it always remain and can use easly, maybe creating a github repo, that I get the modules I need,
and it update for this boilerplate, when I update something.

Now something super insteresting, is that now I use cursor, so the AI build super fast by me,
But inclusivily it fail a lot (other is understand very well each thing I do, and because I
know how it works very well, I can create code very fast), other point is that a lot of code
has been made already, the idea is not to re make the wheel. So in the end a boilerplate,
connected with the AI could be amazing, yes a github repo, with all my code, and be able
to fetch parts, like ok I need a grid cards, no, I need a flex cards, etc. Maybe the most
manually way is just to have a repo, with components, for example. But in another way it
could be amazing to habe the ability to not just for UI components, but for functionallity, like
for example integrate mongoDB database, create a CRUD, add auth0, that are libraries no?,
Are different problems, but is the way the create apps from a js object.

Now other challenge for create an app from a js object, is modify the UI, I need to build the
different components, but it is a little bit strict, but what if I need create a side bar,
with text area, with other inputs, and the outputs to save the results, that is basicly photoai,
or magnific, no?, ok when I build that, I'll update that, and ideally integrate that on my
apps generator, this one.
And integrate other functionallyties, like change the colors, styles.

And other incredible functionality is the AI to edit and help to build thigs, that is amazing,
just like I said to help to complete the fields, or the form/json generator. and as I said to be able to connect different type of models, like text, images, audiot, any ... that is amazing.
Generating Super Agentic Workflows. And in the end, just like j4Next that create chatbots at
one conversation deployed on wahtsapp (what is incredible because could give the power of anyone
to create complex AIs, democratizate AI creation, democratizate AI creation), or my idea of
integrate the UI to be UI/AI interaction.

The problem whit all this, is that is super complex, is a visionary project. But in the end, in 
what always I have been, so not matter what direction take it, I need to concentrate on Marketing, and monetizate each step, start smaller as possible, and monetizate that step.
It's like, instead of first create the super system, first create a simple chatbot that make 
a terapist, with a simple prompt, and monetizate that ... build by modules, monetizate each step.
And that is my salvation ...



## Summary 

Organized Summary of Projects from Product Spec
1. Rapid App Creation Platform
Main Goal
Create a platform to build apps faster by easily connecting to existing AI models and APIs.
Key Features

Connect to replicate or gradio demos and endpoints easily
Generate app structure from API documentation
AI-assisted form completion
Serverless architecture (like Vercel for frontend)

Benefits

Build an app every day
Grow audience
Showcase to clients
Validate ideas quickly

Future Scope

Connect apps and build modules
AI assembly for complex AI apps
Potential to become a no-code AI platform

2. Personal Code Boilerplate System
Main Goal
Efficiently reuse and manage personal code across projects.
Key Features

GitHub repo with reusable code modules
Easy fetching of specific code parts (e.g., grid cards, flex cards)
Integration with AI for faster code generation
Includes both UI components and functionalities (e.g., MongoDB integration, CRUD operations, Auth0)

Connection to Project 1
Could be integrated into the Rapid App Creation Platform to provide pre-built components and functionalities.
3. AI-Assisted App Customization
Main Goal
Enhance app creation with AI-powered customization and editing.
Key Features

AI helps complete fields in app generation forms
Edit and customize UI elements (e.g., sidebars, text areas, inputs)
Change colors and styles easily
Connect different types of AI models (text, images, audio)

Connection to Projects 1 & 2
This could be an advanced feature of the Rapid App Creation Platform, utilizing components from the Personal Code Boilerplate.
4. Super Agentive Workflows
Main Goal
Create a system for generating complex AI workflows.
Key Features

Connect different types of AI models
Create chatbots deployable on platforms like WhatsApp
Integrate UI for AI interaction

Connection to Other Projects
This is an advanced concept that could be the ultimate evolution of the Rapid App Creation Platform.
5. Monetization Strategy
Main Goal
Focus on marketing and monetizing each step of development.
Key Features

Start with smaller, manageable projects
Monetize each step or module
Example: Create a simple chatbot therapist with a basic prompt

Relevance to All Projects
This is a crucial strategy to apply across all project developments, ensuring sustainability and growth.
Overall Vision
The overarching goal is to create a comprehensive system for rapid AI app development and deployment, with a focus on user-friendly interfaces, reusability, and AI assistance throughout the process. The strategy involves starting small, monetizing each step, and gradually building towards more complex and integrated systems.


==== project_documentation.md ====
# AI App Generation Platform (Project "changebg")

## Table of Contents
- [Overview](#overview)
- [Architecture](#architecture)
- [Core Features & Modules](#core-features--modules)
- [Key Technologies & Libraries](#key-technologies--libraries)
- [Directory Structure](#directory-structure)
- [Important Files & Their Roles](#important-files--their-roles)
- [API Endpoints](#api-endpoints)
- [Data Flow Examples](#data-flow-examples)
- [Code Examples](#code-examples)
- [Future/Experimental Features](#futureexperimental-features)
- [Notes & Potential Improvements](#notes--potential-improvements)

## Overview

This Next.js project serves as a platform for rapidly creating and deploying web applications that interface with AI models, primarily from **Replicate** and **Gradio**. The core concept is to define an "app" via a configuration (specifying inputs, outputs, and backend model details), store this configuration, and then dynamically render a UI for users to interact with the AI model.

### Key Functionalities

- **Dynamic App Creation**: Users can define new "apps" through a UI or JSON configuration
- **Dynamic App Rendering**: Generated apps are accessible via unique slugs (`/app/[slug]`)
- **AI Model Integration**: Supports both Replicate and Gradio models
- **App Preview**: Allows testing configurations before saving
- **Server-Sent Events (SSE)**: Experimental support for real-time updates from Gradio
- **Database Storage**: MongoDB for storing app configurations
- **Pre-built Tools**: Several standalone AI tools (IlluminAI, Upscaler, etc.)

## Architecture

- **Frontend**: Next.js (App Router), React, Tailwind CSS
- **Backend**: Next.js API Routes
- **Database**: MongoDB
- **AI Model Providers**:
  - Replicate (via `replicate` npm package and direct API calls)
  - Gradio (via `@gradio/client` npm package and direct API calls, including SSE)

## Core Features & Modules

### 3.1. App Creation & Configuration

**UI Components:**
- Main UI: `/create` (`src/app/create/page.tsx`)
- Preview Component: `src/components/AppPreview.tsx`

**API Endpoints:**
- `POST /api/create` - Save configurations (`src/app/api/create/route.ts`)
- `GET /api/create/get` - Fetch configurations (`src/app/api/create/get/route.ts`)
- `POST /api/create/fetch-model-details` - Model schema introspection (`src/app/api/create/fetch-model-details/route.ts`)

**Data Storage:**
- MongoDB integration via `src/lib/mongodb.ts`
- Configuration schema defined in `src/types/index.ts` (InputItem, OutputItem, Configuration)

#### Workflow

1. **Navigation**: User navigates to `/create`
2. **Model Selection**: User selects app type (Replicate/Gradio) and provides model/client details
3. **Schema Fetching**: 
   - For **Replicate**: Fetches model schema from `https://api.replicate.com/v1/models/{model}/versions/{version}`
   - For **Gradio**: Uses `@gradio/client`'s `Client.connect(client).view_api()` or fetches from `{gradio_space_url}/info`
4. **Configuration**: Fetched schema populates input/output fields, user can edit properties
5. **Preview/Edit**: User can switch between "Form" and "JSON" views
6. **Save**: Final configuration is submitted and saved to MongoDB

#### Configuration Merging

- `src/common/configuration.ts` defines `configurationsObj` (hardcoded configurations)
- `getConfigurations(forceRefresh?: boolean)` merges database configurations with hardcoded ones
- This serves as the primary source of app definitions for the entire application

### 3.2. Dynamic App Rendering

**Components:**
- Page Template: `/app/[slug]` (`src/app/app/[slug]/page.tsx` and `ClientPage.tsx`)

**API Endpoints:**
- `POST /api/app/[slug]` - Execute predictions (`src/app/api/app/[slug]/route.ts`)
- `POST /api/app/[slug]/get` - Status check for Replicate (`src/app/api/app/[slug]/get/route.ts`)

#### Workflow

1. **Page Load**: User navigates to `/app/[slug]`
2. **Server Component**: Fetches `initialConfigurations` using `getConfigurations()`
3. **Client Component**: `ClientPage.tsx` renders dynamic UI based on configuration
4. **Input Handling**: User provides inputs (text, file uploads converted to base64)
5. **Prediction Execution**:
   - **Replicate**: Creates prediction, returns prediction ID, polls for results
   - **Gradio**: Executes prediction directly, returns immediate results
6. **Results Display**: Updates UI with outputs based on `config.outputs`

### 3.3. App Preview Feature

**Integration**: Within `/create` page via "Preview" tab
**Component**: `src/components/AppPreview.tsx`
**API Endpoints:**
- `POST /api/preview` - Preview predictions (`src/app/api/preview/route.ts`)
- `GET /api/preview/get` - Preview status check (`src/app/api/preview/get/route.ts`)

#### Workflow

1. **Preview Mode**: User selects "Preview" tab in `/create`
2. **Dynamic Rendering**: `AppPreview.tsx` renders inputs based on current draft config
3. **Testing**: User interacts with inputs and clicks "Test Configuration"
4. **Execution Options**:
   - **SSE Enabled**: For Gradio with experimental SSE support
   - **Standard**: Uses preview API endpoints for polling-based results
5. **Results**: Displays outputs based on configuration

### 3.4. Server-Sent Events (SSE) for Gradio (Experimental)

**Documentation**: `docs/sse-implementation.md`
**API Endpoints:**
- `POST /api/experimental/sse/init` - Initiate SSE prediction
- `GET /api/experimental/sse/stream` - Stream SSE data
**Utilities**: `src/utils/gradio.ts`

#### Workflow

1. **Initiation**: `AppPreview.tsx` sends POST to `/api/experimental/sse/init`
2. **Event ID**: Gradio API returns an `event_id`
3. **Stream Connection**: Client creates EventSource to `/api/experimental/sse/stream`
4. **Real-time Updates**: Server pipes Gradio stream directly to client
5. **Event Handling**: Client listens for messages and updates UI progressively

### 3.5. Static/Specific Tools

Pre-defined applications with dedicated pages and API routes:

| Tool | UI Route | API Route | Model |
|------|----------|-----------|--------|
| IlluminAI | `/illuminai` | `POST /api/illuminai` | `zsxkib/ic-light` |
| Upscaler | `/upscaler` | `POST /api/upscale` | `philz1337x/clarity-upscaler` |
| Remove Background | `/removebg` | `POST /api/removebg` | `codeplugtech/background_remover` |
| Enhance Background | `/enhancebg` | `POST /api/enhancebg` | Various models |
| Simpson | `/simpson` | `POST /api/simpson` | Simpson-style generation |
| Interior Design | `/` (homepage) | `POST /api/inter-design` | Interior design models |

## Key Technologies & Libraries

### Core Framework
- **Next.js 14+** (App Router)
- **React 18**
- **TypeScript**
- **Tailwind CSS**

### AI Integration
- **Replicate Client** (`replicate` npm) - Replicate model interactions
- **Gradio Client** (`@gradio/client` npm) - Gradio space/API interactions

### Database & Storage
- **MongoDB** (`mongodb` npm) - Configuration storage

### UI Components & Utilities
- **React Dropzone** (`react-dropzone` npm) - File uploads
- **FileSaver.js** (`file-saver` npm) - Client-side downloads
- **React Loader Spinner** - Loading indicators
- **Axios** - HTTP requests (alongside native `fetch`)

### Icons & Styling
- **Heroicons**
- **Lucide React**
- **React Icons**

### Experimental Features
- **EventSource Polyfill** (`eventsource` npm) - SSE support

## Directory Structure

```
src/
â”œâ”€â”€ app/                          # Next.js App Router
â”‚   â”œâ”€â”€ (pages)/                  # Main UI pages
â”‚   â”œâ”€â”€ app/[slug]/              # Dynamic app rendering
â”‚   â”œâ”€â”€ api/                     # Backend API routes
â”‚   â”‚   â”œâ”€â”€ app/[slug]/          # Dynamic app APIs
â”‚   â”‚   â”œâ”€â”€ create/              # App creation APIs
â”‚   â”‚   â”œâ”€â”€ experimental/sse/    # SSE APIs
â”‚   â”‚   â””â”€â”€ [tool-apis]/         # Specific tool APIs
â”‚   â””â”€â”€ create/                  # App creation UI
â”œâ”€â”€ common/                      # Shared configurations
â”‚   â”œâ”€â”€ configuration.ts         # Central app definitions
â”‚   â””â”€â”€ index.ts                 # Navigation items
â”œâ”€â”€ components/                  # Reusable React components
â”œâ”€â”€ lib/                         # Utility modules
â”‚   â””â”€â”€ mongodb.ts              # MongoDB connection
â”œâ”€â”€ types/                       # TypeScript definitions
â”œâ”€â”€ utils/                       # General utilities
â””â”€â”€ experimental/sse-handler/    # SSE placeholder files

docs/                            # Project documentation
playground/                      # Testing scripts
public/                         # Static assets
```

## Important Files & Their Roles

| File | Purpose |
|------|---------|
| `src/common/configuration.ts` | Central logic for app definitions, merges hardcoded configs with DB-fetched ones |
| `src/app/create/page.tsx` | UI for creating new app configurations |
| `src/app/api/create/fetch-model-details/route.ts` | Backend logic to get schema/info from Replicate/Gradio |
| `src/app/app/[slug]/ClientPage.tsx` | Renders UI for dynamically configured apps |
| `src/app/api/app/[slug]/route.ts` | Backend logic for running predictions for dynamic apps |
| `src/components/AppPreview.tsx` | Real-time app preview component during creation |
| `src/app/api/preview/route.ts` | Backend logic for handling preview requests |
| `src/app/api/experimental/sse/init/route.ts` | SSE initiation for Gradio |
| `src/app/api/experimental/sse/stream/route.ts` | SSE streaming for Gradio |
| `src/types/index.ts` | Defines `Configuration`, `InputItem`, `OutputItem` types |

## API Endpoints

### Core Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| `POST` | `/api/create` | Create new app configuration in MongoDB |
| `GET` | `/api/create/get` | Fetch all app configurations |
| `POST` | `/api/create/fetch-model-details` | Fetch schema/info for Replicate/Gradio models |
| `POST` | `/api/app/[slug]` | Run prediction for app identified by slug |
| `POST` | `/api/app/[slug]/get` | Get status/result of Replicate prediction |
| `POST` | `/api/preview` | Run prediction in preview mode |
| `GET` | `/api/preview/get` | Get status/result for preview prediction |

### Experimental Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| `POST` | `/api/experimental/sse/init` | Initiate SSE-based Gradio prediction |
| `GET` | `/api/experimental/sse/stream` | Stream Gradio prediction events |

### Tool-Specific Endpoints

| Method | Endpoint | Purpose |
|--------|----------|---------|
| `POST` | `/api/illuminai` | IlluminAI tool prediction |
| `POST` | `/api/upscale` | Image upscaling |
| `POST` | `/api/removebg` | Background removal |
| `POST` | `/api/enhancebg` | Background enhancement |
| `POST` | `/api/simpson` | Simpson-style generation |
| `POST` | `/api/inter-design` | Interior design generation |

## Data Flow Examples

### Dynamic App Execution (Replicate)

```mermaid
sequenceDiagram
    participant User
    participant ClientPage
    participant API
    participant Replicate
    participant MongoDB

    User->>ClientPage: Navigate to /app/my-replicate-app
    ClientPage->>MongoDB: Fetch configuration
    ClientPage->>User: Render input form
    User->>ClientPage: Fill inputs, click Submit
    ClientPage->>API: POST /api/app/my-replicate-app
    API->>MongoDB: Look up configuration
    API->>Replicate: Create prediction
    Replicate->>API: Return prediction ID
    API->>ClientPage: Return prediction ID
    
    loop Poll for results
        ClientPage->>API: POST /api/app/my-replicate-app/get
        API->>Replicate: Check prediction status
        Replicate->>API: Return status/output
        API->>ClientPage: Return status/output
    end
    
    ClientPage->>User: Display results when succeeded
```

### SSE-Based Gradio Execution

```mermaid
sequenceDiagram
    participant Client
    participant SSE_Init
    participant SSE_Stream
    participant Gradio

    Client->>SSE_Init: POST /api/experimental/sse/init
    SSE_Init->>Gradio: POST prediction request
    Gradio->>SSE_Init: Return event_id
    SSE_Init->>Client: Return event_id
    
    Client->>SSE_Stream: EventSource connection
    SSE_Stream->>Gradio: GET stream endpoint
    
    loop Real-time updates
        Gradio->>SSE_Stream: Stream events
        SSE_Stream->>Client: Forward events
        Client->>Client: Update UI progressively
    end
```

## Code Examples

### Replicate Prediction (from `src/app/api/app/[slug]/route.ts`)

```typescript
// Inside POST /api/app/[slug] when config.type === 'replicate'
const replicate = new Replicate({ auth: REPLICATE_API_TOKEN });
const model: `${string}/${string}` | `${string}/${string}:${string}` | undefined = config.model;
const version = config.version as string | undefined;
const input: { [key: string]: any } = {}; // Constructed from req and config.inputs

// ... logic to populate 'input' object ...

const output = await replicate.predictions.create({
  model,
  version,
  input,
});
return NextResponse.json(output, { status: 201 });
```

### Configuration Type Definition

```typescript
interface Configuration {
  name: string;
  type: 'replicate' | 'gradio';
  model?: string;
  version?: string;
  client?: string;
  endpoint?: string;
  inputs: InputItem[];
  outputs: OutputItem[];
}

interface InputItem {
  name: string;
  type: string;
  component: string;
  show: boolean;
  label: string;
  defaultValue?: any;
  // ... additional properties
}

interface OutputItem {
  name: string;
  type: string;
  component: string;
  show: boolean;
  label: string;
}
```

## Future/Experimental Features

### SSE Implementation
- **Status**: Experimental
- **Purpose**: Provide real-time progress updates instead of polling
- **Target**: Gradio models with streaming support
- **Documentation**: `docs/sse-implementation.md`

### Vision & Roadmap
According to `productSpec.md`, the project has ambitious goals including:
- AI assembly capabilities
- No-code AI platform
- Super agentic workflows
- Enhanced user experience for AI interaction

## Notes & Potential Improvements

### Security Considerations
- âœ… **API Keys**: Properly managed via environment variables
- âš ï¸ **Input Validation**: Could be enhanced across API routes
- âš ï¸ **Rate Limiting**: Not currently implemented

### Code Quality
- **Shared Logic**: `ClientPage.tsx` and `AppPreview.tsx` could benefit from more shared components
- **Error Handling**: Present but could be more standardized
- **TypeScript**: Well-typed throughout the application

### Performance
- **Caching**: `getConfigurations()` uses 3600s revalidation with cache-busting support
- **File Handling**: Base64 conversion for files could be optimized for large uploads
- **Database**: MongoDB queries could benefit from indexing strategies

### Architecture
- **Separation of Concerns**: Clear separation between static tools and dynamic apps
- **Modularity**: Good component structure with reusable elements
- **Scalability**: Current architecture supports adding new AI providers

### Development Experience
- **Documentation**: Well-documented with inline comments and separate docs
- **Testing**: `playground/` directory provides good examples for testing integrations
- **Debugging**: SSE implementation includes comprehensive error handling

### Known Limitations
- **File Size**: Large file uploads may face browser/server limits with base64 encoding
- **SSE Support**: Currently experimental and limited to Gradio
- **Model Discovery**: Manual model configuration required (no automatic discovery)
- **Preview Isolation**: Uses `X-Preview-Mode` header concept but implements via separate endpoints

This documentation provides a comprehensive overview of the AI App Generation Platform, serving as both a technical reference and architectural guide for developers working with the system.


==== public/next.svg ====
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

==== public/vercel.svg ====
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>

==== src/app/ClientSidebarWrapper.tsx ====
"use client";

import { usePathname } from 'next/navigation';
import { ReactNode } from 'react';

type ClientSidebarWrapperProps = {
  children: ReactNode;
};

export default function ClientSidebarWrapper({ children }: ClientSidebarWrapperProps) {
  const pathname = usePathname();
  const showSidebar = !pathname.startsWith('/create');

  if (!showSidebar) {
    return null;
  }

  return <>{children}</>;
}

==== src/app/api/app/[slug]/get/route.ts ====
import { Slug } from '@/types';
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(
  request: Request,
  { params }: { params: { slug: Slug } },
) {
  try {
    const req = await request.json();

    const slug = params.slug;
    // if(slug !== 'freshink' && slug !== 'createVideo') return NextResponse.json(
    //   { error: `Something went wrong, api, slug ${slug} not allowed` },
    //   { status: 500 }
    // );

    const {id} = req;

    console.log('[slug]/get', {id});
  
    if (!id) return NextResponse.json(
        { error: 'not id /api' },
        { status: 500 }
      );
    
    const replicate = new Replicate({
      auth: process.env.REPLICATE_API_TOKEN as string,
    });
  
    const state = await replicate.predictions.get(id);

    // const state = {
    //   id: "wds8qv2e5hrj20chkc8vmp60vc",
    //   status: "succeeded",
    // }
  
    console.log({state});
    return NextResponse.json({ state }, { status: 201 });
  } catch (error: any) {
    console.error("api/app/[]/get " + error.message);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}

==== src/app/api/app/[slug]/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';
import { Slug } from '@/types';
import { Configurations } from "@/types";
import {getConfigurations} from '@/common/configuration';
import { Client, handle_file } from "@gradio/client";

type Status = "successful" | "failed" | "canceled";

const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;
if (!REPLICATE_API_TOKEN) throw Error(`not REPLICATE_API_TOKEN ${REPLICATE_API_TOKEN}`);

export async function POST(
  request: Request,
  { params }: { params: { slug: Slug } },
) {
  const slug = params.slug;

  console.log('Received request for slug:', slug);

  try {
    const configurations = await getConfigurations(true);

    if (!configurations) {
      console.error('No configurations found');
      return NextResponse.json(
        { error: 'No configurations available' },
        { status: 404 }
      );
    }

    console.log('Fetched configurations:', configurations.map(conf => conf.name));

    const config = configurations.find(conf => conf.name === slug);

    if (!config) {
      console.error(`Configuration not found for slug: ${slug}`);
      return NextResponse.json(
        { error: `Configuration not found for slug: ${slug}` },
        { status: 404 }
      );
    }

    console.log('Found configuration:', config.name);

    if (config) {
      const req = await request.json();
      console.log('elseif conf');

      let indImg = 0;

      if (config && config.type === 'replicate') {
        const replicate = new Replicate({
          auth: REPLICATE_API_TOKEN,
        });

        const model: 
          `${string}/${string}` | `${string}/${string}:${string}` | undefined = config.model;

        if (!model || typeof model !== "string") throw Error(`not model found or format issue ${model}`);

        const version = config.version as string | undefined;

        // I need to check how to convert array of object, to object,

        const input: { [key: string]: any } = {};
        
        // TODO -> Make the extraction of the req automatic, define in the fronted, the name related with the config object ...

        // console.log('Request Parameters:', JSON.stringify(req, null, 2));

        let indxImage = 0;
        config.inputs.forEach(item => {
          if (item.key) {
            if(item.show) {
              const {component} = item;
              if (component === 'image') {
                const {image} = req;
                if(!image) return NextResponse.json(
                  { error: 'not image /api' },
                  { status: 500 }
                );
                console.log({image})
                input[item.key] = image[indxImage];
              } else if (component === 'prompt') {
                const {prompt} = req;
                if(!prompt) return NextResponse.json(
                  { error: 'not image /api' },
                  { status: 500 }
                );
                input[item.key] = prompt;
              }
            } else {
              input[item.key] = item.value;
            }
          }
        });

        if(!input) throw Error('api/app/[]/ input is not a object');

        console.log('xxx ->', {model, version , input});
        
        // const output = await replicate.predictions.create({
        //   model,
        //   version,
        //   input,
        // });

        const output = {
          id: "3h1s8zajrxrgp0chr93t8h6svg"
        };
        
        if (!output) {
          console.log(`api/[${slug}] !output`, {output});
          console.log('Something went wrong');
          return NextResponse.json(
            { error: 'Something went wrong, api not response output' },
            { status: 500 }
          );
        }
        
        return NextResponse.json(
          output,
          { status: 201 }
        );
      } else if (config && config.type === 'gradio') {
        const params: Record<string, any> = {};
        let indImg = 0;

        for (const item of config.inputs) {
          if (item.component === 'image') {
            const image = req.image[indImg];
            if (typeof image === 'string' && image.startsWith('data:image/')) {
              params[item.key] = await handle_file(await convertBase64ToBlob(image));
            } else {
              params[item.key] = await handle_file(image);
            }
            indImg++;
          } else if (item.component === 'audio') {
            const audio = req.audio;
            if (typeof audio === 'string' && audio.startsWith('data:audio/')) {
              params[item.key] = await handle_file(await convertBase64ToBlob(audio));
            } else if (audio instanceof Blob) {
              params[item.key] = await handle_file(audio);
            }
          } else {
            params[item.key] = req[item.key] !== undefined ? req[item.key] : item.value;
          }
        }
        const client = config.client;
        const path = config.path;
        const endpoint = config.endpoint as string;
        console.log('Gradio request params:', {
          client,
          endpoint,
          path,
          params: {
            ...params,
            // Hide large binary data from logs
            source_image: params.source_image ? '[Blob data]' : null,
            driven_audio: params.driven_audio ? '[Audio data]' : null 
          }
        })
        let output: any;
        try {
          // 1. Verify connection
          console.log('Connecting to Gradio client:', client);
          const app = await Client.connect(client as string).catch(err => {
            console.error('Gradio connection failed:', err.message);
            throw new Error(`Failed to connect to Gradio client ${client}: ${err.message}`);
          });
          console.log('Gradio client connected:', !!app);

          // Make prediction with detailed error context
          console.log('Running prediction with params:', {
            endpoint: endpoint, // Log the endpoint being used
            params: Object.keys(params),
            // Log types/sizes for debugging potential data issues
            audio_type: params.driven_audio?.type,
            audio_size: params.driven_audio?.size,
            image_type: params.source_image?.type,
            image_size: params.source_image?.size
          });

          console.log('flag before prediction');
          try {
            output = await app.predict(endpoint, params);
            console.log('flag after prediction');
            console.log('Prediction completed:', {
              output_data_type: typeof output?.data,
              output_status: output?.status // Check if output exists
            });
          } catch (predictError: any) {
            console.error('Gradio prediction failed:', {
              endpoint: endpoint,
              params: Object.keys(params), // Show keys, not full data
              error_message: predictError.message,
              error_stack: predictError.stack,
              gradio_app_info: app.config // Log Gradio app config for context
            });
            // Re-throw the original prediction error to be caught by the outer catch
            throw predictError;
          }

        } catch (error: any) {
          // This catches connection, endpoint verification, and prediction errors
          console.error('Full Gradio operation error:', {
            client: client,
            endpoint: config.endpoint, // Log intended endpoint
            error_message: error.message,
            error_stack: error.stack,
            // Avoid logging potentially large params again if it was a prediction error
            ...(error instanceof Error && !error.message.includes('prediction failed') && { params: Object.keys(params) })
          });
          // Throw a consistent error format
          throw new Error(`Gradio operation failed for ${client}: ${error.message}`);
        }


        console.log('Final Gradio output object:', {output}); // Log the final output object structure
        if (!output) {
          console.log('Something went wrong');
          return NextResponse.json(
            { error: 'Something went wrong' },
            { status: 500 }
          );
        }
        
        return NextResponse.json({
          status: 'succeeded',
          output: output.data
        }, { status: 201 });
      }
    } else if (slug !== 'freshink' 
        && slug !== 'createVideo'
        && slug !== "hairStyle"
        && slug !== "livePortrait"
        && slug !== "upscaler"
        && slug !== 'tryon')
    {
      return NextResponse.json(
        { error: `Something went wrong, api, slug ${slug} not found` },
        { status: 500 }
      );
    }

    const req = await request.json();

    const {sheme} = getModel({slug});

    Object.entries(sheme.input).forEach((item) => {
      if(item[1] === 'image') {
        const {image} = req;
        if(!image) return NextResponse.json(
          { error: 'not image /api' },
          { status: 500 }
        );
        (sheme.input as any)[item[0]] = image;
      } else if (item[1] === 'video') {
        const {video} = req;
        if(!video) return NextResponse.json(
          { error: 'not video req /api' },
          { status: 500 }
        );
        (sheme.input as any)[item[0]] = video;
        // (sheme.input as any)[item[0]] = "https://replicate.delivery/pbxt/LEQxLFMUNZMiKt5PWjyMJIbTdvKAb5j3f0spuiEwt9TEbo8B/d0.mp4";
      } else if(item[1] === 'prompt') {
        const {prompt} = req;
        if(!prompt) return NextResponse.json(
          { error: 'not prompt /api' },
          { status: 500 }
        );
        (sheme.input as any)[item[0]] = prompt;
      }
    })
    
    const replicate = new Replicate({
      auth: REPLICATE_API_TOKEN,
    });
  
    const model: 
      `${string}/${string}` | `${string}/${string}:${string}` | undefined = sheme?.model;
  
    if(!model || typeof model !== "string") throw Error(`not model found or format issue ${model}`);

    const version: string | undefined = sheme.version;
    if(!version) throw Error('api/app/[]/ version not found');
  
    const input = sheme?.input;
    if(!input) throw Error('api/app/[]/ input is not a object');

    console.log('xxx ->', {model, version , input});


    const output = await replicate.predictions.create({
      model,
      version,
      input,
    });

    // const output = {
    //   id: "87h588fapdrgg0cgmgftvtz87r"
    // };


    console.log({output});
    if (!output) {
      console.log('Something went wrong');
      return NextResponse.json(
        { error: 'Something went wrong' },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      output,
      { status: 201 }
    );
  } catch (error: any) {
    // console.error("api/app/[] general error" + JSON.stringify(error.message, null, 2));
    console.error("api/app/[] general error" + error.message);
    console.error("api/app/[] general error" + error.stack);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}

function getModel({slug}: {slug: string}) {
  let sheme;
  let model: `${string}/${string}` | `${string}/${string}:${string}`;

  console.log({slug});

  switch (slug) {
    case 'freshink':
      model = "fofr/sdxl-fresh-ink:8515c238222fa529763ec99b4ba1fa9d32ab5d6ebc82b4281de99e4dbdcec943";
      sheme = {
        model: model,
        input: {
          width: 1024,
          height: 1024,
          prompt: "A fresh ink TOK tattoo",
          refine: "expert_ensemble_refiner",
          scheduler: "K_EULER",
          lora_scale: 0.6,
          num_outputs: 1,
          guidance_scale: 7.5,
          apply_watermark: false,
          high_noise_frac: 0.9,
          negative_prompt: "ugly, broken, distorted",
          prompt_strength: 0.8,
          num_inference_steps: 25
        }
      }
      break;
    case 'createVideo':
      model = "chenxwh/diffsynth-exvideo:b3b0e929bf918153fbc0c5444fbe215f5cdbdbdf610910cf4dfcb6f6006e4783";
      sheme = {
        model,
        input: {
          prompt: "prompt",
          num_frames: 128,
          negative_prompt: "é”™è¯¯çš„çœ¼ç›ï¼Œç³Ÿç³•çš„äººè„¸ï¼Œæ¯å®¹ï¼Œç³Ÿç³•çš„è‰ºæœ¯ï¼Œå˜å½¢ï¼Œå¤šä½™çš„è‚¢ä½“ï¼Œæ¨¡ç³Šçš„é¢œè‰²ï¼Œæ¨¡ç³Šï¼Œé‡å¤ï¼Œç—…æ€ï¼Œæ®‹ç¼ºï¼Œ",
          num_inference_steps: 25,
          num_inference_steps_upscale_video: 25
        }
      }
      break;
    case 'upscaler':
      model = "philz1337x/clarity-upscaler:dfad41707589d68ecdccd1dfa600d55a208f9310748e44bfe35b4a6291453d5e";
      sheme = {
        model,
        input: {
          seed: 1337,
          image: "image",
          prompt: "masterpiece, best quality, highres, <lora:more_details:0.5> <lora:SDXLrender_v2.0:1>",
          dynamic: 6,
          handfix: "disabled",
          pattern: false,
          sharpen: 0,
          sd_model: "juggernaut_reborn.safetensors [338b85bc4f]",
          scheduler: "DPM++ 3M SDE Karras",
          creativity: 0.35,
          lora_links: "",
          downscaling: false,
          resemblance: 0.6,
          scale_factor: 2,
          tiling_width: 112,
          output_format: "png",
          tiling_height: 144,
          custom_sd_model: "",
          negative_prompt: "(worst quality, low quality, normal quality:2) JuggernautNegative-neg",
          num_inference_steps: 18,
          downscaling_resolution: 768
        }
      }
      break;
    case 'hairStyle':
      model = "orpatashnik/styleclip:7af9a66f36f97fee2fece7dcc927551a951f0022cbdd23747b9212f23fc17021";
      sheme = {
        model,
        version: "7af9a66f36f97fee2fece7dcc927551a951f0022cbdd23747b9212f23fc17021",
        input: {
          input: "image",
          target: "prompt",
          neutral: "a face",
          manipulation_strength: 4.1,
          disentanglement_threshold: 0.15
        },
      }
      break;
    case 'livePortrait':
      model = "fofr/live-portrait:067dd98cc3e5cb396c4a9efb4bba3eec6c4a9d271211325c477518fc6485e146";
      const version = "067dd98cc3e5cb396c4a9efb4bba3eec6c4a9d271211325c477518fc6485e146";
      sheme = {
        model,
        version,
        input: {
          face_image: "image",
          driving_video: "video",
          live_portrait_dsize: 512,
          live_portrait_scale: 2.3,
          video_frame_load_cap: 128,
          live_portrait_lip_zero: true,
          live_portrait_relative: true,
          live_portrait_vx_ratio: 0,
          live_portrait_vy_ratio: -0.12,
          live_portrait_stitching: true,
          video_select_every_n_frames: 1,
          live_portrait_eye_retargeting: false,
          live_portrait_lip_retargeting: false,
          live_portrait_lip_retargeting_multiplier: 1,
          live_portrait_eyes_retargeting_multiplier: 1
        }
      }
      break;
    // case 'tryon':

    //   break;
    default:
      throw Error('slug not found');
      break;
  }

  return {sheme};
}

async function convertBase64ToBlob(base64: string): Promise<Blob> {
  const response = await fetch(base64);
  return await response.blob();
}


==== src/app/api/create/fetch-model-details/route.ts ====
import { NextResponse } from 'next/server';
import { Client, handle_file } from "@gradio/client";
import { InputItem, OutputItem } from '@/types';

export async function POST(request: Request) {
  const { type, client, model, version } = await request.json();
  
  try {
    if (type === 'replicte') {
      const response = await fetch(`https://api.replicate.com/v1/models/${model}/versions/${version}`, {
        headers: {
          'Authorization': `Token ${process.env.REPLICATE_API_TOKEN}`,
          'Content-Type': 'application/json',
        },
      });
  
      if (!response.ok) {
        throw new Error('Failed to fetch model details');
      }
  
      const data = await response.json();
      
      const inputs = data.openapi_schema.components.schemas.Input.properties;
      const outputs = data.openapi_schema.components.schemas.Output;
      const required = data.openapi_schema.components.schemas.Input.required;
  
      return NextResponse.json({ inputs, outputs, required });
    } else if (type === 'gradio') {
      console.log('flag1', {client});
      
      const fixedClient = fixClient(client);
      let app = await Client.connect(String(fixedClient));

      console.log({'client': fixedClient, app: !!app});
      
      const app_info = await app.view_api();
      console.log({view_api: app_info});
      console.log(JSON.stringify(app_info, null, 2));
      
      const convertResult = await convertToIO({app_info, app, client: fixedClient});
      if (!convertResult) {
        throw new Error('Failed to convert to IO');
      }
      const { formattedEndpoints, api_info } = convertResult;

      return NextResponse.json({ formattedEndpoints, api_info, view_api: !!app_info }, { status: 200 });
    } else if (type === 'huggingface') { } 
    else if (type === 'fal') {
      const response = await fetch(`https://api.fal.ai/v1/models/${model}/versions/${version}`, {
        headers: {
          'Authorization': `Token ${
            process.env.FAL_API_TOKEN
          }`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch model details');
      }

      const data = await response.json();

      const inputs = data.openapi_schema.components.schemas.Input.properties;
      const outputs = data.openapi_schema.components.schemas.Output;
      const required = data.openapi_schema.components.schemas.Input.required;

      return NextResponse.json({ inputs, outputs, required });
    }
  } catch (error: any) {
    console.error('Error fetching model details:', error.message);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

function fixClient(inputClient: string): string {
  // First check if it looks like a URL
  if (inputClient.includes('://') || inputClient.startsWith('http')) {
    try {
      const url = new URL(inputClient);
      if (url.hostname === "huggingface.co") {
        const parts = url.pathname.split('/').filter(Boolean);
        // Handle both direct model paths and spaces paths
        if (parts[0] === "spaces" && parts.length > 1) {
          return parts.slice(1).join('/');
        } else if (parts.length >= 2) {
          return parts.join('/');
        }
      }
    } catch (e) {
      console.debug('Input is not a valid URL, proceeding as plain client name');
    }
  }
  
  // Clean up non-URL inputs
  return inputClient.startsWith('/') ? inputClient.slice(1) : inputClient;
}

// Define FormattedEndpoint type
interface FormattedEndpoint {
  key: string;
  inputs: Partial<InputItem>[];
  outputs: Partial<OutputItem>[];
}

// Simplified type for the app config
interface AppConfig {
  app_reference: string;
  config: {
    components: Array<{
      id: number;
      type: string;
      props: {
        label?: string;
        value?: any;
        [key: string]: any;
      };
      api_info: {
        type: string;
        items?: { type: string; enum?: string[] };
        properties?: { path: { type: string } };
        description?: string;
      };
    }>;
    dependencies: Array<{
      id: number;
      api_name: string;
      inputs: number[];
      outputs: number[];
    }>;
  };
}

/**
 * Maps Gradio component type to InputItem.component or OutputItem.component
 */
function mapComponent(type: string): InputItem['component'] | OutputItem['component'] {
  const lowerType = type.toLowerCase();
  switch (lowerType) {
    case 'textbox': return 'Textbox';
    case 'dropdown': return 'dropdown';
    case 'slider': return 'slider';
    case 'checkbox': return 'checkbox';
    case 'audio': return 'audio';
    case 'number': return 'number';
    case 'checkboxgroup': return 'checkboxgroup';
    default: return 'Textbox'; // Fallback for inputs
  }
}

/**
 * Maps Gradio api_info.type to InputItem.type or OutputItem.type
 */
function mapType(apiInfo: any): InputItem['type'] | OutputItem['type'] {
  if (apiInfo.type === 'boolean') return 'boolean';
  if (apiInfo.type === 'number') return 'integer'; // Map "number" to "integer" for InputItem
  if (apiInfo.type === 'string') return 'string';
  if (apiInfo.type === 'array') return 'array';
  if (apiInfo.type === 'object' && apiInfo.properties?.path) return 'string'; // FileData as string
  return 'string'; // Fallback
}

/**
 * Formats endpoints from /gradio_api/info or view_api() response
 */
function formatEndpointsFromApiInfo(apiInfo: any): FormattedEndpoint[] {
  const formattedEndpoints: FormattedEndpoint[] = [];
  const { named_endpoints } = apiInfo;

  for (const [key, valueObject] of Object.entries(named_endpoints)) {
    const inputs: InputItem[] = (valueObject as any).parameters.map((item: any) => ({
      key: item.parameter_name,
      component: mapComponent(item.component) as InputItem['component'],
      type: mapType(item.type) as InputItem['type'],
      label: item.label || item.parameter_name,
      value: item.parameter_default,
      description: item.type?.description || item.python_type?.description || undefined,
      show: true,
      required: !item.parameter_has_default,
    }));

    const outputs: OutputItem[] = (valueObject as any).returns.map((item: any, index: number) => ({
      key: item.label ? item.label.toLowerCase().replace(/\s+/g, '_') : `output_${index}`,
      component: mapComponent(item.component) as OutputItem['component'],
      type: mapType(item.type) as OutputItem['type'],
      title: item.label || `Output ${index}`,
      show: true,
      formatItem: item.python_type?.type,
    }));

    formattedEndpoints.push({ key, inputs, outputs });
  }

  return formattedEndpoints;
}

/**
 * Constructs the Gradio Space API URL from client string
 */
function constructAppRoot(client: string): string {
  const spaceName = client.toLowerCase().replace('/', '-');
  return `https://${spaceName}.hf.space`;
}

function formatEndpointsFromConfig(appConfig: AppConfig): FormattedEndpoint[] {
  const { config } = appConfig;

  const componentMap = new Map<number, AppConfig["config"]["components"][0]>();
  config.components.forEach(comp => componentMap.set(comp.id, comp));

  const generateKey = (label: string | undefined, index: number): string => {
    if (!label) return `param_${index}`;
    return label.toLowerCase().replace(/\s+/g, "_").replace(/[^a-z0-9_]/g, "");
  };

  const formattedEndpoints: FormattedEndpoint[] = [];

  config.dependencies
    .filter(dep => dep.api_name)
    .forEach(dep => {
      const endpointPath = `/${dep.api_name}`;

      // Format inputs
      const inputs: InputItem[] = dep.inputs.map((id, index) => {
        const comp = componentMap.get(id);
        if (!comp) {
          console.warn(`Component ID ${id} not found`);
          return {
            key: `param_${index}`,
            component: 'Textbox',
            type: 'string',
            label: `Input ${id}`,
            value: null,
            show: true,
          };
        }

        const { type: componentType, props, api_info } = comp;
        const label = props.label || `Input ${id}`;
        const value = 'value' in props ? props.value : null;

        return {
          key: generateKey(props.label, index),
          component: mapComponent(componentType) as InputItem['component'],
          type: mapType(api_info) as InputItem['type'],
          label,
          value,
          description: api_info.description || undefined,
          show: true,
        };
      });

      // Format outputs
      const outputs: OutputItem[] = dep.outputs.map((id, index) => {
        const comp = componentMap.get(id);
        if (!comp) {
          console.warn(`Component ID ${id} not found`);
          return {
            key: `output_${index}`,
            component: 'number',
            type: 'number',
            title: `Output ${id}`,
            show: true,
          };
        }

        const { type: componentType, props, api_info } = comp;
        const title = props.label || `Output ${id}`;

        return {
          key: generateKey(props.label, index),
          component: mapComponent(componentType) as OutputItem['component'],
          type: mapType(api_info) as OutputItem['type'],
          title,
          show: true,
          formatItem: api_info.type,
        };
      });

      formattedEndpoints.push({
        key: endpointPath,
        inputs,
        outputs,
      });
    });

  return formattedEndpoints;
}

/**
 * Converts Gradio API info or app config into formatted endpoints with multiple fallbacks
 */
interface ConvertToIOResponse {
  formattedEndpoints: FormattedEndpoint[] | null;
  api_info:{
    api: any;
    source: string;
  };
}
async function convertToIO({ app_info, app, client }: { app_info: any; app?: any, client: string }): Promise<ConvertToIOResponse | null> {
  const appRoot = app?.config?.root || constructAppRoot(client);
  console.log('convertToIO', {appRoot});
  const apiUrlInfo = `${appRoot}/info`;
  const apiUrlGradioAPI = `${appRoot}/gradio_api/info`;

  const responseInfo = await fetch(`${appRoot}/info`);
  const apiInfo = await responseInfo.json();

  console.log('flag0', {apiInfo, ok: responseInfo.ok});


  
  if (appRoot) {
    try {
      console.log(`Fetching ${apiUrlInfo}`);
      const response = await fetch(apiUrlInfo);
      console.log('flag2', {response});
      if (response.ok) {
        const apiInfo = await response.json();
        console.log('flag4', {apiInfo});
        if (apiInfo.named_endpoints && Object.keys(apiInfo.named_endpoints).length > 0) {
          console.log("Using /gradio_api/info data");
          return {
            formattedEndpoints: formatEndpointsFromApiInfo(apiInfo), 
            api_info: {
              api: apiInfo, 
              source: "/info"
            }
          };
        }
      } else {
        const response = await fetch(`${appRoot}/gradio_api/info`);
        if (response.ok) {
          const apiGradioApiInfo = await response.json();
          console.log('flag6', {apiGradioApiInfo});
          if (apiGradioApiInfo.named_endpoints && Object.keys(apiGradioApiInfo.named_endpoints).length > 0) {
            return {
              formattedEndpoints: formatEndpointsFromApiInfo(apiGradioApiInfo),
              api_info: {
                api: apiGradioApiInfo,
                source: "/gradio_api/info"
              }
            };
          }
        }

        
      }
    } catch (error: any) {
      console.log(`xxx Fetching ${apiUrlInfo}`);
      const response = await fetch(apiUrlGradioAPI);
      console.log('flag3', {response});
      if (response.ok) {
        const apiInfo = await response.json();
        console.log('flag5', {apiInfo});
        if (apiInfo.named_endpoints && Object.keys(apiInfo.named_endpoints).length > 0) {
          console.log("Using /info data");
          return {
            formattedEndpoints: formatEndpointsFromApiInfo(apiInfo),
            api_info: {
              api: apiInfo, 
              source: "/gradio_api/info"
            }
          };
        }
      }
    }
  }

  // Fallback to app_info from view_api()
  if (app_info && app_info.named_endpoints && Object.keys(app_info.named_endpoints).length > 0) {
    console.log("Falling back to app.view_api() data");
    return {
      formattedEndpoints: formatEndpointsFromApiInfo(app_info),
      api_info: {
        api: app_info, 
        source: "app_info"
      }
    };
  }

  // Final fallback to app.config
  if (app && app.config) {
    console.log("Falling back to app.config");
    return {
      formattedEndpoints: formatEndpointsFromConfig(app as AppConfig), 
      api_info: {
        api: app.config,
        source: "app_config"
      }};
  }

  console.log("No valid data source available");
  return null;
}


==== src/app/api/create/get/route.ts ====
import { NextResponse } from 'next/server';
import clientPromise from '@/lib/mongodb';
import { MongoClient } from 'mongodb';

export async function GET() {
  try {
    const client = await clientPromise;
    const { collection } = await validateMongoDBConnection(client);
    
    const fetchedApps = await collection.find({});
    const apps = await fetchedApps.toArray();

    console.log('Fetched apps:', apps);

    return NextResponse.json(apps, { status: 200 });
  } catch (error: any) {
    console.error('Error in GET /api/create/get:', error);
    return NextResponse.json({ message: 'Error fetching app configurations', error: error.message }, { status: 500 });
  }
}

async function validateMongoDBConnection(client: MongoClient) {
  const dbName = process.env.MONGODB_DB_NAME;
  const collectionName = process.env.MONGODB_COLLECTION_NAME;

  if (!dbName || !collectionName) {
    throw new Error('MONGODB_DB_NAME and MONGODB_COLLECTION_NAME must be set in environment variables');
  }
  
  const database = client.db(dbName);
  const collection = database.collection(collectionName);

  // Verify the database exists, create it if it doesn't
  const dbList = await client.db().admin().listDatabases();
  const dbExists = dbList.databases.some(db => db.name === dbName);
  if (!dbExists) {
    await client.db(dbName).createCollection('temp');
    console.log(`Created "${dbName}" database`);
    await client.db(dbName).dropCollection('temp');
  }

  // Verify the collection exists, create it if it doesn't
  const collections = await database.listCollections({ name: collectionName }).toArray();
  if (collections.length === 0) {
    await database.createCollection(collectionName);
    console.log(`Created "${collectionName}" collection`);
  }

  return { database, collection };
}


==== src/app/api/create/route.ts ====
import { NextResponse } from 'next/server';
import clientPromise from '@/lib/mongodb';
import { MongoClient } from 'mongodb';


export async function POST(request: Request) {
  try {
    const client = await clientPromise;
    const body = await request.json();
    
    const { collection } = await validateMongoDBConnection(client);

    const documentToInsert = {
      ...body,
      createdAt: new Date()
    };

    // Transform keys to strings
    const transformedDocument = Object.fromEntries(
      Object.entries(documentToInsert).map(([key, value]) => [String(key), value])
    );

    const result = await collection.insertOne(transformedDocument);

    return NextResponse.json({ message: 'App configuration created', id: result.insertedId }, { status: 201 });
  } catch (error: any) {
    console.error('Error in POST /api/create-app:', error);
    return NextResponse.json({ message: 'Error creating app configuration', error: error.message }, { status: 500 });
  }
}

async function validateMongoDBConnection(client: MongoClient) {
  const dbName = process.env.MONGODB_DB_NAME;
  const collectionName = process.env.MONGODB_COLLECTION_NAME;

  if (!dbName || !collectionName) {
    throw new Error('MONGODB_DB_NAME and MONGODB_COLLECTION_NAME must be set in environment variables');
  }
  
  const database = client.db(dbName);
  const collection = database.collection(collectionName);

  // Verify the database exists
  const dbList = await client.db().admin().listDatabases();
  const dbExists = dbList.databases.some(db => db.name === dbName);
  if (!dbExists) {
    throw new Error(`Database "${dbName}" does not exist`);
  }

  // Verify the collection exists
  const collections = await database.listCollections({ name: collectionName }).toArray();
  if (collections.length === 0) {
    throw new Error(`Collection "${collectionName}" does not exist`);
  }

  return { database, collection };
}

==== src/app/api/enhancebg/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  // 1. Get request data (in JSON format) from the client
  const req = await request.json();

  const {image, prompt} = req;

  if(!image || !prompt) return NextResponse.json(
      { error: 'not image or prompt /api' },
      { status: 500 }
    );
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    "dhanushreddy291/photo-background-generation:1db5ee211d65558d3fd11fc60bc00073f300d7a3a0b5abbfafbd20239ac58d2f";

  const input = {
    image,
    prompt,
    num_outputs: 1,
    negative_prompt: "3d, cgi, render, bad quality, normal quality",
    num_inference_steps: 30,
    controlnet_conditioning_scale: 1
  };

  const output = await replicate.run(model, { input });

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/experimental/sse/init/route.ts ====
import { NextResponse } from 'next/server';
import { getGradioBaseUrl } from '@/utils/gradio';

// Helper function to determine the correct API path
async function getGradioApiPath(client: string, endpoint: string): Promise<string> {
  const baseUrl = getGradioBaseUrl(client);

  // Try fetching /info to determine the path structure
  try {
    const infoResponse = await fetch(`${baseUrl}/info`);
    if (infoResponse.ok) {
      const infoData = await infoResponse.json();
      const cleanEndpoint = endpoint.startsWith('/') ? endpoint.slice(1) : endpoint;
      if (infoData?.named_endpoints?.[cleanEndpoint]) {
        console.log(`Using /call/${cleanEndpoint} based on /info`);
        return `${baseUrl}/call/${cleanEndpoint}`;
      }
    }
  } catch (e) {
    console.warn("Failed to fetch /info, falling back to /gradio_api/call");
  }

      // Fallback path - ensure no double slashes
      const cleanEndpoint = endpoint.startsWith('/') ? endpoint.slice(1) : endpoint;
      console.log(`Using fallback /gradio_api/call/${cleanEndpoint}`);
      return `${baseUrl}/gradio_api/call/${cleanEndpoint}`;
}
// https://Yuanshi-OminiControl_Art.hf.space/gradio_api/call/infer

    export async function POST(request: Request) {
      try {
        const { client, endpoint, inputs } = await request.json();

        if (!client || !endpoint || !inputs) {
          return NextResponse.json({ error: 'Missing client, endpoint, or inputs' }, { status: 400 });
        }

        const apiPath = await getGradioApiPath(client, endpoint);

        // Prepare headers, including HF token if available
        const headers: HeadersInit = { "Content-Type": "application/json" };
        if (process.env.HF_TOKEN) {
          headers["Authorization"] = `Bearer ${process.env.HF_TOKEN}`;
        }

        console.log(`Initiating prediction via POST to: ${apiPath}`);
        const response = await fetch(apiPath, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify({ data: inputs }) // Send inputs in the 'data' field
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`Gradio POST failed (${response.status}): ${errorText}`);
          return NextResponse.json({ error: `Gradio API request failed: ${errorText}` }, { status: response.status });
        }

        const responseData = await response.json();
        console.log("Gradio POST response:", responseData);

        if (!responseData.event_id) {
           return NextResponse.json({ error: 'Gradio did not return an event_id' }, { status: 500 });
        }

        // Return only the event_id and the client info needed for the stream request
        return NextResponse.json({ event_id: responseData.event_id, client });

      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error during SSE init';
        console.error("SSE Init Error:", errorMessage);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
      }
    }


==== src/app/api/experimental/sse/stream/route.ts ====
import { NextRequest } from 'next/server';
import { getGradioBaseUrl } from '@/utils/gradio';

export const dynamic = 'force-dynamic'; // Ensure dynamic execution

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const eventId = searchParams.get('event_id');
  const client = searchParams.get('client');
  const endpoint = searchParams.get('endpoint');

  if (!eventId || !client || !endpoint) {
    return new Response('Missing event_id, client, or endpoint', { status: 400 });
  }

  const baseUrl = getGradioBaseUrl(client);
  const cleanEndpoint = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint;
  const streamUrl = `${baseUrl}/call/${cleanEndpoint}/${eventId}`;

  console.log(`Attempting to stream from: ${streamUrl}`);

  try {
    const headers: HeadersInit = {};
    if (process.env.HF_TOKEN) {
      headers["Authorization"] = `Bearer ${process.env.HF_TOKEN}`;
    }

    const gradioResponse = await fetch(streamUrl, {
      method: 'GET',
      headers: headers,
      // @ts-ignore - Necessary for streaming
      duplex: 'half'
    });

    if (!gradioResponse.ok) {
      const errorText = await gradioResponse.text();
      console.error(`Gradio SSE request failed (${gradioResponse.status}): ${errorText}`);
      const errorEvent = `event: error_event\ndata: ${JSON.stringify(`Gradio request failed: ${gradioResponse.status}`)}\n\n`;
      return new Response(errorEvent, { status: 200, headers: { 'Content-Type': 'text/event-stream' } });
    }

    if (!gradioResponse.body) {
      throw new Error('Gradio response body is null');
    }

    const reader = gradioResponse.body.getReader();
    const stream = new ReadableStream({
      async start(controller) {
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            controller.enqueue(value);
          }
        } catch (error) {
          console.error("SSE Stream Error:", error);
          controller.error(error);
        } finally {
          controller.close();
          reader.releaseLock();
        }
      },
      cancel() {
        reader.cancel();
      }
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error("SSE Stream Error:", errorMessage);
    const errorEvent = `event: error_event\ndata: ${JSON.stringify(errorMessage)}\n\n`;
    return new Response(errorEvent, { status: 200, headers: { 'Content-Type': 'text/event-stream' } });
  }
}


==== src/app/api/illuminai/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  const req = await request.json();

  const {image, prompt, source} = req;

  console.log('/api', {image, prompt, source});

  if(!image || !prompt || !source) {
    return NextResponse.json(
      { error: 'not image, prompt or source /api' },
      { status: 500 }
    );
  }
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    "zsxkib/ic-light:d41bcb10d8c159868f4cfbd7c6a2ca01484f7d39e4613419d5952c61562f1ba7";

  const input = {
    cfg: 2,
    steps: 25,
    width: 512,
    height: 640,
    prompt: prompt,
    light_source: "Left Light",
    highres_scale: 1.5,
    output_format: "webp",
    subject_image: image,
    lowres_denoise: 0.9,
    output_quality: 80,
    appended_prompt: "best quality",
    highres_denoise: 0.5,
    negative_prompt: "lowres, bad anatomy, bad hands, cropped, worst quality, dark",
    number_of_images: 1
  }

  let output: any | null = null;

  try {
    output = await replicate.run(model, { input });
  } catch (error: any) {
    console.log('illuminai /api', {error});
    return NextResponse.json(
      { error: `Something went wrong, ${error.message}` },
      { status: 500 }
    );
  }

  
  
  // const output = [
  //   "https://replicate.delivery/pbxt/DCiXOO8IjXKeM6ecacI0hP7jEBfHX5uYt3a0bf85dNNYBwHMB/generated_0.webp"
  // ]

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/inter-design/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  const req = await request.json();

  const image = req.image;
  const theme = req.theme;
  const room = req.room;

  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    'jagilley/controlnet-hough:854e8727697a057c525cdb45ab037f64ecca770a1769cc52287c2e56472a247b';

  const input = {
    image,
    prompt: `A ${theme} ${room} Editorial Style Photo, Symmetry, Straight On, Modern Living Room, Large Window, Leather, Glass, Metal, Wood Paneling, Neutral Palette, Ikea, Natural Light, Apartment, Afternoon, Serene, Contemporary, 4k`,
    a_prompt: `best quality, extremely detailed, photo from Pinterest, interior, cinematic photo, ultra-detailed, ultra-realistic, award-winning`,
  };

  const output = await replicate.run(model, { input });

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/preview/get/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;
if (!REPLICATE_API_TOKEN) throw Error('REPLICATE_API_TOKEN not found');

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    
    if (!id) {
      return NextResponse.json(
        { error: 'Prediction ID is required' },
        { status: 400 }
      );
    }

    // For Gradio results (which are immediate)
    if (id.startsWith('gradio_')) {
      return NextResponse.json({
        status: 'succeeded',
        output: null // Output was already returned in the POST response
      });
    }

    // For Replicate results
    const replicate = new Replicate({
      auth: REPLICATE_API_TOKEN!,
    });

    const prediction = await replicate.predictions.get(id);
    
    return NextResponse.json({
      status: prediction.status,
      output: prediction.output,
    });
  } catch (error: any) {
    console.error('Error checking prediction status:', error);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}


==== src/app/api/preview/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';
import { Client, handle_file } from "@gradio/client";

const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;
if (!REPLICATE_API_TOKEN) throw Error('REPLICATE_API_TOKEN not found');

async function convertBase64ToBlob(base64: string): Promise<Blob> {
  const response = await fetch(base64);
  return await response.blob();
}

interface ConfigInput {
  key: string;
  component: string;
  show?: boolean;
  value?: any;
}

interface PreviewConfig {
  type: 'replicate' | 'gradio';
  model?: string;
  version?: string;
  client?: string;
  path?: string;
  inputs: ConfigInput[];
  endpoint?: string;
}

export async function POST(request: Request) {
  console.log('Preview POST request received');
  try {
    const { config, params } = await request.json();
    console.log('Preview request:', { config, params });

    if (!config) {
      return NextResponse.json(
        { error: 'Configuration is required' },
        { status: 400 }
      );
    }

    // Handle Replicate models
    if (config.type === 'replicate') {
      const replicate = new Replicate({
        auth: REPLICATE_API_TOKEN,
      });

      if (!config.model || typeof config.model !== 'string') {
        throw new Error('Model identifier is required for Replicate models');
      }

      if (!config.version) {
        throw new Error('Model version is required for Replicate models');
      }

      // Process inputs according to configuration
      const input: { [key: string]: any } = {};
      const typedConfig = config as PreviewConfig;
      typedConfig.inputs.forEach((item: ConfigInput) => {
        if (item.show) {
          switch (item.component) {
            case 'image':
              if (params.image && params.image[item.key]) {
                input[item.key] = params.image[item.key];
              }
              break;
            case 'prompt':
              input[item.key] = params[item.key];
              break;
            case 'textbox':
              input[item.key] = params[item.key];
              break;
            default:
              input[item.key] = params[item.key];
          }
        } else if (item.value !== undefined) {
          // Use default value for hidden inputs
          input[item.key] = item.value;
        }
      });

      console.log('Replicate input:', input);

      const prediction = await replicate.predictions.create({
        model: typedConfig.model as `${string}/${string}`,
        version: typedConfig.version,
        input,
      });

      console.log('Replicate prediction started:', prediction);

      return NextResponse.json({ 
        id: prediction.id,
        status: prediction.status
      }, { status: 201 });
    }
    // Handle Gradio models
    else if (config.type === 'gradio') {
      const typedConfig = config as PreviewConfig;
      if (!typedConfig.client || !typedConfig.path || !typedConfig.endpoint) {
        throw new Error('Client and path are required for Gradio models');
      }

      const processedParams: Record<string, any> = {};

      // Process each input
      for (const item of typedConfig.inputs) {
        const input = item as ConfigInput;
        
        if (!input.show) {
          if (input.value !== undefined) {
            processedParams[input.key] = input.value;
          }
          continue;
        }

        switch (input.component) {
          case 'image': {
            const image = params.image && params.image[input.key];
            if (image) {
              if (typeof image === 'string' && image.startsWith('data:image/')) {
                processedParams[input.key] = await handle_file(await convertBase64ToBlob(image));
              } else {
                processedParams[input.key] = await handle_file(image);
              }
            }
            break;
          }
          case 'textbox':
            processedParams[input.key] = params[input.key];
            break;
          case 'prompt':
            processedParams[input.key] = params[input.key];
            break;
          default:
            processedParams[input.key] = params[input.key] !== undefined ? params[input.key] : input.value;
            break;
        }
      }

      console.log('Gradio params:', {processedParams, typedConfig});

      let app;

      try {
        app = await Client.connect(typedConfig.client!);
        console.log('app:', {path: typedConfig.client, processedParams});
      } catch (error:any) {
        throw new Error(`Error connecting app to Gradio client: ${error.message}`);
      }
      console.log('Gradio app connected:', !!app);

      let result;

      // Validate parameters
      if (!processedParams || typeof processedParams !== 'object') {
        throw new Error('Invalid parameters for prediction');
      }

      const predictParams = {
        endpoint: typedConfig.endpoint,
        data: processedParams,
      }
      console.log('Gradio predict params:', predictParams);
      
      try {
        // Get API info to validate endpoint and parameters
        // const apiInfo = await app.view_api();
        
        // if (!apiInfo.named_endpoints[typedConfig.endpoint]) {
        //   console.error('Available endpoints:', apiInfo.named_endpoints);
        //   // TODO we need to manage the alternative
        //   throw new Error(`Endpoint ${typedConfig.endpoint} not found in app`);
        // }
        // console.log('after apiInfo:');

        // const endpointInfo = apiInfo.named_endpoints[typedConfig.endpoint];
        // const requiredParams = endpointInfo.parameters
        //   ? endpointInfo.parameters
        //       .filter((p: any) => !p.parameter_has_default)
        //       .map((p: any) => p.parameter_name)
        //   : [];

        // const missingParams = requiredParams.filter(
        //   (param: string) => processedParams[param] === undefined
        // );
        
        // if (missingParams.length > 0) {
        //   throw new Error(`Missing required parameters: ${missingParams.join(', ')}`);
        // }

        // Log detailed parameter info before prediction
        console.log('Final prediction parameters:', {
          endpoint: typedConfig.endpoint,
          params: processedParams,
          paramTypes: Object.entries(processedParams).map(([k, v]) => ({
            param: k,
            type: typeof v,
            value: v
          }))
        });

        // Prepare final prediction parameters
        const predictionParams = {...processedParams};

        // Convert image Blobs directly to base64 strings
        if (predictionParams.input_fg instanceof Blob) {
          const arrayBuffer = await predictionParams.input_fg.arrayBuffer();
          const base64String = Buffer.from(arrayBuffer).toString('base64');
          predictionParams.input_fg = `data:image/png;base64,${base64String}`; 
        }
        if (predictionParams.scribble_map instanceof Blob) {
          const arrayBuffer = await predictionParams.scribble_map.arrayBuffer();
          const base64String = Buffer.from(arrayBuffer).toString('base64');
          predictionParams.scribble_map = `data:image/png;base64,${base64String}`; 
        }

        // Log the final parameters being sent
        console.log('Final prediction parameters (base64 converted):', {
          endpoint: typedConfig.endpoint,
          params: predictionParams,
          paramTypes: Object.entries(predictionParams).map(([k, v]) => ({
            param: k,
            type: typeof v,
            value: typeof v === 'string' && v.length > 100 ? v.substring(0, 100) + '...' : v
          }))
        });

        try {
          result = await app.predict(typedConfig.endpoint, predictionParams);
        } catch (error: any) {
          console.error('Detailed prediction error:', {
            error: error.message,
            stack: error.stack,
            endpoint: typedConfig.endpoint,
            params: processedParams,
            paramTypes: Object.entries(processedParams).map(([k, v]) => ({
              param: k,
              type: typeof v,
              value: v
            }))
          });
          throw new Error(`Prediction failed for endpoint ${typedConfig.endpoint}: ${error.message}`);
        }
      } catch (error: any) {
        console.error('Detailed prediction error:', {
          error: error.message,
          stack: error.stack,
          endpoint: typedConfig.endpoint,
          params: processedParams
        });
        throw new Error(`Prediction failed: ${error.message}`);
      }

      console.log('Gradio result:', JSON.stringify(result, null, 2));

      if (!result) {
        throw new Error('Gradio model returned no output');
      }

      return NextResponse.json({
        status: 'succeeded',
        output: result.data
      }, { status: 201 });
    }

    throw new Error('Unsupported model type');
  } catch (error: any) {
    console.error('Error in preview:', error);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    if (!id) {
      return NextResponse.json(
        { error: 'Prediction ID is required' },
        { status: 400 }
      );
    }
    
    // For Gradio results (which are immediate)
    if (id.startsWith('gradio_')) {
      return NextResponse.json({
        status: 'succeeded',
        output: null // Output was already returned in the POST response
      });
    }
    
    // For Replicate results
    const replicate = new Replicate({
      auth: REPLICATE_API_TOKEN!,
    });
    
    const prediction = await replicate.predictions.get(id);
    console.log('Replicate prediction status:', prediction);
    
    return NextResponse.json({
      status: prediction.status,
      output: prediction.output,
    });
  } catch (error: any) {
    console.error('Error checking prediction status:', error);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}


==== src/app/api/removebg/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  // 1. Get request data (in JSON format) from the client
  const req = await request.json();

  const {image} = req;

  if(!image) return NextResponse.json(
      { error: 'not image or prompt /api' },
      { status: 500 }
    );
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    "smoretalk/rembg-enhance:4067ee2a58f6c161d434a9c077cfa012820b8e076efa2772aa171e26557da919";

  const model2 =
    "codeplugtech/background_remover:37ff2aa89897c0de4a140a3d50969dc62b663ea467e1e2bde18008e3d3731b2b";

  const input = {
    image
  };

  const output = await replicate.run(model2, { input });

  // const output = "https://replicate.delivery/pbxt/P9oH8knhkOqvAlGPiLI72IwWs8OJ65u7uIZc1wOqkiOa4dwE/out.png"

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('route', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/simpson/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  // 1. Get request data (in JSON format) from the client
  const req = await request.json();

  const {image, prompt} = req;

  if(!image || !prompt) return NextResponse.json(
      { error: 'not image or prompt /api' },
      { status: 500 }
    );
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const modelS =
    "fofr/sdxl-simpsons-characters:f4d36a72b43ea2fd511cab0afb32539955ee5b28b65c8e3fb7d8abd254be8e91";

  const model = 
    "fofr/pulid-base:65ea75658bf120abbbdacab07e89e78a74a6a1b1f504349f4c4e3b01a655ee7a";

  // const input = {
  //   width: 1024,
  //   height: 1024,
  //   prompt: prompt,
  //   refine: "expert_ensemble_refiner",
  //   scheduler: "K_EULER",
  //   lora_scale: 0.6,
  //   num_outputs: 1,
  //   guidance_scale: 7.5,
  //   apply_watermark: false,
  //   high_noise_frac: 0.8,
  //   negative_prompt: "ugly, broken, distorted, artefacts, 3D, render, photography",
  //   prompt_strength: 0.8,
  //   num_inference_steps: 30
  // }

  const input = {
    width: 1024,
    height: 1024,
    prompt: prompt,
    face_image: image,
    face_style: "high-fidelity",
    output_format: "webp",
    output_quality: 80,
    negative_prompt: "boy",
    checkpoint_model: "animated - starlightXLAnimated_v3",
    number_of_images: 1
  }
  

  const output = await replicate.run(model, { input });

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/upscale/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  const req = await request.json();

  const {image} = req;

  // console.log('/api', {image});

  if(!image) {
    return NextResponse.json(
      { error: 'not image /api' },
      { status: 500 }
    );
  }
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    "philz1337x/clarity-upscaler:dfad41707589d68ecdccd1dfa600d55a208f9310748e44bfe35b4a6291453d5e";
  
  const input = {
    seed: 1337,
    image: image,
    prompt: "masterpiece, best quality, highres, <lora:more_details:0.5> <lora:SDXLrender_v2.0:1>",
    dynamic: 6,
    handfix: "disabled",
    pattern: false,
    sharpen: 0,
    sd_model: "juggernaut_reborn.safetensors [338b85bc4f]",
    scheduler: "DPM++ 3M SDE Karras",
    creativity: 0.35,
    lora_links: "",
    downscaling: false,
    resemblance: 0.6,
    scale_factor: 2,
    tiling_width: 112,
    output_format: "png",
    tiling_height: 144,
    custom_sd_model: "",
    negative_prompt: "(worst quality, low quality, normal quality:2) JuggernautNegative-neg",
    num_inference_steps: 18,
    downscaling_resolution: 768
  }

  let output: any | null = null;

  try {
    output = await replicate.run(model, { input });
  } catch (error: any) {
    console.log({error});
    return NextResponse.json(
      { error: `Something went wrong, ${error.message}` },
      { status: 500 }
    );
  }

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/app/[slug]/ClientPage.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState, useEffect, useCallback } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon, FaceSmileIcon, VideoCameraIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu";
import { Configuration, ImageAreaProps, InputItem, OutputItem } from "@/types";
import { sleep } from "@/utils";
import { Prompt } from "@/components/prompt";
import { Slider, Checkbox, CheckboxGroup, NumberInput, NumberOutput } from "@/components/numericInput";
import { AudioOutput } from "@/components/audioOutput";
import { TextOutput } from "@/components/textOutput";
import { useRouter } from 'next/navigation';
import { notFound } from 'next/navigation';
import { getConfigurations } from '@/common/configuration';

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type UploadedVideoProps = {
  video: File;
  removeVideo(): void;
  file: {
    name: string;
    size: string;
  };
};

type UploadedAudioProps = {
  audio: File;
  audioUrl: string | null;
  removeAudio(): void;
  file: {
    name: string;
    size: string;
  };
};

function UploadedAudio({ audio, audioUrl, removeAudio, file }: UploadedAudioProps) {
  return (
    <div className="p-4 bg-gray-800 rounded-md mb-4">
      <p className="text-sm text-gray-300">
        Audio ready: {file.name} ({file.size})
      </p>
      {audioUrl && (
        <audio 
          src={audioUrl} 
          controls
          className="mt-2 w-full"
        />
      )}
      <button
        onClick={removeAudio}
        className="mt-2 text-red-400 hover:text-red-300 text-sm"
      >
        Remove Audio
      </button>
    </div>
  );
}

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const sources = ["None", "Left Light", "Right Light", "Bottom Light", "Top Light"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const acceptedVideoTypes = {
  "video/*": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB
const maxVideoSize = 100 * 1024 * 1024; // 100MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a room and let our AI generate a new design.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full m-3">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black z-10"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedVideoProps} props The component props
 */
function UploadedVideo({ file, video, removeVideo }: UploadedVideoProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <video
          src={URL.createObjectURL(video)}
          className="h-full w-full object-cover"
          controls
          autoPlay
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black z-10"
        onClick={removeVideo}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[], id: number): void;
  }
) {
  return (
    <Dropzone
      onDrop={(acceptedFiles, rejectedFiles) => props.onImageDrop(acceptedFiles, rejectedFiles, props.id as number)}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function AudioDropzone(
  props: ImageAreaProps & {
    onAudioDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
    onRecordAudio(blob: Blob): void;
  }
) {
  const [isRecording, setIsRecording] = useState(false);
  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);
  const [audioChunks, setAudioChunks] = useState<Blob[]>([]);
  const [permissionStatus, setPermissionStatus] = useState<'prompt'|'granted'|'denied'>('prompt');
  const [permissionError, setPermissionError] = useState<string|null>(null);

  const checkPermission = async () => {
    try {
      const permissionResult = await navigator.permissions.query({ name: 'microphone' as PermissionName });
      setPermissionStatus(permissionResult.state as 'granted'|'denied');
      permissionResult.onchange = () => {
        setPermissionStatus(permissionResult.state as 'granted'|'denied');
      };
    } catch (err) {
      console.warn('Permission API not supported, falling back to direct request');
    }
  };

  const startRecording = async () => {
    try {
      if (permissionStatus === 'denied') {
        setPermissionError('Microphone access was previously denied. Please update permissions in your browser settings.');
        return;
      }

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
        .catch(err => {
          if (err.name === 'NotAllowedError') {
            setPermissionStatus('denied');
            setPermissionError('Microphone access is required for recording. Please allow microphone access and try again.');
          }
          throw err;
        });

      setPermissionStatus('granted');
      setPermissionError(null);
      const recorder = new MediaRecorder(stream);
      setMediaRecorder(recorder);
      
      recorder.ondataavailable = (e) => {
        setAudioChunks(prev => [...prev, e.data]);
      };
      
      recorder.onstop = () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        props.onRecordAudio(audioBlob);
        stream.getTracks().forEach(track => track.stop());
      };
      
      recorder.start();
      setIsRecording(true);
      setAudioChunks([]);
    } catch (err) {
      console.error('Error starting recording:', err);
    }
  };

  const stopRecording = () => {
    if (mediaRecorder) {
      mediaRecorder.stop();
      setIsRecording(false);
    }
  };

  return (
    <div className="space-y-4">
      <Dropzone
        onDrop={props.onAudioDrop}
        accept={{
          "audio/*": [".mp3", ".wav"],
        }}
        maxSize={100 * 1024 * 1024} // 100MB
        multiple={false}
      >
        {({ getRootProps, getInputProps }) => (
          <>
            <input {...getInputProps()} />
            <button
              {...getRootProps()}
              type="button"
              className="relative block minh-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
            >
              <props.icon className="mx-auto h-12 w-12 text-gray-400" />
              <span className="mt-2 block text-sm font-semibold text-gray-300">
                {props.title}
              </span>
            </button>
          </>
        )}
      </Dropzone>
      
      <div className="flex justify-center gap-4">
        <button
          type="button"
          onClick={isRecording ? stopRecording : startRecording}
          className={`px-4 py-2 rounded-md ${
            isRecording 
              ? 'bg-red-500 hover:bg-red-600' 
              : 'bg-green-500 hover:bg-green-600'
          } text-white`}
        >
          {isRecording ? 'Stop Recording' : 'Record Audio'}
        </button>
      </div>
    </div>
  );
}

function VideoDropzone(
  props: ImageAreaProps & {
    onVideoDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onVideoDrop}
      accept={{
        "video/*": [".mp4"],
      }}
      maxSize={maxVideoSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

interface ModelInput {
  prompt: boolean;
  image: number;
  video: boolean;
  select: boolean;
}

interface ModelOutput {
  image: boolean;
  video: boolean;
}

interface Model {
  input: ModelInput;
  output: ModelOutput;
}

function layout({slug}: {slug: string}): { model: Model } {
  let model: Model = {
    input: {
      prompt: false,
      image: 0,
      video: false,
      select: false,
    },
    output: {
      image: false,
      video: false,
    }
  }

  switch(slug) {
    case "createVideo":
      model.input.prompt = model.output.video = true;
      break;
    case "upscaler":
      model.input.image = 1;
      model.output.image = true;
      break;
    case "hairStyle":
      model.input.image = 1;
      model.output.image 
        = model.input.prompt
        = true;
      break;
    case "livePortrait":
      model.input.image = 1;
      model.input.video = true;
      model.output.video = true;
      break;
    default:
      break;
  }

  return {model};
}

type Slug = "createVideo" | "freshink" | "hairStyle" | "upscaler" | "livePortrait" | 'tryon' | 'logo' | 'EVF-SAM';
type Status = "starting" | "processing" | "succeeded" | "failed" | "canceled";
/**
 * Display the home page
 */
export default function ClientPage({ slug, initialConfigurations }: { slug: Slug, initialConfigurations: Configuration[] }) {
  const [loading, setLoading] = useState(true);
  const [retryCount, setRetryCount] = useState(0);
  const [config, setConfig] = useState<Configuration | null>(null);
  const [outputImage, setOutputImage] = useState<string[] | null>(null);
  const [base64Images, setBase64Images] = useState<string[]>([]);
  const [outputVideo, setOutputVideo] = useState<string | null>(null);
  const [base64Video, setBase64Video] = useState<string | null>(null);
  const [source, setSource] = useState<string>(sources[0]);
  const [prompt, setPrompt] = useState<string | null>(null);
  const [error, setError] = useState<string | null>("");
  const [files, setFiles] = useState<File[]>([]);
  const [video, setVideo] = useState<File | null>(null);
  const [audio, setAudio] = useState<File | null>(null);
  const [base64Audio, setBase64Audio] = useState<string | null>(null);

  const handleRecordedAudio = (blob: Blob) => {
    const audioFile = new File([blob], 'recording.wav', { type: 'audio/wav' });
    setAudio(audioFile);
    console.log('Audio file set:', audioFile.name, audioFile.size);
    
    const reader = new FileReader();
    reader.readAsDataURL(blob);
    reader.onload = () => {
      const result = reader.result as string;
      setBase64Audio(result);
      console.log('Recorded audio converted to base64:', result.substring(0, 50) + '...');
      console.log('Audio state updated - audio:', audioFile, 'base64:', !!result);
    };
  };

  const fetchConfig = useCallback(async () => {
    const configurations = await getConfigurations();
    const foundConfig = configurations.find(conf => conf.name === slug);
    if (foundConfig) {
      setConfig(foundConfig);
      setLoading(false);
    } else if (retryCount < 2) {
      setTimeout(() => {
        setRetryCount(prev => prev + 1);
      }, 1000);
    } else {
      setLoading(false);
    }
  }, [slug, retryCount]);

  useEffect(() => {
    fetchConfig();
  }, [fetchConfig]);

  useEffect(() => {
    if (!loading && !config) {
      window.location.reload();
    }
  }, [loading, config]);

  if (loading) {
    return <div>Loading... Attempt {retryCount + 1} of 3</div>;
  }

  if (!config) {
    return notFound();
  }

  console.log({config});

  const {model} = layout({slug});
  
  let contImg = 0;

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[],
    id: number,
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError(`Please upload a PNG or JPEG image less than ${maxFileSize}MB.`);
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFiles((prevFiles) => ({ ...prevFiles, [id]: acceptedFiles[0] }));

    // Convert to base64
    convertImageToBase64(acceptedFiles[0], id);
  }

  function onAudioDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError(`Please upload an MP3 or WAV file less than 100MB.`);
      return;
    }

    setAudio(null);
    console.info(acceptedFiles);
    setError("");
    setAudio(acceptedFiles[0]);

    // Convert to base64
    const reader = new FileReader();
    reader.readAsDataURL(acceptedFiles[0]);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Audio(binaryStr);
    };
  }

  function onVideoDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError(`Please upload a MP4 video less than ${maxVideoSize}MB.`);
      return;
    }

    removeVideo();

    console.info(acceptedFiles);
    setError("");
    setVideo(acceptedFiles[0]);

    // Convert to base64
    convertVideoToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File, id: number): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Images(prevImg => ({...prevImg, [id]: binaryStr}));
    };
  }

  function convertVideoToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Video(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(id?: number): void {
    // setFiles((prevFiles) => ({ ...prevFiles, [id]: null }));
    setOutputImage(null);
  }

  /**
   * Remove the uploaded video
   * @returns void
   */
  function removeVideo(): void {
    setVideo(null);
    setOutputVideo(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    if (outputImage && Array.isArray(outputImage) && outputImage.length > 0) {
      saveAs(outputImage[0], "output.png"); // Use the first image in the array
    }
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage({slug}: {slug: Slug}): Promise<void> {
    const params: any = { 
      prompt, 
      image: base64Images, 
      video: base64Video,
      audio: base64Audio 
    };
    
    if (config?.inputs) {
      let imgI = 0;
      for (const [key, value] of Object.entries(config.inputs)) {
        if (value.show) {
          const {component} = value;
          if (component === 'image') {
            if(!params[component][imgI]) {
              alert(`must to fill the ${component} ${imgI}`)
              return;
            }
            imgI++;
          } else if(params[component]) {
            console.log(`${component} ${imgI} filled`);
          } else {
            alert(`must to fill the ${component}`)
            // return;
          }
        }
      }
    }
    
    for (const [key, value] of Object.entries(model.input)) {
      if (value) {
        if (typeof value === 'number') {
          for(let i= 0; i < value ;i++) {
            if (params[key][i]) { 
              console.log('Ok', {key, i});
            } else {
              console.log('alert', key, params[key]);
              setError(`Must fill the field ${key} ${value}`);
              return; // Exit the function early
            }
          }
        } else {
          if (params[key]) {
            console.log('Ok', key);
          } else {
            console.log('alert', key, params[key]);
            setError(`Must fill the field ${key}`);
            return;
          }
        }
      }
    }

    setLoading(true);

    let prediction: any;

    if (slug === 'EVF-SAM') {
      if(!prompt) {
        alert('Please upload the files.');
        return;
      }
      if (initialConfigurations) {
        const evfSamConfig = initialConfigurations.find(conf => conf.name === 'EVF-SAM');
        if (evfSamConfig) {
          const formData = new FormData();
          formData.append(evfSamConfig.inputs[0].key, files[0]);
          formData.append(evfSamConfig.inputs[1].key, prompt);

          console.log('flag1', {formData});

          const response = await fetch(`/api/app/${slug}`, {
            method: "POST",
            body: formData,
          });
          if (response.status !== 201) {
            console.log('err ', {response})
            setError("error");
            setLoading(false);
            return;
          }
          console.log('flag2');
          
          const responseJSON = await response.json();
          console.log('flag3', {responseJSON})

          console.log({responseJSON});
          
          prediction = {
            state: {
              output: responseJSON[0].url,
            }
          }
        }
      }
    } else {
      let response: any;
      let result: any;
      let status: Status | null = null;


      console.log('clientPagw', {params});

      const genA = await fetch(`/api/app/${slug}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(params),
      });

      if (!genA.ok) {
        setError(genA.statusText);
        setLoading(false);
        return;
      }
      
      const responseData = await genA.json();

      console.log({responseData});
  
      const id = responseData.id;
      

      if (id) {
        do {
          await sleep(1_000);
          response = await fetch(`/api/app/${slug}/get`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ id }),
          });
          result = await response.json();
          
          if (result.error) {
            setError(result.error);
            setLoading(false);
            return;
          }
    
          status = result.state.status;
    
          console.log({status});
        } while (status !== 'succeeded' && status !== 'failed');
        if (status === 'failed') throw Error("status failed");
      } else {
        // Handle Gradio format if present
        if (Array.isArray(responseData) && responseData[0]?.url) {
          // Extract just the URLs from the Gradio response objects
          const urls = responseData.map(item => item.url);
          result = {
            status: 'succeeded',
            output: urls
          };
          console.log('array and url',{result});
        } else {
          result = {
            status: 'succeeded',
            output: responseData.output
          };
        }
      }
      
      prediction = result;
      console.log('Final prediction:', prediction);
    }
    
    
    if (config && config.outputs) {
      console.log({outputs: config.outputs});
      config.outputs.forEach((item: OutputItem) => {
        const {component} = item; // Change 'type' to 'component'
        console.log({prediction});
        const out = prediction?.state?.output || prediction.output;
        console.log({out});
        if (component === 'image') { // Update the condition to check 'component'
          if (Array.isArray(out)) { // Check if output is an array)
            const urls = out.map((item) => item.url);
            if (urls.length > 0) {
              setOutputImage(urls); // Set the entire array
            } else {
              setOutputImage(out);
            }
          } else if (typeof out === 'string') {
            setOutputImage([out]); // Wrap single string in an array
          } else {
            console.error('Invalid output format');
            throw Error('Invalid output format');
          }
        } else if (component === 'video') {
          if (config?.outputs && config.outputs.length > 0) {
            const key = config.outputs[0].key;
            setOutputVideo(out[key]);
          } else {
            console.error('Invalid key');
            throw Error('Invalid key');
          }
        }
      })
    }

    if(model.output.video) {
      console.log({prediction});
      const videox = prediction.state.output ? prediction.state.output[0] : null;
      console.log({videox})
      setOutputVideo(videox);
    } else if(model.output.image) {
      // Handle Gradio format if present
      if (Array.isArray(prediction.output) && prediction.output[0]?.url) {
        setOutputImage([prediction.output[0].url]);
      } else {
        setOutputImage(prediction.output[0]);
      }
    }

    setLoading(false);
  }
  
  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={() => submitImage({slug})} />
      
      <div className="flex flex-row">
        <div className="flex flex-col w-1/2">
          <h1 className="mx-auto">Input</h1>
          <section className="mx-4 mt-9 flex flex-col space-y-8 lg:mx-6 gap-4 lg:space-x-8 lg:space-y-0 xl:mx-8">
            {config?.inputs.map((item: InputItem, index: number) => {
              if (('show' in item) && item['show']) {
                const { component } = item;
                switch (component.toLowerCase()) {
                  case 'image':
                    const Img = !files[contImg] ?
                      (<ImageDropzone
                        key={index}
                        id={contImg}
                        title={`Drag 'n drop your image here or click to upload`}
                        onImageDrop={onImageDrop}
                        icon={slug === 'hairStyle' ? FaceSmileIcon : PhotoIcon}
                      />)
                      :
                      (<UploadedImage
                        key={index}
                        image={files[contImg]}
                        removeImage={() => removeImage(contImg)}
                        file={{ name: files[contImg].name, size: fileSize(files[contImg].size) }}
                      />)
                    contImg += 1;
                    return Img;
                  case 'prompt':
                    return(
                      <Prompt
                        key={index}
                        label={item.label as string}
                        placeholder={item.placeholder as string} 
                        description={item.description as string}
                        placeholderTextArea={item.value as string}
                        setPrompt={setPrompt}
                      />)
                  case 'textbox':
                    return(
                      <Prompt
                        key={index}
                        label={item.label as string}
                        placeholder={item.placeholder as string} 
                        description={item.description as string}
                        placeholderTextArea={item.value as string}
                        setPrompt={setPrompt}
                      />)
                  case 'number':
                    return (
                      <NumberInput
                        key={index}
                        label={item.label as string || 'Value'}
                        description={item.description as string}
                        min={Number(item.min) || 0}
                        max={Number(item.max) || 100}
                        step={Number(item.step) || 1}
                        defaultValue={Number(item.value) || 50}
                        onChange={(value) => setPrompt(value.toString())}
                      />
                    )
                  case 'slider':
                    return (
                      <Slider
                        key={index}
                        label={item.label as string}
                        description={item.description as string}
                        min={item.min as number || 0}
                        max={item.max as number || 100}
                        step={item.step as number || 1}
                        defaultValue={item.value as number || 50}
                        onChange={(value) => setPrompt(value.toString())}
                      />
                    )
                  case 'checkbox':
                    return (
                      <Checkbox
                        key={index}
                        label={item.label as string}
                        description={item.description as string}
                        defaultChecked={item.value as boolean}
                        onChange={(checked) => setPrompt(checked.toString())}
                      />
                    )
                  case 'checkboxgroup':
                    return (
                      <CheckboxGroup
                        key={index}
                        label={item.label as string}
                        description={item.description as string}
                        options={item.options as string[] || []}
                        defaultSelected={(item.value as string[]) || []}
                        onChange={(selected) => setPrompt(JSON.stringify(selected))}
                      />
                    )
                  case 'dropdown':
                    return (
                      <SelectMenu
                        key={index}
                        label={item.label as string}
                        options={item.options as string[] || []}
                        selected={(item.value as string) || (item.options as string[])?.[0] || ''}
                        onChange={(value) => setPrompt(value)}
                      />
                    )
                  case 'audio':
                    return !audio ? (
                      <AudioDropzone
                        key={index}
                        title={`Drag 'n drop your audio here or click to upload`}
                        onAudioDrop={onAudioDrop}
                        onRecordAudio={handleRecordedAudio}
                        icon={VideoCameraIcon}
                      />
                    ) : (
                      <UploadedAudio
                        audio={audio}
                        audioUrl={base64Audio}
                        removeAudio={() => {
                          setAudio(null);
                          setBase64Audio(null);
                        }}
                        file={{
                          name: audio.name,
                          size: fileSize(audio.size)
                        }}
                      />
                    )
                  default:
                    return <div>no supported {item.key} type {component}</div>;
                }
              }
            })}
            {model.input.prompt && 
              <div className="w-80">
                <label className="block text-sm font-medium leading-6 text-gray-300">
                  Prompt,
                  <br/>
                  {slug === 'freshink' ? 
                    ("describe the tatto you want to create")
                      : slug === 'createVideo'
                        ? "describe the video you want to create"
                        : "describe the hair style"
                  }
                </label>
                <textarea
                  className="mt-2 w-full border bg-slate-800 text-sm text-gray-300 leading-6 text-left pl-3 py-1 rounded-md"
                  placeholder={
                    slug === 'freshink' ? 
                      ("A fresh ink TOK tattoo") 
                        : slug === 'createVideo' 
                          ? "bonfire, on the stone"
                          : "a face with a bowlcut"
                    }
                  onChange={(e) => setPrompt(e.target.value)}
                />
              </div>
            }
            {model.input.select && <SelectMenu
                label="Light Source"
                options={sources}
                selected={source}
                onChange={setSource}
              />
            }
            {
              Array.from({ length: model.input.image }).map((_, index) => (
                !files[index] ? (
                  <ImageDropzone 
                    key={index}
                    id={index}
                    title={`Drag 'n drop your image here or click to upload`}
                    onImageDrop={onImageDrop}
                    icon={slug === 'hairStyle' ? FaceSmileIcon : PhotoIcon}
                  />
                ) : (
                  <UploadedImage
                    key={index}
                    image={files[index]}
                    removeImage={() => removeImage(index)}
                    file={{ name: files[index].name, size: fileSize(files[index].size) }}
                  />
                )
              ))
            }

            {model.input.video && (
              !video ? (
                <VideoDropzone
                  title={`Drag 'n drop your video here or click to upload`}
                  onVideoDrop={onVideoDrop}
                  icon={VideoCameraIcon}
                />
              ) : (
                <UploadedVideo
                  video={video}
                  removeVideo={removeVideo}
                  file={{ name: video.name, size: fileSize(video.size) }}
                />
              )
            )}
          </section>
        </div>

        <div className="flex flex-col w-1/2">
          <h1 className="mx-auto">Output</h1>
          <section className="mx-4 mt-9 flex flex-col gap-4">
            {config && config.outputs && config.outputs.map((item: OutputItem, index: number) => {
              if (('show' in item) && item['show']) {
                if (item.type === 'array' && item.format === 'uri') {
                  // Check if outputImage is an array and has items
                  if (Array.isArray(outputImage) && outputImage.length > 0) {
                    return (
                      <div key={index} className="flex flex-col">
                        {outputImage.map((imgUri, imgIndex) => (
                          <ImageOutput
                            key={imgIndex}
                            title={item.title || 'Output'}
                            downloadOutputImage={downloadOutputImage}
                            outputImage={imgUri} // Use each URI for the ImageOutput
                            icon={SparklesIcon}
                            loading={loading}
                          />
                        ))}
                      </div>
                    );
                  } else {
                    // Show a placeholder or loading state before generation
                    return (
                      <ImageOutput
                        key={index}
                        title={item.title || 'Output'}
                        downloadOutputImage={downloadOutputImage}
                        outputImage={null} // Placeholder before generation
                        icon={SparklesIcon}
                        loading={loading}
                      />
                    );
                  }
                }

                switch (item.component.toLowerCase()) {
                  case 'image':
                    return <ImageOutput
                      key={index}
                      title={item.placeholder as string}
                      downloadOutputImage={downloadOutputImage}
                      outputImage={Array.isArray(outputImage) ? outputImage[0] : outputImage} // Ensure outputImage is a string or null
                      icon={SparklesIcon}
                      loading={loading}
                    />
                  case 'video':
                    return <video
                      key={index}
                      src={outputVideo as string}
                      width="520"
                      height="340"
                      controls
                      autoPlay
                      className="h-full w-full object-cover"
                    >
                      Your browser does not support the video tag.
                    </video>
                  case 'audio':
                    return (
                      <AudioOutput
                        key={index}
                        title={item.title || 'Audio Output'}
                        audioUrl={item.value as string || null}
                      />
                    )
                  case 'number':
                    return (
                      <NumberOutput
                        key={index}
                        title={item.title || 'Numeric Output'}
                        value={item.value || null}
                      />
                    )
                  case 'textbox':
                    return (
                      <TextOutput
                        key={index}
                        title={item.title}
                        placeholder={item.placeholder}
                        value={item.value}
                      />
                    )
                  default:
                    return <div>no supported {item.component} type</div>;
                }
              }
            })}

            {model.output.image && (
              <ImageOutput
                title={`AI-generated output goes here`}
                downloadOutputImage={downloadOutputImage}
                outputImage={Array.isArray(outputImage) ? outputImage[0] : outputImage} // Ensure outputImage is a string or null
                icon={SparklesIcon}
                loading={loading}
              />
            )}
            {model.output.video && (
              <video
                src={outputVideo as string}
                width="520"
                height="340"
                controls
                autoPlay
                className="h-full w-full object-cover"
              >
                Your browser does not support the video tag.
              </video>
            )}
          </section>
        </div>
      </div>
    </main>
  );
}


==== src/app/app/[slug]/page.tsx ====
import { Suspense } from 'react';
import { notFound } from 'next/navigation';
import ClientPage from './ClientPage';
import { Slug } from '@/types';
import {getConfigurations} from '@/common/configuration';


export default async function Page({ params }: { params: { slug: Slug } }) {
  const configurations = await getConfigurations();

  if (!configurations) {
    return notFound();
  }

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ClientPage slug={params.slug} initialConfigurations={configurations} />
    </Suspense>
  );
}

==== src/app/chat/[slug]/page.tsx ====
"use client"
import {PaperAirplaneIcon, XCircleIcon} from '@heroicons/react/24/outline';
import ReactMarkdown from 'react-markdown';

import { useEffect, useState } from "react"

type ErrorNotificationProps = {
  errorMessage: string;
};


function PageNotFound() {
  return (<div className="w-full h-screen text-white flex justify-center items-center">
    <div className="mx-auto ">
      404 Page not found
    </div>
  </div>)
}

function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

type Slug = "dates" | "trip" | "viral";
function isSlug(value: string): value is Slug {
  return value === "dates" || value === "trip" || value === "viral";
}
export default function Home({ params }: { params: { slug: Slug } }) {
  const [isValidSlug, setIsValidSlug] = useState<boolean>(false);
  const [question, setQuestion] = useState<string>("questions");
  const [answer, setAnswer] = useState<string>('');
  const [plan, setPlan] = useState("");
  const [start, setStart] = useState(false);
  const [sessionId, setSessionId] = useState<string>();
  const [error, setError] = useState<string | null>("");

  useEffect(() => {
    if (isSlug(params.slug)) setIsValidSlug(true);
    else setIsValidSlug(false);
  },[params.slug]);

  if (!isValidSlug) return <PageNotFound />;

  const BASE_URL_CHAT = process.env.BASE_URL_CHAT_AGENT_PY;
  if(!BASE_URL_CHAT) throw Error('not BASE_URL_CHAT ...');

  async function handleStart() {
    try {
      const res = await fetch(BASE_URL_CHAT + '/start_flow', {
        method: 'POST',
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({slug: params.slug}),
      });
  
      const { session_id, question} = await res.json();

      console.log({session_id});

      if(!session_id && !question) throw Error('no session_id, or question');

      setSessionId(session_id);
      setQuestion(question);
      setStart(true);
    } catch (error: any) {
      console.error(error.message);
      setError(`${error.message}`);
    }
  }

  async function handleAnswer() {
    if(!answer) {
      alert('please answer the question ...');
      return;
    }
    try {
      const params = {
        answer,
      }

      const response = await fetch(BASE_URL_CHAT+'/answer'+`/${sessionId}`,{
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(params),
      });
      
      const {next_question, trip_plan} = await response.json();

      console.log({next_question});

      if(next_question) {
        setAnswer('');
        setQuestion(next_question);
      } else if(trip_plan) {
        console.log({trip_plan});
        setPlan(trip_plan);
      } else {
        throw Error('no next_question or trip_plan');
      }
    } catch (error: any) {
      console.error(error.message);
    }
  }

  return (
    <div className="lg:pl-72 flex flex-col min-h-screen justify-center">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      {start && <div className="mx-auto flex flex-col gap-2">
        <label htmlFor="answer">{question}</label>
        <textarea name="anwer" id="answer" className="bg-inherit border"
          onChange={(e) => setAnswer(e.target.value)} 
          value={answer}
        />
        <button className="border flex flex-row justify-center gap-2 p-1 items-center hover:bg-blue-950"
          onClick={handleAnswer}
        >
          Send 
          <PaperAirplaneIcon className="h-5 w-5 shrink-0" />
        </button>
      </div>}
      {!start && 
        <div className='mx-auto'>
          <button 
          className="border flex flex-row min-w-[200px] justify-center gap-2 p-2 items-center hover:bg-blue-950"
          onClick={handleStart}
          >
            {params.slug}
            <PaperAirplaneIcon className="h-5 w-5 shrink-0" />
          </button>
        </div>
      }
      {plan && <div className='mx-auto p-6 border rounded '>
        <ReactMarkdown>{plan}</ReactMarkdown>
      </div>}
    </div>
  )
}

==== src/app/create/list/page.tsx ====
'use client';

import { useEffect, useState } from 'react';
import { Configurations } from '@/types'; // Adjust the import path as necessary
import {getConfigurations} from '@/common/configuration';
import { useRouter } from 'next/navigation';

const AppList = () => {
  const router = useRouter();
  const [apps, setApps] = useState<Configurations>([]);

  useEffect(() => {
    const fetchApps = async () => {
      try {
        // Combine fetched apps with configurationObj
        setApps(await getConfigurations());
      } catch (error) {
        console.error('Error fetching apps:', error);
      }
    };

    fetchApps();
  }, []);

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 p-6 bg-gray-900">
      {apps.map((app) => (
        <div 
          key={app.name} 
          className="bg-gray-800 shadow-lg rounded-lg p-6 hover:bg-gray-700 transition-colors cursor-pointer"
          onClick={() => router.push(`/app/${app.name}`)}
        >
          <h3 className="text-xl font-bold mb-4 text-blue-400">{app.name}</h3>
          <div className="space-y-2">
            <InfoItem label="Type" value={app.type ?? 'N/A'} />
            <InfoItem label="Client" value={app.client ?? 'N/A'} />
            <InfoItem label="Path" value={app.path ?? 'N/A'} />
            <InfoItem label="Endpoint" value={app.endpoint ?? 'N/A'} />
            <InfoItem label="Model" value={app.model ?? 'N/A'} />
            <InfoItem label="Version" value={app.version ?? 'N/A'} />
            <InfoItem label="Inputs" value={app.inputs.map(input => input.key).join(', ')} />
            <InfoItem label="Outputs" value={app.outputs ? app.outputs.map(output => output.key).join(', ') : 'N/A'} />
          </div>
        </div>
      ))}
    </div>
  );
};

const InfoItem = ({ label, value }: { label: string; value: string }) => (
  <p className="text-sm text-gray-300">
    <span className="font-semibold text-gray-100">{label}:</span> {value}
  </p>
);

export default AppList;

==== src/app/create/page.tsx ====
"use client";

import { useState, useRef, useEffect } from 'react';
import { InputItem, OutputItem, Configuration } from "@/types";
import { PlusCircle, X, ChevronDown, ArrowRight } from 'lucide-react';
import { useRouter } from 'next/navigation';
import { getConfigurations } from '@/common/configuration';
import AppPreview from '@/components/AppPreview';

interface GradioEndpoint {
  key: string;
  inputs: InputItem[];
  outputs: OutputItem[];
}

const JsonEditor = ({ value, onChange }: { value: string; onChange: (value: string) => void }) => {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const scrollPositionRef = useRef<number>(0);

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.scrollTop = scrollPositionRef.current;
    }
  }, [value]);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    onChange(e.target.value);
  };

  const handleScroll = () => {
    if (textareaRef.current) {
      scrollPositionRef.current = textareaRef.current.scrollTop;
    }
  };

  return (
    <textarea
      ref={textareaRef}
      value={value}
      onChange={handleChange}
      onScroll={handleScroll}
      className="w-full h-[60vh] px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none overflow-auto"
    />
  );
};

export default function CreateApp() {
  const router = useRouter();

  const [isRawDataStep, setIsRawDataStep] = useState(true);
  const [appType, setAppType] = useState<'gradio' | 'replicate'>('gradio');
  const [rawData, setRawData] = useState('');
  const [modelUrl, setModelUrl] = useState('');
  const [modelData, setModelData] = useState<any>(null);
  const [editMode, setEditMode] = useState<'form' | 'json' | 'preview'>('form');
  const [implementationStep, setImplementationStep] = useState<number>(1);
  const [jsonConfig, setJsonConfig] = useState('');
  const [appName, setAppName] = useState('');
  const [inputs, setInputs] = useState<InputItem[]>([]);
  const [outputs, setOutputs] = useState<OutputItem[]>([]);
  const [path, setPath] = useState('/predict');
  const [client, setClient] = useState('');
  const [modelInput, setModelInput] = useState('');
  const [model, setModel] = useState('');
  const [version, setVersion] = useState<string | null>(null);
  const [errorMessage, setErrorMessage] = useState('');
  const [modelDetails, setModelDetails] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [configurations, setConfigurations] = useState<any[]>([]);
  const [loadingMessage, setLoadingMessage] = useState<string | null>(null); // State for loading message
  const [successMessage, setSuccessMessage] = useState<string | null>(null); // State for success message
  const [endpoint, setEndpoint] = useState('');
  const [endpoints, setEndpoints] = useState<string[]>([]);
  const [gradioEndpoints, setGradioEndpoints] = useState<GradioEndpoint[] | undefined>(undefined);

  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const currentConfig = {
      name: appName,
      type: appType,
      ...(appType === 'gradio' ? { client, path, endpoint } : { model, version }),
      endpoint,
      inputs: inputs.map(input => ({
        type: input.type,
        key: input.key,
        show: input.show,
        placeholder: input.placeholder || "",
        gradioName: input.gradioName || "",
        label: input.label || "",
        description: input.description || "",
        component: input.component || "",
        value: input.value !== undefined ? input.value : null
      })),
      outputs: outputs.map(output => ({
        type: output.type,
        key: output.key,
        show: output.show,
        placeholder: output.placeholder || ""
      }))
    };
    setJsonConfig(JSON.stringify(currentConfig, null, 2));
  }, [appName, appType, client, path, model, version, inputs, outputs, endpoint]);

  useEffect(() => {
    if (configurations.length > 0) {
      const initialInputs = configurations[0].inputs.map((input: InputItem) => ({
        ...input,
        type: input.type === 'string' ? 'string' : 'array' // Adjusted to only check for 'string' and 'array'
      }));
      setInputs(initialInputs);
    }
  }, [configurations]);

  useEffect(() => {
    if (gradioEndpoints) {
      const gradioEndpoint = gradioEndpoints.find((item) => item.key === endpoint);
      console.log({gradioEndpoint});
      if (gradioEndpoint) {
        const { inputs, outputs, key } = gradioEndpoint;
        console.log({key, inputs, outputs});
        setInputs(inputs || []);
        setOutputs(outputs || []);
      }
    }
  }, [endpoint]);

  const handleInputChange = (index: number, field: keyof InputItem, value: any) => {
    setInputs(prevInputs => {
      const updatedInputs = [...prevInputs];
      updatedInputs[index] = { ...updatedInputs[index], [field]: value };
      return updatedInputs;
    });
  };

  const handleOutputChange = (index: number, field: keyof OutputItem, value: any) => {
    setOutputs(prevOutputs => {
      const updatedOutputs = [...prevOutputs];
      updatedOutputs[index] = { ...updatedOutputs[index], [field]: value };
      updateJsonConfig(inputs, updatedOutputs);
      return updatedOutputs;
    });
  };

  const addInput = () => {
    setInputs([...inputs, { component: 'prompt', type: 'string', key: '', show: false }]);
  };

  const addOutput = () => {
    setOutputs([...outputs, { component: 'image', type: 'string', key: '', show: true }]);
  };

  const updateInput = (index: number, field: keyof InputItem, value: any) => {
    const newInputs = [...inputs];
    newInputs[index] = { ...newInputs[index], [field]: value };
    setInputs(newInputs);
  };

  const updateOutput = (index: number, field: keyof OutputItem, value: any) => {
    const newOutputs = [...outputs];
    newOutputs[index] = { ...newOutputs[index], [field]: value };
    setOutputs(newOutputs);
  };

  const removeInput = (index: number) => {
    const newInputs = inputs.filter((_, i) => i !== index);
    setInputs(newInputs);
  };

  const removeOutput = (index: number) => {
    const newOutputs = outputs.filter((_, i) => i !== index);
    setOutputs(newOutputs);
  };

  const isFormValid = () => {
    const isInputsValid = inputs.length > 0 && inputs.every(input => input.key.trim() !== '');
    const isOutputsValid = outputs.length > 0;
    return isInputsValid && isOutputsValid && appName.trim() !== '';
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isFormValid()) {
      alert('Please fill all required fields and add at least one input and one output.');
      return;
    }

    const newApp: Configuration = {
      name: appName,
      type: appType,
      inputs,
      outputs,
    };

    if (appType === 'gradio') {
      newApp.client = client;
      newApp.path = path;
      newApp.endpoint = endpoint;
    } else {
      newApp.model = model as `${string}/${string}`;
      newApp.version = version;
    }

    // Use SSE if enabled and Gradio app
    if (process.env.USE_SSE_EXPERIMENTAL === 'true' && appType === 'gradio') {
      try {
        const eventSource = new EventSource(`/api/experimental/sse/predict?client=${client}&endpoint=${endpoint}`);
        
        eventSource.onmessage = (event) => {
          const result = JSON.parse(event.data);
          // Update preview with result
          setOutputs(prev => prev.map((out, i) => ({
            ...out,
            value: result[i] || out.value
          })));
        };

        eventSource.onerror = () => {
          alert('SSE connection failed - falling back to regular API');
          eventSource.close();
          submitRegular(newApp);
        };

        return;
      } catch (error) {
        console.error('SSE failed, falling back:', error);
      }
    }

    submitRegular(newApp);
  };

  const submitRegular = async (newApp: Configuration) => {
    try {
      const response = await fetch('/api/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(newApp),
      });

      if (response.ok) {
        alert('App created successfully!');
        router.push(`/app/${appName}`);
      } else {
        alert('Failed to create app');
      }
    } catch (error) {
      console.error('Error creating app:', error);
      alert('An error occurred while creating the app');
    }
  };

  const handleRawDataChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setRawData(e.target.value);
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
    }
  };
  
  const handleParseRawData = () => {
    console.log({rawData});
    
    setErrorMessage('');

    const isReplicate = /\breplicate\.run\(/.test(rawData);
    if (!isReplicate) {
      setErrorMessage('Invalid format for Replicate raw data. Please check your input.');
      return;
    }
    
    console.log({isReplicate});
    
    if (isReplicate) {
      const step2Regex = /"([^:]+\/[^:]+):([^"]+)"/;
      const modelMatch = rawData.match(step2Regex);
      console.log("Step 2:", modelMatch ? modelMatch.slice(1) : "No match");

      if (modelMatch) {
        const model = modelMatch[1];
        const version = modelMatch[2];
        
        const step3Regex = /input:\s*({[\s\S]*?})\s*}/;
        const inputMatch = rawData.match(step3Regex);
        console.log("Step 3:", inputMatch ? "Input object found" : "No input object");
        
        if (inputMatch) {
          console.log("Input Match:", inputMatch[1]);

          const inputString = inputMatch[1];

          const configuration: Configuration = {
            name: model,
            type: 'replicate',
            model: model as `${string}/${string}`,
            version: version,
            inputs: Object.entries(eval(`(${inputString})`)).map(([key, value]: [string, any]) => ({
              type: Array.isArray(value) ? 'array' : typeof value === 'boolean' ? 'boolean' : typeof value === 'number' && Number.isInteger(value) ? 'integer' : 'string',
              key,
              value: value as any, // Explicitly cast value to any
              show: false,
              required: value.required || false,
              component: value.component || 'prompt'
            }))
          };

          console.log("Configuration:", JSON.stringify(configuration, null, 2));

          setAppName(configuration.name);
          setAppType(configuration.type);
          setModel(configuration.model as string);
          setVersion(configuration.version || null);
          setInputs(configuration.inputs);
          setIsRawDataStep(false);
        } else {
          console.error("Error: No input object found in raw data. Please check the format.");
        }
      }
    } else {
      console.log("Type not identified as replicate");
    }
  };

  const handleJsonChange = (newValue: string) => {
    setJsonConfig(newValue);
    try {
      const parsedConfig = JSON.parse(newValue);
      setAppName(parsedConfig.name);
      setAppType(parsedConfig.type);
      if (parsedConfig.type === 'gradio') {
        setClient(parsedConfig.client);
        setPath(parsedConfig.path);
        setEndpoint(parsedConfig.endpoint);
      } else {
        setModel(parsedConfig.model);
        setVersion(parsedConfig.version);
      }
      setInputs(parsedConfig.inputs.map((input: any) => ({
        type: input.type,
        key: input.key,
        show: input.show,
        placeholder: input.placeholder || "",
        gradioName: input.gradioName || "",
        label: input.label || "",
        description: input.description || "",
        component: input.component || "",
        value: input.value !== undefined ? input.value : null
      })));
      setOutputs(parsedConfig.outputs.map((output: any) => ({
        type: output.type,
        key: output.key,
        show: output.show,
        placeholder: output.placeholder || ""
      })));
    } catch (error) {
      console.error('Invalid JSON:', error);
    }
  };

  const handleFetchModel = async () => {
    try {
      const response = await fetch(modelUrl);
      if (!response.ok) {
        throw new Error('Failed to fetch model data');
      }
      const data = await response.json();
      setModelData(data);
    } catch (error) {
      console.error('Error fetching model:', error);
      alert('Error fetching model data. Please check the URL and try again.');
    }
  };

  const handleModelInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setModelInput(e.target.value);
    const [modelPart, versionPart] = e.target.value.split(':');
    setModel(modelPart.trim());
    setVersion(versionPart ? versionPart.trim() : null);
  };

  interface PropertyValue {
    type: 'string' | 'array' | 'integer' | 'boolean';
    default?: string | number | boolean;
    description?: string;
    title?: string;
    required?: boolean;
    items?: {
      type?: string;
      format?: string;
    };
    format?: string; // Add this line
    component?: 'image' | 'prompt' | 'checkbox' | 'number' | 'video';
  }

  const handleFetchModelDetails = async (type: 'replicate' | 'gradio') => {
    try {
      setIsLoading(true);
      setLoadingMessage(`Fetching ${type === 'gradio' ? 'Gradio space' : 'Replicate model'} details...`);

      const response = await fetch('/api/create/fetch-model-details', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ type, client, model, version }), // Send model and version in the request body
      });

      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      
      const data = await response.json();

      console.log('Fetched data:', data);

      // Populate inputs based on the schema
      const { formattedEndpoints, view_api }: { formattedEndpoints: GradioEndpoint[], api_info: any, view_api: boolean } = data;
      
      console.log({formattedEndpoints});

      if (view_api) {
        console.log('API view is available');
        alert('API view is available');
      } else {
        console.log('API view is NOT available');
        alert('API view is NOT available');

      }

      // I: I have the enpoints on formattedEndpoints
      // 2 I should have a select on endpoint, and be able to select the endpoint
      //    When changes the endpoint should appear the Inputs and Outputs,

      // I have to change the logic, when 

      // O: can be able to select the endpoint when is gradio.

      // It should happens depends on the endpoint, for example have one as default.
      // So here I should just I mean, update the endpoint, and for that endpoint,
      //  update the respective inputs and outputs,
      // So I can select the formattedParams to zero, and so on, and get the inputs, and otputs for that.
      // And, yeah, maybe review the useEffect, when something change here,

      let inputItems: InputItem[] = [];
      let outputItems: OutputItem[] = [];


      if (type === 'gradio') {
        console.log({type})

        const endpoints = formattedEndpoints.map((item: any) => item.key);
        const defaultEndpoint = endpoints[0]; // Default to first endpoint

        // Set Gradio endpoints and default endpoint
        setEndpoints(endpoints);
        setEndpoint(defaultEndpoint);
        setGradioEndpoints(formattedEndpoints);
        
        // Find the default endpoint data
        const defaultGradioEndpoint = formattedEndpoints.find((item) => item.key === defaultEndpoint);
        if (defaultGradioEndpoint) {
          inputItems = defaultGradioEndpoint.inputs || [];
          outputItems = defaultGradioEndpoint.outputs || [];

          // Immediately set inputs and outputs
          setInputs(inputItems);
          setOutputs(outputItems);

          // Sync JSON config with default endpoint data
          updateJsonConfig(inputItems, outputItems);
        }

        setIsRawDataStep(false); 
      } else if (type === 'replicate') {
        // Process inputs
        inputItems = Object.entries(inputs).map(([key, value]) => {
          const typedValue = value as PropertyValue;
          return {
            component: typedValue.component || 'prompt',
            key,
            type: typedValue.type,
            value: (typedValue.default !== undefined ? typedValue.default : null) as string | number | boolean | undefined,
            show: false,
            placeholder: typedValue.description || '',
            label: typedValue.title || '',
            required: false,
          };
        });
      
        // Process outputs
        const processOutput = (key: string, value: PropertyValue): OutputItem => {
          let outputItem: OutputItem = {
            component: value.component || 'image',
            key,
            type: value.type as 'string' | 'number' | 'boolean' | 'array',
            show: true,
            title: value.title || key,
            placeholder: value.description || '',
          };
        
          if (value.type === 'array' && value.items) {
            outputItem.typeItem = value.items.type as 'string' | 'number' | 'boolean';
            if (value.items.format) {
              outputItem.formatItem = value.items.format;
            }
          } else if (value.type === 'string' && value.format) {
            outputItem.format = value.format;
          }
        
          return outputItem;
        };

        outputItems = Object.entries(outputs).map(([key, value]) => processOutput(key, value as PropertyValue));
      }
        

      // Sort inputs to have required fields at the top
      // const sortedInputs = [
      //   ...inputItems.filter((input: InputItem) => input.required),
      //   ...inputItems.filter((input: InputItem) => !input.required),
      // ];

      const validInputs = inputItems.filter((item): item is InputItem => item !== undefined);
      const validOutputs = outputItems.filter((item): item is OutputItem => item !== undefined);
      setInputs(validInputs);
      setOutputs(validOutputs);
      updateJsonConfig(validInputs, validOutputs);
      setIsRawDataStep(false);
    } catch (error: any) {
      console.error('Error fetching model details:', error.message);
      alert('Error fetching model data. Please check the URL and try again.');
    } finally {
      // Always reset loading states regardless of success/failure
      setIsLoading(false);
      setLoadingMessage(null);
    }
  };

  const fetchConfigurations = async () => {
    setIsLoading(true);
    try {
      const timestamp = Date.now();
      const configurations = await getConfigurations(true);
      // Handle configurations as needed
    } catch (error) {
      console.error('Error fetching configurations:', error);
      alert('Failed to fetch configurations.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleBack = () => {
    setIsRawDataStep(true);
    fetchConfigurations();
  };

  // Component to render inputs dynamically
  const renderInput = (input: InputItem) => {
    switch (input.type) {
      case 'string':
        return <input type="text" value={input.value || ''} placeholder={input.placeholder} />;
      case 'array':
        return (
          <select multiple>
            {/* Populate options based on your needs */}
            <option value="uri">URI</option>
            {/* Add more options as needed */}
          </select>
        );
      default:
        return null;
    }
  };

  const updateJsonConfig = (inputs: InputItem[], outputs: OutputItem[]) => {
    const config: Configuration = {
      name: appName,
      type: appType,
      inputs,
      outputs: outputs.map(output => {
        // Include all properties, including formatItem if it exists
        const outputItem: OutputItem = {
          key: output.key,
          type: output.type,
          show: output.show,
          title: output.title,
          placeholder: output.placeholder,
          component: output.component || 'image'
        };
        if (output.format) outputItem.format = output.format;
        if (output.typeItem) outputItem.typeItem = output.typeItem;
        if (output.formatItem) outputItem.formatItem = output.formatItem;
        return outputItem;
      })
    };

    if (appType === 'replicate') {
      config.model = model as `${string}/${string}`;
      config.version = version;
    } else if (appType === 'gradio') {
      config.client = client;
      config.path = path;
      config.endpoint = endpoint;
    }

    setJsonConfig(JSON.stringify(config, null, 2));
  };

  const handleAppNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setAppName(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handleAppTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setAppType(e.target.value as 'gradio' | 'replicate');
    updateJsonConfig(inputs, outputs);
  };

  const handleModelChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setModel(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handleVersionChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setVersion(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handleClientChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setClient(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handlePathChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setPath(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handleEndpointChange = (e: React.ChangeEvent<HTMLInputElement> | React.ChangeEvent<HTMLSelectElement>) => {
    setEndpoint(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  return (
    <div className="max-w-4xl mx-auto p-4 sm:p-6 space-y-4 sm:space-y-6 bg-gray-800 rounded-lg shadow-lg mt-8 sm:mt-16">
      {isRawDataStep ? (
        <>
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-lg font-semibold text-gray-200">Enter Model Details</h2>
            <button
              type="button"
              onClick={() => setIsRawDataStep(false)}
              className="flex items-center bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600"
            >
              <ArrowRight size={20} />
              <span className="ml-1">Skip Step</span>
            </button>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-300 mb-1">App Type:</label>
            <select
              value={appType}
              onChange={(e) => setAppType(e.target.value as 'gradio' | 'replicate')}
              className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="replicate">Replicate</option>
              <option value="gradio">Gradio</option>
            </select>
          </div>

          {appType === 'replicate' && (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-300 mb-1">Model:Version</label>
                <input
                  type="text"
                  value={modelInput}
                  onChange={handleModelInputChange}
                  placeholder="owner/model_name:version"
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <button
                type="button"
                onClick={() => handleFetchModelDetails('replicate')}
                disabled={isLoading || !model}
                className="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-400"
              >
                {isLoading ? (
                  <span className="flex items-center justify-center">
                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Fetching...
                  </span>
                ) : 'Fetch Model Details'}
              </button>
            </div>
          )}

          {appType === 'gradio' && (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-300 mb-1">Client:</label>
                <input
                  type="text"
                  value={client}
                  onChange={(e) => setClient(e.target.value)}
                  placeholder="Enter the gradio client"
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <button
                type="button"
                onClick={() => handleFetchModelDetails('gradio')}
                disabled={isLoading || !client}
                className="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-400"
              >
                {isLoading ? (
                  <span className="flex items-center justify-center">
                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Fetching...
                  </span>
                ) : 'Fetch Model Details'}
              </button>
              {/* <div>
                <label className="block text-sm font-medium text-gray-300 mb-1">Raw Data (Optional):</label>
                <textarea
                  ref={textareaRef}
                  value={rawData}
                  onChange={handleRawDataChange}
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500 h-[20vh]"
                  placeholder='Paste raw data here (optional)...'
                />
              </div> */}
            </div>
          )}

          {/* {appType === 'gradio' && (
            <button
              type="button"
              onClick={handleParseRawData}
              className="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600"
            >
              Parse Raw Data
            </button>
          )} */}
        </>
      ) : (
        <> {/* Add fragment to wrap form and preview */}
          <form onSubmit={handleSubmit}>
            <div className="flex justify-between items-center mb-4">
              <div className="flex space-x-4">
                <button
                type="button" 
                onClick={() => setEditMode('form')} 
                className={`px-4 py-2 rounded-md ${editMode === 'form' ? 'bg-blue-500 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                Form
              </button>
              <button 
                type="button" 
                onClick={() => setEditMode('json')} 
                className={`px-4 py-2 rounded-md ${editMode === 'json' ? 'bg-blue-500 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                JSON
              </button>
              <button 
                type="button" 
                onClick={() => {
                  setEditMode('preview');
                  setImplementationStep(2);
                }} 
                className={`px-4 py-2 rounded-md ${editMode === 'preview' ? 'bg-blue-500 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                Preview
              </button>
            </div>
              <button
                type="submit"
                className="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600"
              >
                Create App
              </button>
            </div>

            {/* Keep form and json modes inside the form */}
            {editMode === 'form' ? (
            <>
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-300 mb-1">App Name:</label>
                  <input
                    type="text"
                    value={appName}
                    onChange={handleAppNameChange}
                    className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-300 mb-1">App Type:</label>
                  <select
                    value={appType}
                    onChange={handleAppTypeChange}
                    className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="gradio">Gradio</option>
                    <option value="replicate">Replicate</option>
                  </select>
                </div>
              </div>

              {appType === 'gradio' ? (
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Client:</label>
                    <input
                      type="text"
                      value={client}
                      onChange={handleClientChange}
                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Path:</label>
                    <input
                      type="text"
                      value={path}
                      onChange={handlePathChange}
                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Endpoint:</label>
                    {endpoints ? (
                      <select
                      value={endpoint}
                      onChange={handleEndpointChange}
                      className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                      >
                        {endpoints && endpoints.map((item: string) => 
                          (<option key={item} value={item}>{item}</option>)
                        )}
                      </select>
                    ) : (
                      <input
                        type="text"
                        value={endpoint}
                        onChange={handleEndpointChange}
                        className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                      />
                    )}
                  </div>
                </div>
              ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Model:</label>
                    <input
                      type="text"
                      value={model}
                      onChange={handleModelChange}
                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Version:</label>
                    <input
                      type="text"
                      value={version || ''}
                      onChange={handleVersionChange}
                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                  </div>
                  {appType === 'replicate' && (
                    <div className="mt-4">
                      <button
                        type="button"
                        onClick={() => handleFetchModelDetails('replicate')}
                        className="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                      >
                        Re-fetch Model Details
                      </button>
                    </div>
                  )}
                </div>
              )}

              {/* Show loading message with more visibility */}
              {loadingMessage && (
                <div className="my-4 p-3 bg-blue-900/30 border border-blue-500 rounded-md text-blue-200 flex items-center">
                  <svg className="animate-spin h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  {loadingMessage}
                </div>
              )}

              {/* Hide inputs and outputs while loading */}
              {isLoading ? (
                <div className="text-gray-300">Loading...</div>
              ) : (
                <>
                  <div>
                    <h3 className="text-lg font-semibold text-gray-200 mb-2">Inputs:</h3>
                    {inputs.map((input, index) => (
                      <div key={index} className="mb-4 p-4 bg-gray-700 rounded-md">
                        <div className="grid grid-cols-2 gap-4">
                          <input
                            type="text"
                            value={input.key}
                            onChange={(e) => handleInputChange(index, 'key', e.target.value)}
                            placeholder="Key"
                            className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          />
                            <select
                              value={input.component}
                              onChange={(e) => handleInputChange(index, 'component', e.target.value as InputItem['component'])}
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            >
                              <option value="prompt">Prompt</option>
                              <option value="image">Image</option>
                              <option value="audio">Audio</option>
                              <option value="checkbox">Checkbox</option>
                              <option value="number">Number</option>
                              <option value="video">Video</option>
                            </select>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mt-2">
                          <input
                            type="text"
                            value={input.value || ''}
                            onChange={(e) => handleInputChange(index, 'value', e.target.value)}
                            placeholder="Value"
                            className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          />
                          <div className="flex items-center justify-between">
                            <label className="flex items-center space-x-2 text-gray-300">
                              <input
                                type="checkbox"
                                checked={input.show}
                                onChange={(e) => handleInputChange(index, 'show', e.target.checked)}
                                className="form-checkbox h-5 w-5 text-blue-500"
                              />
                              <span>Show</span>
                            </label>
                            <button
                              type="button"
                              onClick={() => removeInput(index)}
                              className="p-2 bg-red-500 text-white rounded-md hover:bg-red-600"
                            >
                              <X size={20} />
                            </button>
                          </div>
                        </div>
                        {input.show && (
                          <div className="grid grid-cols-2 gap-4 mt-4">
                            <input
                              type="text"
                              value={input.placeholder || ''}
                              onChange={(e) => handleInputChange(index, 'placeholder', e.target.value)}
                              placeholder="Placeholder"
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            />
                            <input
                              type="text"
                              value={input.label || ''}
                              onChange={(e) => handleInputChange(index, 'label', e.target.value)}
                              placeholder="Label"
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            />
                            <select
                              value={input.type}
                              onChange={(e) => handleInputChange(index, 'type', e.target.value as InputItem['type'])}
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            >
                              <option value="string">String</option>
                              <option value="array">Array</option>
                              <option value="number">Number</option>
                              <option value="boolean">Boolean</option>
                            </select>
                          </div>
                        )}
                      </div>
                    ))}
                    <button 
                      type="button" 
                      onClick={addInput} 
                      className="w-full mt-2 px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-600 flex items-center justify-center"
                    >
                      <PlusCircle size={20} className="mr-2" />
                      Add Input
                    </button>
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold text-gray-200 mb-2">Outputs:</h3>
                    {outputs.map((output, index) => (
                      <div key={index} className="mb-4 p-4 bg-gray-700 rounded-md">
                        <div className="grid grid-cols-2 gap-4">
                          <input
                            type="text"
                            value={output.title}
                            onChange={(e) => handleOutputChange(index, 'title', e.target.value)}
                            placeholder="Title"
                            className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          />
                          <select
                            value={output.component}
                            onChange={(e) => handleOutputChange(index, 'component', e.target.value as OutputItem['component'])}
                            className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          >
                            <option value="image">Image</option>
                            <option value="prompt">Prompt</option>
                            <option value="checkbox">Checkbox</option>
                            <option value="number">Number</option>
                            <option value="video">Video</option>
                          </select>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mt-2">
                          <input
                            type="text"
                            value={output.placeholder || ''}
                            onChange={(e) => handleOutputChange(index, 'placeholder', e.target.value)}
                            placeholder="Placeholder"
                            className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          />
                          <div className="flex items-center justify-between">
                            <label className="flex items-center space-x-2 text-gray-300">
                              <input
                                type="checkbox"
                                checked={output.show}
                                onChange={(e) => handleOutputChange(index, 'show', e.target.checked)}
                                className="form-checkbox h-5 w-5 text-blue-500"
                              />
                              <span>Show</span>
                            </label>
                            <button
                              type="button"
                              onClick={() => removeOutput(index)}
                              className="p-2 bg-red-500 text-white rounded-md hover:bg-red-600"
                            >
                              <X size={20} />
                            </button>
                          </div>
                        </div>
                        {output.show && (
                          <div className="mt-4 grid grid-cols-2 gap-4">
                            <input
                              type="text"
                              value={output.key}
                              onChange={(e) => handleOutputChange(index, 'key', e.target.value)}
                              placeholder="Key"
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            />
                            <select
                              value={output.type}
                              onChange={(e) => handleOutputChange(index, 'type', e.target.value as OutputItem['type'])}
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            >
                              <option value="string">String</option>
                              <option value="number">Number</option>
                              <option value="boolean">Boolean</option>
                              <option value="array">Array</option>
                            </select>
                            {output.type === 'array' && (
                              <>
                                <select
                                  value={output.typeItem || ''}
                                  onChange={(e) => handleOutputChange(index, 'typeItem', e.target.value as OutputItem['typeItem'])}
                                  className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                                >
                                  <option value="">Select Item Type</option>
                                  <option value="string">String</option>
                                  <option value="number">Number</option>
                                  <option value="boolean">Boolean</option>
                                </select>
                                <input
                                  type="text"
                                  value={output.formatItem || ''}
                                  onChange={(e) => handleOutputChange(index, 'formatItem', e.target.value)}
                                  placeholder="Format Item"
                                  className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                                />
                              </>
                            )}
                            {output.type === 'string' && (
                              <input
                                type="text"
                                value={output.format || ''}
                                onChange={(e) => handleOutputChange(index, 'format', e.target.value)}
                                placeholder="Format"
                                className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                              />
                            )}
                          </div>
                        )}
                      </div>
                    ))}
                    <button 
                      type="button" 
                      onClick={addOutput} 
                      className="w-full mt-2 px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-600 flex items-center justify-center"
                    >
                      <PlusCircle size={20} className="mr-2" />
                      Add Output
                    </button>
                  </div>
                  {successMessage && <div className="text-green-300">{successMessage}</div>}
                </>
              )}
            </>
            ) : editMode === 'json' ? (
              <JsonEditor value={jsonConfig} onChange={handleJsonChange} />
            ) : null}
          </form>

          {/* Render AppPreview outside the form when in preview mode */}
          {editMode === 'preview' && (
            <AppPreview
              config={{
                name: appName,
                type: appType,
                ...(appType === 'gradio' ?
                  { client, path, endpoint, endpoints } :
                  { model: `${model.split('/')[0]}/${model.split('/')[1]}`, version }
                ),
                inputs,
                outputs
              }}
              onEndpointChange={(newEndpoint) => {
                setEndpoint(newEndpoint);
                if (gradioEndpoints) {
                  const newGradioEndpoint = gradioEndpoints.find((item) => item.key === newEndpoint);
                  if (newGradioEndpoint) {
                    const { inputs: newInputs, outputs: newOutputs } = newGradioEndpoint;
                    setInputs(newInputs || []);
                    setOutputs(newOutputs || []);
                  }
                }
              }}
              onAppNameChange={setAppName}
            />
          )}
        </> // Close fragment
      )}

      {modelData && (
        <div className="mt-4 p-4 bg-gray-700 rounded-md">
          <h3 className="text-lg font-semibold text-gray-200">Model Data:</h3>
          <pre className="text-gray-300">{JSON.stringify(modelData, null, 2)}</pre>
        </div>
      )}
    </div>
  );
}


==== src/app/desktop-sidebar.tsx ====
import { usePathname } from "next/navigation";
import { navigation } from "@/common";
import { classNames } from "@/utils";
import Link from "next/link";

export function DesktopSidebar() {
  const pathName = usePathname();

  return (
    <aside className="hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col">
      {/* Sidebar component, swap this element with another sidebar if you like */}
      <div className="flex grow flex-col gap-y-5 overflow-y-auto bg-gray-900 px-6">
        <div className="flex h-16 shrink-0 items-center">
          <h1 className="bg-gradient-to-r from-blue-600 via-green-500 to-indigo-400 bg-clip-text text-xl font-semibold text-transparent">
            J4 Tools
          </h1>
        </div>

        <nav className="flex flex-1 flex-col">
          <ul role="list" className="flex flex-1 flex-col gap-y-7">
            <li>
              <ul role="list" className="-mx-2 space-y-1">
                {navigation.map((item) => (
                  <li key={item.name}>
                    <Link
                      href={item.href}
                      className={classNames(
                        pathName === item.href
                          ? "bg-gray-800 text-white"
                          : "text-gray-400 hover:bg-gray-800 hover:text-white",
                        "group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6 transition-all duration-300"
                      )}
                    >
                      <item.icon
                        className="h-6 w-6 shrink-0"
                        aria-hidden="true"
                      />
                      {item.name}
                    </Link>
                  </li>
                ))}
              </ul>
            </li>
          </ul>
        </nav>
      </div>
    </aside>
  );
}


==== src/app/enhancebg/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu"
import { ImageAreaProps } from "@/types";
import { Field, Input, Label, Description, } from "@headlessui/react";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const themes = ["Modern", "Vintage", "Minimalist", "Professional"];
const rooms = ["Living Room", "Dining Room", "Bedroom", "Bathroom", "Office"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a product and let our AI generate a new background.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [prompt, setPrompt] = useState<string | null>(null);
  const [theme, setTheme] = useState<string>(themes[0]);
  const [room, setRoom] = useState<string>(rooms[0]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file || !prompt) {
      setError("Please upload an image & fill the prompt");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/inter-design", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image, prompt }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    // Output returns an array of two images
    // Here we show the second image
    setOutputImage(result.output[0]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      {/* <section className="mx-4 mt-9 flex w-fit flex-col space-y-8 lg:mx-6 lg:flex-row lg:space-x-8 lg:space-y-0 xl:mx-8"> */}
        {/* <Input name="full_name" type="text" /> */}
        {/* <SelectMenu
          label="Model"
          options={themes}
          selected={theme}
          onChange={setTheme}
        />
        <SelectMenu
          label="Room type"
          options={rooms}
          selected={room}
          onChange={setRoom}
        /> */}
      {/* </section> */}
      <Field className="flex flex-col px-4 gap-1 lg:px-6 xl:gap-1 xl:px-8">
        <Label className="text-sm/6 font-medium text-white">Prompt</Label>
        <Description className="text-sm/6 text-white/50">Describe what is the background you want the image change for.</Description>
        <Input 
        className="border bg-slate-500 rounded-lg w-full"
        name="prompt"
        onChange={(e)=> setPrompt(e.target.value)}
        />
      </Field>

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/favicon.ico ====
(Skipped binary or unreadable file)

==== src/app/globals.css ====
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 255, 255, 255;
  --background-start-rgb: 0, 0, 0;
  --background-end-rgb: 0, 0, 0;
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

==== src/app/header.tsx ====
import { usePathname } from "next/navigation";
import { Bars3Icon } from "@heroicons/react/24/outline";

type HeaderProps = {
  onClick(): void;
};

export function Header({ onClick }: HeaderProps) {
  const pathName = usePathname();
  console.log(pathName);

  return (
    <header className="sticky top-0 z-40 flex items-center gap-x-6 px-4 py-4 shadow-sm sm:px-6 lg:hidden">
      <button
        type="button"
        className="-m-2.5 p-2.5 text-gray-400 lg:hidden"
        onClick={onClick}
      >
        <span className="sr-only">Open sidebar</span>
        <Bars3Icon className="h-6 w-6" aria-hidden="true" />
      </button>
      <div className="flex-1 text-sm font-semibold leading-6 text-white">
        {pathName === "/" ? "Home" : "History"}
      </div>
    </header>
  );
}


==== src/app/illuminai/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu";
import { ImageAreaProps } from "@/types";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const sources = ["None", "Left Light", "Right Light", "Bottom Light", "Top Light"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a room and let our AI generate a new design.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [source, setSource] = useState<string>(sources[0]);
  const [prompt, setPrompt] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file) {
      setError("Please upload an image.");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/illuminai", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image, source, prompt }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    setOutputImage(result.output[0]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      <section className="mx-4 mt-9 flex w-fit flex-col space-y-8 lg:mx-6 lg:flex-row lg:space-x-8 lg:space-y-0 xl:mx-8">
        <div className="w-80">
          <label className="block text-sm font-medium leading-6 text-gray-300">
            Prompt
          </label>
          <textarea
          className="mt-2 w-full border bg-slate-800 text-sm text-gray-300 leading-6 text-left pl-3 py-1 rounded-md"
          // type="text"
          onChange={(e) => setPrompt(e.target.value)}
          />
        </div>
        <SelectMenu
          label="Light Source"
          options={sources}
          selected={source}
          onChange={setSource}
        />
        {/* <SelectMenu
          label="Room type"
          options={rooms}
          selected={room}
          onChange={setRoom}
        /> */}
      </section>

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/layout.tsx ====
import './globals.css';
import { Analytics } from '@vercel/analytics/react';
import { Inter } from 'next/font/google';
import { Sidebar } from './sidebar';
import ClientSidebarWrapper from './ClientSidebarWrapper';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
  title: 'Interior Designer AI',
  description: 'Upload a sample room photo and get a design back in seconds.',
  robots: 'index, follow',
  openGraph: {
    title: 'Interior Designer AI',
    description: 'Upload a sample room photo and get a design back in seconds.',
    url: 'https://interior-designer-ai.vercel.app/',
    locale: 'en_US',
    type: 'website',
    images: [
      {
        url: 'https://interior-designer-ai.vercel.app/app-screenshot.png',
        width: 1200,
        height: 630,
        alt: 'Screenshot of the Interior Designer AI app',
      },
    ],
  },
};

type RootLayoutProps = {
  children: React.ReactNode;
};

export default function RootLayout({ children }: RootLayoutProps) {
  return (
    <html lang='en'>
      <body className={`${inter.className}`}>
        <ClientSidebarWrapper>
          <Sidebar />
        </ClientSidebarWrapper>
        <main>
          {children}
        </main>
        <Analytics />
      </body>
    </html>
  );
}

==== src/app/mobile-sidebar.tsx ====
import { Fragment } from "react";
import { usePathname } from "next/navigation";
import { XMarkIcon } from "@heroicons/react/24/outline";
import { Transition } from "@headlessui/react";
import { Dialog } from "@headlessui/react";
import { navigation } from "@/common";
import { classNames } from "@/utils";

type SidebarProps = {
  sidebarOpen: boolean;
  setSidebarOpen(open: boolean): void;
};

export function MobileSidebar({ sidebarOpen, setSidebarOpen }: SidebarProps) {
  const pathName = usePathname();

  return (
    <Transition.Root show={sidebarOpen} as={Fragment}>
      <Dialog
        as="div"
        className="relative z-50 lg:hidden"
        onClose={setSidebarOpen}
      >
        <Transition.Child
          as={Fragment}
          enter="transition-opacity ease-linear duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="transition-opacity ease-linear duration-300"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-gray-900/80" />
        </Transition.Child>

        <div className="fixed inset-0 flex">
          <Transition.Child
            as={Fragment}
            enter="transition ease-in-out duration-300 transform"
            enterFrom="-translate-x-full"
            enterTo="translate-x-0"
            leave="transition ease-in-out duration-300 transform"
            leaveFrom="translate-x-0"
            leaveTo="-translate-x-full"
          >
            <Dialog.Panel className="relative mr-16 flex w-full max-w-xs flex-1">
              <Transition.Child
                as={Fragment}
                enter="ease-in-out duration-300"
                enterFrom="opacity-0"
                enterTo="opacity-100"
                leave="ease-in-out duration-300"
                leaveFrom="opacity-100"
                leaveTo="opacity-0"
              >
                <div className="absolute left-full top-0 flex w-16 justify-center pt-5">
                  <button
                    type="button"
                    className="-m-2.5 p-2.5"
                    onClick={() => setSidebarOpen(false)}
                  >
                    <span className="sr-only">Close sidebar</span>
                    <XMarkIcon
                      className="h-6 w-6 text-white"
                      aria-hidden="true"
                    />
                  </button>
                </div>
              </Transition.Child>

              {/* Sidebar component, swap this element with another sidebar if you like */}
              <aside className="flex grow flex-col gap-y-5 overflow-y-auto bg-gray-900 px-6 pb-2 ring-1 ring-white/10">
                <div className="flex h-16 shrink-0 items-center">
                  <h1 className="bg-gradient-to-r from-blue-600 via-green-500 to-indigo-400 bg-clip-text text-xl font-semibold text-transparent">
                    Interior Designer
                  </h1>
                </div>
                <nav className="flex flex-1 flex-col">
                  <ul role="list" className="flex flex-1 flex-col gap-y-7">
                    <li>
                      <ul role="list" className="-mx-2 space-y-1">
                        {navigation.map((item) => (
                          <li key={item.name}>
                            <a
                              href={item.href}
                              className={classNames(
                                pathName === item.href
                                  ? "bg-gray-800 text-white"
                                  : "text-gray-400 hover:bg-gray-800 hover:text-white",
                                "group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6 transition-all duration-300"
                              )}
                            >
                              <item.icon
                                className="h-6 w-6 shrink-0"
                                aria-hidden="true"
                              />
                              {item.name}
                            </a>
                          </li>
                        ))}
                      </ul>
                    </li>
                  </ul>
                </nav>
              </aside>
            </Dialog.Panel>
          </Transition.Child>
        </div>
      </Dialog>
    </Transition.Root>
  );
}


==== src/app/on-device/[slug]/page.tsx ====
(Skipped binary or unreadable file)

==== src/app/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu";
import { ImageAreaProps } from "@/types";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const themes = ["Modern", "Vintage", "Minimalist", "Professional"];
const rooms = ["Living Room", "Dining Room", "Bedroom", "Bathroom", "Office"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a room and let our AI generate a new design.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [theme, setTheme] = useState<string>(themes[0]);
  const [room, setRoom] = useState<string>(rooms[0]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file) {
      setError("Please upload an image.");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/inter-design", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image, theme, room }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    // Output returns an array of two images
    // Here we show the second image
    setOutputImage(result.output[1]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      <section className="mx-4 mt-9 flex w-fit flex-col space-y-8 lg:mx-6 lg:flex-row lg:space-x-8 lg:space-y-0 xl:mx-8">
        <SelectMenu
          label="Model"
          options={themes}
          selected={theme}
          onChange={setTheme}
        />
        <SelectMenu
          label="Room type"
          options={rooms}
          selected={room}
          onChange={setRoom}
        />
      </section>

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/providers.tsx ====
"use client"

import { ThemeProvider } from "next-themes"

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
      {children}
    </ThemeProvider>
  )
}

==== src/app/removebg/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu"
import { ImageAreaProps } from "@/types";
import { Field, Input, Label, Description, } from "@headlessui/react";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const themes = ["Modern", "Vintage", "Minimalist", "Professional"];
const rooms = ["Living Room", "Dining Room", "Bedroom", "Bathroom", "Office"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a product and let our AI generate a new background.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [theme, setTheme] = useState<string>(themes[0]);
  const [room, setRoom] = useState<string>(rooms[0]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file) {
      setError("Please upload an image");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/removebg", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image }),
    });

    const result = await response.json();

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    // Output returns an array of two images
    // Here we show the second image
    setOutputImage(result.output);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/selectmenu.tsx ====
import { Fragment } from "react";
import { classNames } from "@/utils";
import { Listbox, Transition } from "@headlessui/react";
import { ListboxButton, ListboxOption, ListboxOptions } from '@headlessui/react'
import { CheckIcon, ChevronUpDownIcon } from "@heroicons/react/20/solid";

type SelectMenuProps = {
  label: string;
  options: string[];
  selected: string;
  onChange(value: string): void;
};

export function SelectMenu({
  label,
  options,
  selected,
  onChange,
}: SelectMenuProps) {
  return (
    <Listbox value={selected} onChange={onChange}>
      {({ open }) => (
        <div className="w-80">
          <label className="block text-sm font-medium leading-6 text-gray-300">
            {label}
          </label>
          <div className="relative mt-2">
            <ListboxButton className="relative w-full cursor-default rounded-md py-1.5  pl-3 pr-10 text-left text-gray-300 shadow-sm ring-1 ring-inset ring-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-600 dark:bg-slate-800 sm:text-sm sm:leading-6">
              <span className="block truncate">{selected}</span>
              <span className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2">
                <ChevronUpDownIcon
                  className="h-5 w-5 text-gray-400"
                  aria-hidden="true"
                />
              </span>
            </ListboxButton>

            <Transition
              show={open}
              as={Fragment}
              leave="transition ease-in duration-100"
              leaveFrom="opacity-100"
              leaveTo="opacity-0"
            >
              <ListboxOptions className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md py-1 text-gray-300 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none dark:bg-slate-800 sm:text-sm">
                {options.map((option, index) => (
                  <ListboxOption
                    key={`${option}_${index}`}
                    value={option}
                    className={({ active }) =>
                      classNames(
                        active ? "bg-indigo-600 text-white" : "text-gray-300",
                        "relative cursor-default select-none py-2 pl-8 pr-4"
                      )
                    }
                  >
                    {({ selected, active }) => (
                      <>
                        <span
                          className={classNames(
                            selected ? "font-semibold" : "font-normal",
                            "block truncate"
                          )}
                        >
                          {option}
                        </span>

                        {selected ? (
                          <span
                            className={classNames(
                              active ? "text-white" : "text-indigo-600",
                              "absolute inset-y-0 left-0 flex items-center pl-1.5"
                            )}
                          >
                            <CheckIcon className="h-5 w-5" aria-hidden="true" />
                          </span>
                        ) : null}
                      </>
                    )}
                  </ListboxOption>
                ))}
              </ListboxOptions>
            </Transition>
          </div>
        </div>
      )}
    </Listbox>
  );
}


==== src/app/sidebar.tsx ====
"use client";

import { useState } from "react";
import { Header } from "./header";
import { MobileSidebar } from "./mobile-sidebar";
import { DesktopSidebar } from "./desktop-sidebar";

export function Sidebar() {
  const [sidebarOpen, setSidebarOpen] = useState<boolean>(false);

  return (
    <>
      <MobileSidebar
        sidebarOpen={sidebarOpen}
        setSidebarOpen={setSidebarOpen}
      />
      <DesktopSidebar />
      <Header onClick={() => setSidebarOpen(true)} />
    </>
  );
}


==== src/app/simpson/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu"
import { ImageAreaProps } from "@/types";
import { Field, Input, Label, Description, } from "@headlessui/react";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const themes = ["Modern", "Vintage", "Minimalist", "Professional"];
const rooms = ["Living Room", "Dining Room", "Bedroom", "Bathroom", "Office"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a product and let our AI generate a new background.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [prompt, setPrompt] = useState<string | null>(null);
  const [theme, setTheme] = useState<string>(themes[0]);
  const [room, setRoom] = useState<string>(rooms[0]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file || !prompt) {
      setError("Please upload an image & fill the prompt");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/simpson", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image, prompt }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    // Output returns an array of two images
    // Here we show the second image
    setOutputImage(result.output[0]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      {/* <section className="mx-4 mt-9 flex w-fit flex-col space-y-8 lg:mx-6 lg:flex-row lg:space-x-8 lg:space-y-0 xl:mx-8"> */}
        {/* <Input name="full_name" type="text" /> */}
        {/* <SelectMenu
          label="Model"
          options={themes}
          selected={theme}
          onChange={setTheme}
        />
        <SelectMenu
          label="Room type"
          options={rooms}
          selected={room}
          onChange={setRoom}
        /> */}
      {/* </section> */}
      <Field className="flex flex-col px-4 gap-1 lg:px-6 xl:gap-1 xl:px-8">
        <Label className="text-sm/6 font-medium text-white">Prompt</Label>
        <Description className="text-sm/6 text-white/50">Describe the simpson charachter.</Description>
        <Input 
        className="border bg-slate-500 rounded-lg w-full"
        name="prompt"
        onChange={(e)=> setPrompt(e.target.value)}
        />
      </Field>

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/upscaler/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu";
import { ImageAreaProps } from "@/types";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a room and let our AI generate a new design.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file) {
      setError("Please upload an image.");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/upscale", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    setOutputImage(result.output[0]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/common/configuration.ts ====
import { Configurations } from "@/types";

const configurationsObj: Configurations = [
  {
    name: 'pyramid-flow',
    type: 'gradio',
    client: 'Pyramid-Flow/pyramid-flow',
    path: '/generate_video',
    inputs: [
      { component: 'prompt', type: 'string', key: 'prompt', value: null, show: true },
      { component: 'image', type: 'string', key: 'image', value: null, show: true },
      { component: 'prompt', type: 'integer', key: 'duration', value: 1, show: false },
      { component: 'prompt', type: 'integer', key: 'guidance_scale', value: 1 },
      { component: 'prompt', type: 'integer', key: 'video_guidance_scale', value: 1 },
      { component: 'prompt', type: 'integer', key: 'frames_per_second', value: 8 }
    ],
    outputs: [
      { component: 'video', type: 'string', key: 'visualitation', placeholder: 'video output', show: true }
    ]
  },
  {
    name: 'Hivision',
    type: 'gradio',
    client: 'TheEeeeLin/HivisionIDPhotos',
    path: '/idphoto_inference',
    inputs: [
      { component: 'image', type: 'string', key: 'input_image', value: 'https://theeeeelin-hivisionidphotos.hf.space/file=/tmp/gradio/5bf86fbc980e461b32c5e52a47b8f5c0909f27e3ab146f7e0155e72f49be4e06/test2.jpg', show: true },
      { component: 'prompt', type: 'string', key: 'mode_option', label: 'Mode Option', value: "Size List", show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'size_list_option', label: 'Size List Option', value: "One inch (413, 295)", show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'color_option', label: 'Color Option', value: "Blue", show: true }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'render_option', label: 'Render Option', value: "Solid Color", show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'image_kb_options', label: 'Image KB Options', value: "Not Set", show: false },
      { component: 'number', type: 'integer', key: 'custom_color_R', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'custom_color_G', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'custom_color_B', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'custom_size_height', value: 413, show: false }, // Added component and changed show to false
      { component: 'number', type: 'integer', key: 'custom_size_width', value: 295, show: false }, // Added component and changed show to false
      { component: 'number', type: 'integer', key: 'custom_image_kb', value: 50, show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'language', label: 'Language', value: "English", show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'matting_model_option', label: 'Matting Model Option', value: "modnet_photographic_portrait_matting", show: false }, // Added component and changed show to false
    ],
    outputs: [
      { component: 'image', type: 'string', placeholder: 'Visualitation', key:'visulization', show: true },
      { component: 'image', type: 'string', placeholder: 'mask', key:'mask', show: true },
    ],
  },
  {
    name: 'FineGrainImageEnhancer',
    type: 'gradio',
    client: 'finegrain/finegrain-image-enhancer',
    path: '/process',
    inputs: [
      { component: 'image', type: 'string', key: 'input_image', value: null, show: true }, // Added input for image
      { component: 'prompt', type: 'string', key: 'prompt', value: "Hello!!", show: false },
      { component: 'prompt', type: 'string', key: 'negative_prompt', value: "Hello!!", show: false },
      { component: 'number', type: 'integer', key: 'seed', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'upscale_factor', value: 1, show: false },
      { component: 'number', type: 'integer', key: 'controlnet_scale', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'controlnet_decay', value: 0.5, show: false },
      { component: 'number', type: 'integer', key: 'condition_scale', value: 2, show: false },
      { component: 'number', type: 'integer', key: 'tile_width', value: 64, show: false },
      { component: 'number', type: 'integer', key: 'tile_height', value: 64, show: false },
      { component: 'number', type: 'integer', key: 'denoise_strength', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'num_inference_steps', value: 1, show: false },
      { component: 'prompt', type: 'string', key: 'solver', value: "DDIM", show: false },
    ],
    outputs: [
      { component: 'image', type: 'string', placeholder: 'Processed Image', key: 'output_image', show: true },
    ],
  },
  {
    name: 'EVF-SAM',
    type: 'gradio',
    client: 'wondervictor/evf-sam',
    path: '/predict',
    inputs: [
      { component: 'image', type: 'string', key: 'image_np', value: null, show: true },
      { component: 'prompt' ,type: 'string', key: 'prompt', label: 'Prompt', description: 'Use a phrase or sentence to describe the object you want to segment. Currently we only support English', value: null, show: true },
    ],
    outputs: [
      { component: 'image', type: 'array', placeholder: 'Visualitation', key:'visulization', show: true },
      { component: 'image', type: 'array', placeholder: 'mask', key:'mask', show: true },
    ],
  },
  {
    name: 'Spanish-F5',
    type: 'gradio',
    client: 'jpgallegoar/Spanish-F5',
    path: '/predict',
    inputs: [
      { component: 'image', type: 'string', key: 'image_np', value: null, show: true },
      { component: 'prompt' ,type: 'string', key: 'prompt', label: 'Prompt', description: 'Use a phrase or sentence to describe the object you want to segment. Currently we only support English', value: null, show: true },
    ],
    outputs: [
      { component: 'image', type: 'array', placeholder: 'Visualitation', key:'visulization', show: true },
      { component: 'image', type: 'array', placeholder: 'mask', key:'mask', show: true },
    ],
  },
  {
    name: 'logo-context',
    type: 'gradio',
    client: 'multimodalart/logo-in-context',
    path: '/generate',
    inputs: [
      { component: 'image', type: 'string', key: 'image', placeholder: 'Upload Logo Imagen',value: null, show: true }, // Added input for image
      { component: 'prompt', type: 'string', key: 'prompt_description', label: 'Describe your logo', value: "Hello!!", show: true },
      { component: 'prompt', type: 'string', key: 'prompt_user', label: 'Where should the logo be applied?', value: "Hello!!", show: true },
    ],
    outputs: [
      { component: 'image', type: 'array', placeholder: 'Processed Image', key: 'output_image', show: true },
    ],
  },
  {
    name: 'consistent-character-gradio',
    type: 'gradio',
    client: 'Kwai-Kolors/Kolors-Character-With-Flux',
    path: '/generate',
    inputs: [
      { component: 'image', type: 'string', key: 'image', placeholder: 'Upload Logo Imagen',value: null, show: true }, // Added input for image
      { component: 'prompt', type: 'string', key: 'prompt_description', label: 'Describe your logo', value: "Hello!!", show: true },
      { component: 'prompt', type: 'string', key: 'prompt_user', label: 'Where should the logo be applied?', value: "Hello!!", show: true },
    ],
    outputs: [
      { component: 'image', type: 'string', placeholder: 'Processed Image', key: 'output_image', show: true },
    ],
  },
  {
    name: "flux-ip-adapter",
    type: "gradio",
    client: "InstantX/flux-IP-adapter",
    path: "/process_image",
    inputs: [
      { component: 'image', type: 'string', key: 'image', placeholder: 'Upload Logo Imagen',value: null, show: true },
      { component: 'prompt', type: 'string', key: 'prompt', label: 'Describe your logo', value: "Hello!!", show: true },
      { component: 'prompt', type: 'integer', key: 'scale', value: 0.7, show: false },
      { component: 'prompt', type: 'integer', key: 'seed', value: 42, show: false },
      { component: 'checkbox', type: 'boolean', key: 'randomize_seed', value: true, show: false },
      { component: 'checkbox', type: 'boolean', key: 'width', value: 1024, show: false },
      { component: 'checkbox', type: 'boolean', key: 'height', value: 1024, show: false },
    ],
    outputs: [
      { component: 'image', type: 'array', format: 'string', placeholder: 'Processed Image', key: 'output_image', show: true },
      { component: 'prompt', type: 'array', placeholder: 'Processed Image', key: 'seed', show: true },
    ]
  },
  {
    name: 'consistent-character-replicate',
    type: 'replicate',
    model: 'fofr/consistent-character',
    version: '9c77a3c2f884193fcee4d89645f02a0b9def9434f9e03cb98460456b831c8772',
    inputs: [
      { component: 'prompt', type: 'string', key: 'prompt', label: 'Prompt', description: 'the prompt to generate the character', value: 'A closeup headshot photo of a young woman in a grey sweater', show: true },
      { component: 'image', type: 'string', key: 'subject', value: 'https://replicate.delivery/pbxt/L0gy7uyLE5UP0uz12cndDdSOIgw5R3rV5N6G2pbt7kEK9dCr/0_3.webp', show: true },
      { component: 'prompt', type: 'string', key: 'output_format', value: 'webp', show: false },
      { component: 'prompt', type: 'integer', key: 'output_quality', value: 80, show: false },
      { component: 'prompt', type: 'string', key: 'negative_prompt', value: "", show: false },
      { component: 'prompt', type: 'boolean', key: 'randomise_poses', value: true, show: false },
      { component: 'number', type: 'boolean', key: 'number_of_outputs', label: 'number of outputs', value: 5, show: false },
      { component: 'number', type: 'boolean', key: 'number_of_images_per_pose', label: 'number of images per pose', value: 1, show: false },
    ],
    outputs: [
      { component: 'image', type: 'array', typeItem: 'string', format: 'uri', placeholder: 'characther', key:'output', show: true },
    ],
  },{
    "name": "HiDream",
    "type": "gradio",
    "client": "HiDream-ai/HiDream-I1-Dev",
    "path": "/predict",
    "endpoint": "/generate_with_status",
    "inputs": [
      {
        "type": "string",
        "key": "prompt",
        "show": true,
        "placeholder": "",
        "gradioName": "",
        "label": "Prompt",
        "description": "",
        "component": "Textbox",
        "value": null
      },
      {
        "type": "string",
        "key": "aspect_ratio",
        "show": false,
        "placeholder": "",
        "gradioName": "",
        "label": "Aspect Ratio",
        "description": "",
        "component": "Textbox",
        "value": "4:3"
      },
      {
        "type": "integer",
        "key": "seed",
        "show": false,
        "placeholder": "",
        "gradioName": "",
        "label": "Seed (use -1 for random)",
        "description": "",
        "component": "number",
        "value": 82706
      }
    ],
    "outputs": [
      {
        "type": "string",
        "key": "generated_image",
        "show": true,
        "placeholder": "",
        "component": "image",
      },
      {
        "type": "number",
        "key": "seed_used",
        "show": false,
        "placeholder": "",
        "component": "prompt",
      },
      {
        "type": "string",
        "key": "value_15",
        "show": false,
        "placeholder": "",
        "component": "prompt",
      },
      {
        "type": "string",
        "key": "details",
        "show": false,
        "placeholder": "",
        "component": "prompt",
      }
    ]
  }
]

// New function to fetch configurations
async function fetchConfigurations(timestamp?: number) {
  try {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const url = `${baseUrl}/api/create/get${timestamp ? `?timestamp=${timestamp}` : ''}`;
    const response = await fetch(url, { next: { revalidate: 3600 } });
    if (!response.ok) throw new Error('Failed to fetch configurations');
    return response.json();
  } catch (error) {
    console.error('Error fetching configurations:', error);
    return null;
  }
}

// Combine local configurations with fetched configurations
async function getConfigurations(forceRefresh: boolean = false): Promise<Configurations> {
  const timestamp = forceRefresh ? Date.now() : undefined;
  const fetchedConfigurations = await fetchConfigurations(timestamp);
  console.log({fetchedConfigurations});
  return fetchedConfigurations ? [...configurationsObj, ...fetchedConfigurations] : configurationsObj;
}

export  {getConfigurations};


==== src/common/index.ts ====
import { 
  HomeIcon,
  BoltIcon, 
  BoltSlashIcon, 
  SunIcon, 
  CubeTransparentIcon,
  CakeIcon,
  PaintBrushIcon,
  VideoCameraIcon,
  FaceSmileIcon,
  CpuChipIcon,
  MicrophoneIcon,
  SpeakerWaveIcon,
  PaperAirplaneIcon,
  UserCircleIcon
} from '@heroicons/react/24/outline';
import { NavItem } from '@/types';

export const navigation: Array<NavItem> = [
  { name: 'Interior Design', href: '/', icon: HomeIcon },
  { name: 'IlluminAI', href: '/illuminai', icon: SunIcon },
  { name: 'Upscaler', href: '/app/upscaler', icon:  CubeTransparentIcon},
  { name: 'Enhance Background', href: '/enhancebg', icon: BoltIcon },
  { name: 'Remove Background', href: '/removebg', icon: BoltSlashIcon },
  { name: 'Become Simpson', href: '/simpson', icon: CakeIcon },
  { name: 'FreshInk', href: '/app/freshink', icon: PaintBrushIcon },
  { name: 'Create Video', href: '/app/createVideo', icon: VideoCameraIcon },
  { name: 'Hair Style', href: '/app/hairStyle', icon: FaceSmileIcon },
  { name: 'Live Portrait', href: '/app/livePortrait', icon: MicrophoneIcon },
  { name: 'tts', href: '/on-device/tts', icon: SpeakerWaveIcon },
  { name: 'Trip Planner', href: '/chat/trip', icon: PaperAirplaneIcon },
  { name: 'TryOn', href: '/app/tryon', icon: UserCircleIcon },
  { name: 'Sam2', href: '/app/sam2', icon: UserCircleIcon },
  { name: 'Logo', href: '/app/logo', icon: UserCircleIcon },
  { name: 'EVF-SAM', href: '/app/EVF-SAM', icon: UserCircleIcon },
];


==== src/components/AppPreview.tsx ====
import { useState, useEffect, useRef } from 'react';
import { Configuration } from '@/types';
import { PhotoIcon, FaceSmileIcon, SparklesIcon, VideoCameraIcon, MicrophoneIcon } from "@heroicons/react/24/outline";
import { ThreeDots } from "react-loader-spinner";
import { Prompt } from './prompt';
import { NumberInput, Slider, Checkbox, CheckboxGroup, NumberOutput } from './numericInput';
import { FaDownload } from "react-icons/fa";
import { SelectMenu } from "@/app/selectmenu";
import Dropzone, { FileRejection } from 'react-dropzone';

interface AppPreviewProps {
  config: Configuration & {
    endpoints?: string[];
  };
  onEndpointChange?: (endpoint: string) => void;
  onAppNameChange?: (name: string) => void;
}

export default function AppPreview({ config, onEndpointChange, onAppNameChange }: AppPreviewProps) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [inputValues, setInputValues] = useState<{ [key: string]: string | number | boolean | null }>({});
  const [outputValues, setOutputValues] = useState<{ [key: string]: string | number | boolean | null }>({});

  const [files, setFiles] = useState<Record<string, File>>({});
  const [base64Images, setBase64Images] = useState<Record<string, string>>({});

  // Reset all states when endpoint changes
  useEffect(() => {
    setInputValues({});
    setOutputValues({});
    setFiles({});
    setBase64Images({});
    setError(null);
  }, [config.endpoint]);

  // Initialize input values from config
  useEffect(() => {
    const initialValues: Record<string, any> = {};
    config.inputs.forEach(input => {
      if (input.show) {
        initialValues[input.key] = input.value ?? null;
      }
    });
    setInputValues(initialValues);
  }, [config.inputs]);

  const handleInputChange = (key: string, value: any) => {
    setInputValues(prev => ({
      ...prev,
      [key]: value
    }));
  };

  const onImageDrop = (
    acceptedFiles: File[],
    rejectedFiles: FileRejection[],
    key: string
  ): void => {
    if (rejectedFiles.length > 0) {
      setError(`Please upload a PNG or JPEG image less than 5MB.`);
      return;
    }

    setError("");
    setFiles(prev => ({ ...prev, [key]: acceptedFiles[0] }));

    // Convert to base64
    const reader = new FileReader();
    reader.readAsDataURL(acceptedFiles[0]);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Images(prev => ({ ...prev, [key]: binaryStr }));
      handleInputChange(key, binaryStr);
    };
  };

  const onAudioDrop = (
    acceptedFiles: File[],
    rejectedFiles: FileRejection[],
    key: string
  ): void => {
    if (rejectedFiles.length > 0) {
      setError(`Please upload an MP3, WAV or OGG audio file less than 10MB.`);
      return;
    }

    setError("");
    setFiles(prev => {
      const newFiles = { ...prev };
      if (acceptedFiles[0]) {
        newFiles[key] = acceptedFiles[0];
      } else {
        delete newFiles[key];
      }
      return newFiles;
    });

    // Convert to base64
    const reader = new FileReader();
    reader.readAsDataURL(acceptedFiles[0]);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Images(prev => {
        const newImages = { ...prev };
        if (binaryStr) {
          newImages[key] = binaryStr;
        } else {
          delete newImages[key];
        }
        return newImages;
      });
      handleInputChange(key, binaryStr);
    };
  };

  const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
  const eventSourceRef = useRef<EventSource | null>(null);

  // Cleanup SSE connection on component unmount
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        console.log("Closing SSE connection on unmount");
        eventSourceRef.current.close();
      }
    };
  }, []);

  const fetchRegularPreview = async () => {
    console.log('Fetching regular preview');
    setLoading(true);
    setOutputValues({});
    setError(null);

    try {
      const params: any = {};
      config.inputs.forEach(input => {
        if (!input.show) return;
        params[input.key] = inputValues[input.key] ?? null;
        if (input.component === 'image' && base64Images[input.key]) {
          params[input.key] = base64Images[input.key];
        }
        // Add handling for other file types if needed (audio, video)
      });

      const response = await fetch('/api/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ config, params })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Request failed with status ' + response.status }));
        throw new Error(errorData.error || `Request failed with status ${response.status}`);
      }

      const responseData = await response.json();
      // Define a type for the expected result structure
      type PredictionResult = {
        status: 'succeeded' | 'failed' | 'processing' | 'starting';
        output?: any; // Can be array, object, or primitive
        error?: string;
      };

      let result: PredictionResult;

      if (responseData.id && config.type === 'replicate') { // Only poll for Replicate
        console.log("Polling Replicate prediction:", responseData.id);
        let status = responseData.status;
        let pollCount = 0;
        const maxPolls = 60; // Poll for max 60 seconds

        // Initialize result before loop
        result = { status: responseData.status, output: responseData.output };

        while (status !== 'succeeded' && status !== 'failed' && pollCount < maxPolls) {
          await sleep(1000);
          const pollResponse = await fetch(`/api/preview/get?id=${responseData.id}`);
          // Assign the fetched result, ensuring it matches PredictionResult type
          result = await pollResponse.json() as PredictionResult;
          console.log("Poll status:", result.status);
          if (result.error) throw new Error(result.error);
          status = result.status;
          pollCount++;
        }
        if (status === 'failed') throw new Error(result.error || 'Processing failed');
        if (pollCount >= maxPolls && status !== 'succeeded') throw new Error('Prediction timed out');

      } else { // Gradio or immediate Replicate result
        result = { status: 'succeeded', output: responseData.output };
      }

      // Map outputs
      const outputs: Record<string, any> = {};
      console.log('Mapping outputs:', { result, configOutputs: config.outputs });
      (config.outputs || []).forEach((output, index) => {
        if (!output.show || !result || result.output === undefined) return; // Add checks for result and result.output

        if (Array.isArray(result.output)) {
           if (output.type === 'array') {
             outputs[output.key] = result.output; // Assign whole array if expected
           } else {
             // Ensure index is within bounds
             if (index < result.output.length) {
              outputs[output.key] = result.output[index]; // Assign by index otherwise
             } else {
              console.warn(`Output index ${index} out of bounds for result array.`);
             }
           }
        } else if (typeof result.output === 'object' && result.output !== null) {
           // Handle cases where output might be an object with keys matching output keys
          outputs[output.key] = result.output[output.key] ?? result.output;
        } else {
           // Assign single value to the first output key
          if (index === 0) {
          outputs[output.key] = result.output;
          }
        }
      });

      console.log('Setting outputs:', outputs);
      setOutputValues(outputs);
    } catch (err) {
      console.error("Regular preview fetch error:", err);
      setError(err instanceof Error ? err.message : 'An error occurred during preview.');
    } finally {
      setLoading(false);
    }
  };

  const handleSubmitPreview = async () => {
    console.log('App Preview Submit');
    setError(null);
    setOutputValues({}); // Clear previous outputs

    // Close any existing SSE connection
    if (eventSourceRef.current) {
      console.log("Closing previous SSE connection");
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }

    // Validate inputs
    let hasErrors = false;
    config.inputs.forEach(input => {
      if (!input.show) return;
      // Basic check: if required is true (or undefined, assuming required by default if shown)
      // and the value is null/undefined/empty string, and it's not a file input with a file selected
      const isFileSelected = (input.component === 'image' || input.component === 'audio' || input.component === 'video') && files[input.key];
      const valueIsEmpty = inputValues[input.key] === null || inputValues[input.key] === undefined || inputValues[input.key] === '';

      if ((input.required !== false) && valueIsEmpty && !isFileSelected) {
        setError(`Input "${input.label || input.key}" is required.`);
        hasErrors = true;
      }
    });
    if (hasErrors) return;

    setLoading(true);

    // Check feature flag and app type
    const useSSE = process.env.NEXT_PUBLIC_USE_SSE_EXPERIMENTAL === 'true' && config.type === 'gradio';
    console.log('Using SSE:', useSSE);
    console.log('Input values:', inputValues);

    if (useSSE) {
      console.log('Attempting SSE connection for Gradio preview...');
      try {
        // Construct query parameters for SSE endpoint
        const params = new URLSearchParams();
        params.append('client', config.client || '');
        params.append('endpoint', config.endpoint || '');

        // Add input values to query params
        config.inputs.forEach(input => {
          if (input.show) {
            const value = inputValues[input.key];
            if (value !== null && value !== undefined) {
              // Handle file inputs (send base64)
              if ((input.component === 'image' || input.component === 'audio' || input.component === 'video') && base64Images[input.key]) {
                 params.append(input.key, base64Images[input.key]);
              } else if (typeof value === 'boolean') {
                 params.append(input.key, value.toString());
              } else {
                 params.append(input.key, String(value)); // Convert numbers etc. to string
              }
            }
          }
        });

        // Phase 1: POST to /init to get event_id
        const inputData: any[] = [];
        config.inputs.forEach(input => {
          if (input.show) {
            const value = inputValues[input.key];
            if ((input.component === 'image' || input.component === 'audio' || input.component === 'video') && base64Images[input.key]) {
              inputData.push({ 
                name: files[input.key]?.name || 'input_file', 
                data: base64Images[input.key], 
                is_file: true 
              });
            } else {
              inputData.push(value ?? null);
            }
          } else {
            inputData.push(input.value ?? null);
          }
        });

        const initResponse = await fetch('/api/experimental/sse/init', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            client: config.client,
            endpoint: config.endpoint,
            inputs: inputData
          })
        });

        if (!initResponse.ok) {
          const errorData = await initResponse.json().catch(() => ({ error: 'Init request failed' }));
          throw new Error(errorData.error || `SSE Init failed: ${initResponse.status}`);
        }

        const { event_id, client: returnedClient } = await initResponse.json();
        if (!event_id) throw new Error('Did not receive event_id from init endpoint');

        // Phase 2: GET from /stream using the event_id
        const streamUrl = `/api/experimental/sse/stream?event_id=${event_id}&client=${returnedClient}&endpoint=${config.endpoint}`;
        const eventSource = new EventSource(streamUrl);
        eventSourceRef.current = eventSource; // Store reference for cleanup

        eventSource.onmessage = (event) => {
          console.log('SSE Message:', event.data ? event.data.substring(0,100) + '...' : 'No data');
          setLoading(false); // Stop loading indicator on first message (might be heartbeat or generating)
          try {
            // Check for specific SSE events if the backend sends them
             if (event.type === 'message') { // Default event type
               const messageData = JSON.parse(event.data);
               // Assuming messageData is the array of outputs or final result object
               const outputs: Record<string, any> = {};
                (config.outputs || []).forEach((output, index) => {
                  if (!output.show) return;
                  if (Array.isArray(messageData)) {
                    outputs[output.key] = messageData[index];
                  } else if (typeof messageData === 'object' && messageData !== null) {
                    outputs[output.key] = messageData[output.key] ?? messageData; // Try matching key or assign whole object
                  } else {
                    // Assign single value to the first output key
                    if (index === 0) {
                       outputs[output.key] = messageData;
                    }
                  }
                });
                setOutputValues(prev => ({ ...prev, ...outputs })); // Merge updates
             } else if (event.type === 'generating') {
                console.log("SSE Generating:", event.data);
                // Potentially update UI with intermediate state
             } else if (event.type === 'complete') {
                console.log("SSE Complete event received.");
                eventSource.close();
                eventSourceRef.current = null;
             } else if (event.type === 'heartbeat') {
                console.log("SSE Heartbeat");
             }

          } catch (parseError) {
            console.error('Error parsing SSE data:', parseError, "Raw data:", event.data);
            setError('Received invalid data from server.');
            eventSource.close();
            eventSourceRef.current = null;
            setLoading(false);
          }
        };

        eventSource.onerror = (error) => {
          console.error('SSE Error:', error);
          // Avoid setting error if it was just closed normally
          if (eventSourceRef.current) {
             setError('SSE connection failed.');
             eventSource.close();
             eventSourceRef.current = null;
             setLoading(false);
          }
          // Optional: Fallback to regular fetch
          // fetchRegularPreview();
        };

        // Note: The backend currently sends 'message' event. If it sends 'complete' or custom 'error_event',
        // add specific listeners here like:
        // eventSource.addEventListener('complete', () => { ... });
        // eventSource.addEventListener('error_event', (event: any) => { ... });


      } catch (err) {
        console.error('Error initiating SSE:', err);
        setError(err instanceof Error ? err.message : 'Failed to start SSE connection.');
        setLoading(false);
        // Optional: Fallback
        // fetchRegularPreview();
      }
    } else {
      // Use existing fetch implementation for Replicate or if SSE is disabled
      fetchRegularPreview();
    }
  };

  const downloadOutputImage = (url: string) => {
    const link = document.createElement('a');
    link.href = url;
    link.download = 'output.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const downloadOutputAudio = (url: string) => {
    const link = document.createElement('a');
    link.href = url;
    link.download = 'output.mp3';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="mx-auto w-full max-w-4xl">
      <div className="flex flex-col space-y-8">
        <div className="space-y-4">
          <div className="flex items-center space-x-4">
            <label className="text-sm font-medium text-gray-300">App Name:</label>
            <input
              type="text"
              value={config.name || ''}
              onChange={(e) => onAppNameChange?.(e.target.value)}
              placeholder="Enter app name"
              className="flex-grow px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          {config.type === 'gradio' && (
            <div className="flex items-center space-x-4">
              <label className="text-sm font-medium text-gray-300">Endpoint:</label>
              <select
                value={config.endpoint}
                onChange={(e) => onEndpointChange?.(e.target.value)}
                className="flex-grow px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                {config.endpoints?.map(item => (
                  <option key={item} value={item}>{item}</option>
                ))}
              </select>
            </div>
          )}
        </div>
        {error && (
          <div className="rounded-md bg-red-50 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-red-700">{error}</p>
              </div>
            </div>
          </div>
        )}

        <div className="grid grid-cols-2 gap-8">
          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-300">Inputs</h3>
            {config.inputs.map((input, index) => {
              if (!input.show) return null;

              switch (input.component.toLowerCase()) {
                case 'prompt':
                  return (
                    <Prompt
                      key={index}
                      label={input.label || input.key}
                      placeholder={input.placeholder || ''}
                      description={input.description || ''}
                      placeholderTextArea={input.value?.toString() || ''}
                      setPrompt={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'textbox':
                  return (
                    <Prompt
                      key={index}
                      label={input.label || input.key}
                      placeholder={input.placeholder || ''}
                      description={input.description || ''}
                      placeholderTextArea={input.value?.toString() || ''}
                      setPrompt={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'image':
                  return (
                    <Dropzone
                      key={index}
                      onDrop={(accepted, rejected) => onImageDrop(accepted, rejected, input.key)}
                      accept={{ 'image/*': ['.png', '.jpg', '.jpeg'] }}
                      maxSize={5 * 1024 * 1024}
                    >
                      {({ getRootProps, getInputProps }) => (
                        <div {...getRootProps()} className="relative block w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none">
                          <input {...getInputProps()} />
                          {files[input.key] ? (
                            <img
                              src={URL.createObjectURL(files[input.key])}
                              alt="Preview"
                              className="mx-auto h-48 w-auto object-contain"
                            />
                          ) : (
                            <>
                              <PhotoIcon className="mx-auto h-12 w-12 text-gray-400" />
                              <span className="mt-2 block text-sm font-medium text-gray-300">
                                Drop an image here or click to upload
                              </span>
                            </>
                          )}
                        </div>
                      )}
                    </Dropzone>
                  );
                case 'number':
                  return (
                    <NumberInput
                      key={index}
                      label={input.label || input.key}
                      description={input.description}
                      min={input.min}
                      max={input.max}
                      step={input.step}
                      defaultValue={input.value as number}
                      onChange={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'slider':
                  return (
                    <Slider
                      key={index}
                      label={input.label || input.key}
                      description={input.description}
                      min={input.min}
                      max={input.max}
                      step={input.step}
                      defaultValue={input.value as number}
                      onChange={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'checkbox':
                  return (
                    <Checkbox
                      key={index}
                      label={input.label || input.key}
                      description={input.description}
                      defaultChecked={input.value as boolean}
                      onChange={(checked) => handleInputChange(input.key, checked)}
                    />
                  );
                case 'dropdown':
                  return (
                    <SelectMenu
                      key={index}
                      label={input.label || input.key}
                      options={input.options || []}
                      selected={input.value as string || (input.options || [])[0] || ''}
                      onChange={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'audio':
                  return (
                    <Dropzone
                      key={index}
                      onDrop={(accepted, rejected) => onAudioDrop(accepted, rejected, input.key)}
                      accept={{ 'audio/*': ['.mp3', '.wav', '.ogg'] }}
                      maxSize={10 * 1024 * 1024}
                    >
                      {({ getRootProps, getInputProps }) => (
                        <div {...getRootProps()} className="relative block w-full rounded-lg border-2 border-dashed border-gray-300 p-6 text-center hover:border-gray-400 focus:outline-none">
                          <input {...getInputProps()} />
                          {files[input.key] ? (
                            <div className="space-y-2">
                              <div className="flex items-center justify-between">
                                <span className="text-sm font-medium text-gray-300 truncate max-w-xs">
                                  {files[input.key].name}
                                </span>
                                <span className="text-xs text-gray-400">
                                  {(files[input.key].size / (1024 * 1024)).toFixed(2)}MB
                                </span>
                              </div>
                              <audio 
                                src={URL.createObjectURL(files[input.key])} 
                                controls
                                className="w-full mt-2"
                              />
                              <button 
                                type="button"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setFiles(prev => {
                                    const newFiles = {...prev};
                                    delete newFiles[input.key];
                                    return newFiles;
                                  });
                                  setBase64Images(prev => {
                                    const newImages = {...prev};
                                    delete newImages[input.key];
                                    return newImages;
                                  });
                                }}
                                className="text-xs text-red-400 hover:text-red-300"
                              >
                                Remove Audio
                              </button>
                            </div>
                          ) : (
                            <>
                              <MicrophoneIcon className="mx-auto h-10 w-10 text-gray-400" />
                              <p className="mt-2 text-sm font-medium text-gray-300">
                                Drop audio file or click to browse
                              </p>
                              <p className="text-xs text-gray-400 mt-1">
                                MP3, WAV, OGG (max 10MB)
                              </p>
                            </>
                          )}
                        </div>
                      )}
                    </Dropzone>
                  );
                default:
                  return (
                    <div key={index}>
                      Unsupported input type: {input.component}
                    </div>
                  );
              }
            })}
          </div>

          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-300">Outputs</h3>
            {config.outputs?.map((output, index) => {
              if (!output.show) return null;

              return (
                <div key={index} className="relative">
                  <div className="mb-2 text-sm font-medium text-gray-300">
                    {output.title || output.key}
                    {loading ? (
                      <div className="flex h-full items-center justify-center">
                        <ThreeDots
                          height="50"
                          width="60"
                          color="#eee"
                          ariaLabel="loading"
                          visible={true}
                        />
                      </div>
                    ) : outputValues[output.key] ? (
                      <div className="relative">
                        {output.component === 'image' && (
                          <>
                            {console.log('Rendering image with:', {
                              outputKey: output.key,
                              value: outputValues[output.key],
                              fullOutputValues: outputValues
                            })}
                            <img
                              src={String(outputValues[output.key])}
                              alt={output.title || 'Output'}
                              className="h-full w-full rounded-lg object-contain"
                            />
                            <button
                              onClick={() => downloadOutputImage(String(outputValues[output.key]))}
                              className="absolute right-2 top-2 rounded bg-gray-700 p-2 hover:bg-gray-600"
                            >
                              <FaDownload className="h-4 w-4 text-gray-300" />
                            </button>
                          </>
                        )}
                        {(output.component === 'textbox' || output.component === 'prompt') && (
                          <div className="text-gray-300">
                            {String(outputValues[output.key])}
                          </div>
                        )}
                        {output.component === 'audio' && outputValues[output.key] && (
                          <div className="space-y-2">
                            <audio 
                              src={String(outputValues[output.key])} 
                              controls
                              className="w-full"
                            />
                            <button
                              onClick={() => downloadOutputAudio(String(outputValues[output.key]))}
                              className="flex items-center text-sm text-gray-300 hover:text-white"
                            >
                              <FaDownload className="mr-1 h-3 w-3" />
                              Download Audio
                            </button>
                          </div>
                        )}
                      </div>
                    ) : (
                      <div className="flex h-full items-center justify-center text-gray-500">
                        Output will appear here
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        <div className="flex justify-end">
          <button
            onClick={handleSubmitPreview}
            disabled={loading || !config.name}
            className={`inline-flex items-center rounded-md px-4 py-2 text-sm font-medium shadow-sm ${
              loading || !config.name
                ? 'cursor-not-allowed bg-gray-600 text-gray-400'
                : 'bg-indigo-600 text-white hover:bg-indigo-700'
            }`}
          >
            {loading ? 'Processing...' : 'Test Configuration'}
            <SparklesIcon className="ml-2 h-4 w-4" />
          </button>
        </div>
      </div>
    </div>
  );
}


==== src/components/audioOutput.tsx ====
type AudioOutputProps = {
  title?: string;
  audioUrl: string | null;
};

export function AudioOutput({ title, audioUrl }: AudioOutputProps) {
  return (
    <div className="w-80 p-4 rounded-lg border border-gray-600 bg-slate-800">
      <div className="text-sm font-medium text-gray-300 mb-2">
        {title || 'Audio Output'}
      </div>
      {audioUrl ? (
        <audio
          controls
          className="w-full"
          src={audioUrl}
        >
          Your browser does not support the audio element.
        </audio>
      ) : (
        <div className="text-gray-500 text-sm italic">
          No audio available yet
        </div>
      )}
    </div>
  );
}

==== src/components/numericInput.tsx ====
type NumberInputProps = {
  label: string;
  description?: string;
  min?: number;
  max?: number;
  step?: number;
  defaultValue?: number;
  onChange: (value: number) => void;
};

export function NumberInput({
  label,
  description,
  min = 0,
  max = 100,
  step = 1,
  defaultValue = 50,
  onChange
}: NumberInputProps) {
  return (
    <div className="w-80">
      <label className="block text-sm font-medium leading-6 text-gray-300">
        {label}
      </label>
      {description && (
        <div className="text-sm text-gray-500">
          {description}
        </div>
      )}
      <input
        type="number"
        min={min}
        max={max}
        step={step}
        defaultValue={defaultValue}
        onChange={(e) => onChange(Number(e.target.value))}
        className="mt-2 block w-full rounded-md border-0 bg-slate-800 py-1.5 text-gray-300 shadow-sm ring-1 ring-inset ring-gray-600 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6"
      />
    </div>
  );
}

type SliderProps = {
  label: string;
  description?: string;
  min?: number;
  max?: number;
  step?: number;
  defaultValue?: number;
  onChange: (value: number) => void;
};

export function Slider({
  label, 
  description,
  min = 0,
  max = 100,
  step = 1,
  defaultValue = 50,
  onChange 
}: SliderProps) {
  return (
    <div className="w-80">
      <label className="block text-sm font-medium leading-6 text-gray-300">
        {label}
      </label>
      {description && (
        <div className="text-sm text-gray-500">
          {description}
        </div>
      )}
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        defaultValue={defaultValue}
        onChange={(e) => onChange(Number(e.target.value))}
        className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-2"
      />
      <div className="mt-1 text-xs text-gray-400">
        Value: {defaultValue}
      </div>
    </div>
  );
}

type CheckboxProps = {
  label: string;
  description?: string;
  defaultChecked?: boolean;
  onChange: (checked: boolean) => void;
};

export function Checkbox({
  label,
  description,
  defaultChecked = false,
  onChange
}: CheckboxProps) {
  return (
    <div className="w-80">
      <label className="flex items-center text-sm font-medium text-gray-300">
        <input
          type="checkbox"
          defaultChecked={defaultChecked}
          onChange={(e) => onChange(e.target.checked)}
          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600 mr-2"
        />
        {label}
      </label>
      {description && (
        <div className="mt-1 text-sm text-gray-500 ml-6">
          {description}
        </div>
      )}
    </div>
  );
}

type CheckboxGroupProps = {
  label: string;
  description?: string;
  options?: string[];
  defaultSelected?: string[];
  onChange: (selected: string[]) => void;
};

export function CheckboxGroup({
  label,
  description,
  options = [],
  defaultSelected = [],
  onChange
}: CheckboxGroupProps) {
  return (
    <div className="w-80">
      <label className="block text-sm font-medium leading-6 text-gray-300">
        {label}
      </label>
      {description && (
        <div className="text-sm text-gray-500">
          {description}
        </div>
      )}
      <div className="mt-2 space-y-2">
        {(options || []).map((option) => (
          <label key={option} className="flex items-center text-sm text-gray-300">
            <input
              type="checkbox"
              defaultChecked={defaultSelected.includes(option)}
              onChange={(e) => {
                const newSelected = e.target.checked
                  ? [...defaultSelected, option]
                  : defaultSelected.filter(item => item !== option);
                onChange(newSelected);
              }}
              className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600 mr-2"
            />
            {option}
          </label>
        ))}
      </div>
    </div>
  );
}

type NumberOutputProps = {
  title?: string;
  value: string | number | null;
};

export function NumberOutput({ title, value }: NumberOutputProps) {
  return (
    <div className="w-80 p-4 rounded-lg border border-gray-600 bg-slate-800">
      <div className="text-sm font-medium text-gray-300 mb-2">
        {title || 'Output Value'}
      </div>
      <div className="text-2xl font-bold text-gray-100">
        {value ?? ''}
      </div>
    </div>
  );
}

==== src/components/prompt.tsx ====

type Props = {
  label:string, 
  placeholder: string
  placeholderTextArea: string,
  description: string,
  setPrompt: (value: string) => void;
}
export function Prompt({label,description ,placeholder, placeholderTextArea, setPrompt}: Props) {
  return (
    <div className="w-80">
      <label className="block text-sm font-medium leading-6 text-gray-300">
        {label}
      </label>
      <div>
        {description}
      </div>
      <textarea
        className="mt-2 w-full border bg-slate-800 text-sm text-gray-300 leading-6 text-left pl-3 py-1 rounded-md"
        placeholder={placeholderTextArea}
        onChange={(e) => setPrompt(e.target.value)}
      />
    </div>
  )
}

==== src/components/textOutput.tsx ====
type TextOutputProps = {
  title?: string;
  placeholder?: string;
  value?: string;
};

export function TextOutput({ title, placeholder, value }: TextOutputProps) {
  return (
    <div className="w-80 p-4 rounded-lg border border-gray-600 bg-slate-800">
      <div className="text-sm font-medium text-gray-300 mb-2">
        {title || 'Text Output'}
      </div>
      <div className="text-lg text-gray-100 break-words">
        {value || placeholder || ''}
      </div>
    </div>
  );
}

==== src/experimental/sse-handler/client.ts ====


==== src/experimental/sse-handler/route.ts ====


==== src/experimental/sse-handler/utils.ts ====


==== src/lib/mongodb.ts ====
import { MongoClient } from 'mongodb'

declare global {
  var _mongoClientPromise: Promise<MongoClient> | undefined;
}

if (!process.env.MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "MONGODB_URI"')
}

const uri = process.env.MONGODB_URI
const options = {}

let client
let clientPromise: Promise<MongoClient>

if (process.env.NODE_ENV === 'development') {
  if (!global._mongoClientPromise) {
    client = new MongoClient(uri, options)
    global._mongoClientPromise = client.connect()
  }
  clientPromise = global._mongoClientPromise
} else {
  client = new MongoClient(uri, options)
  clientPromise = client.connect()
}

export default clientPromise

==== src/types/index.ts ====
export type NavItem = {
  name: string;
  href: string;
  icon: React.ForwardRefExoticComponent<
    Omit<React.SVGProps<SVGSVGElement>, 'ref'> & {
      title?: string | undefined;
      titleId?: string | undefined;
    } & React.RefAttributes<SVGSVGElement>
  >;
};

export type ImageAreaProps = {
  title: string;
  id?: number;
  icon: React.ForwardRefExoticComponent<
    Omit<React.SVGProps<SVGSVGElement>, 'ref'> & {
      title?: string | undefined;
      titleId?: string | undefined;
    } & React.RefAttributes<SVGSVGElement>
  >;
};

export type Slug = "createVideo" | "freshink" | "hairStyle" | "upscaler" | "livePortrait" | "tryon"  | "EVF-SAM";

// Your type definitions
export type InputItem = {
  component: 'image' | 'prompt' | 'checkbox' | 'number' | 'video' | 'Textbox' | 'dropdown' | 'slider' | 'audio' | 'checkboxgroup';
  key: string;
  placeholder?: string;
  type: 'string' | 'array' | 'integer' | 'boolean';
  gradioName?: string;
  show?: boolean;
  label?: string;
  description?: string;
  value?: any;
  required?: boolean;
  // Properties for number and slider inputs
  min?: number;
  max?: number;
  step?: number;
  // Properties for dropdown and checkboxgroup inputs
  options?: string[];
};

export interface OutputItem {
  component: 'image' | 'prompt' | 'checkbox' | 'number' | 'video' | 'audio' | 'textbox';
  key: string;
  placeholder?: string;
  type: 'string' | 'number' | 'boolean' | 'array';
  show: boolean;
  title?: string;
  value?: string;
  typeItem?: 'string' | 'number' | 'boolean';
  format?: string;
  formatItem?: string;
}

// Function to infer component for OutputItem
const inferOutputComponent = (output: OutputItem): OutputItem => {
  if (output.type === 'array' && output.typeItem === 'string' && output.formatItem === 'string') {
    return { ...output, component: 'image' }; // Infer as image
  }
  return output; // Return unchanged if no inference
};

export type Configuration = {
  name: string;
  type: 'gradio' | 'replicate';
  client?: string;
  path?: string;
  endpoint?: string;
  model?: `${string}/${string}` | `${string}/${string}:${string}`;
  version?: string | null;
  inputs: InputItem[];
  outputs?: OutputItem[];
};

export type Configurations = Configuration[];

==== src/utils/gradio.ts ====
/**
 * Normalizes Gradio client URLs/identifiers to consistent format
 * @param inputClient - Client identifier (URL or path)
 * @returns Normalized client identifier
 */
export function fixClient(inputClient: string): string {
  // First check if it looks like a URL
  if (inputClient.includes('://') || inputClient.startsWith('http')) {
    try {
      const url = new URL(inputClient);
      if (url.hostname === "huggingface.co") {
        const parts = url.pathname.split('/').filter(Boolean);
        // Handle both direct model paths and spaces paths
        if (parts[0] === "spaces" && parts.length > 1) {
          return parts.slice(1).join('/');
        } else if (parts.length >= 2) {
          return parts.join('/');
        }
      }
    } catch (e) {
      console.debug('Input is not a valid URL, proceeding as plain client name');
    }
  }
  
  // Clean up non-URL inputs
  return inputClient.startsWith('/') ? inputClient.slice(1) : inputClient;
}

/**
 * Constructs the base URL for a Gradio space
 * @param client - Client identifier (from fixClient)
 * @returns Full base URL for the space
 */
export function getGradioBaseUrl(client: string): string {
  const fixedClient = fixClient(client);
  return `https://${fixedClient.replace(/\//g, '-')}.hf.space`;
}


==== src/utils/index.ts ====
export function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(' ');
}

export const sleep = (ms: number) => 
  new Promise((r) => setTimeout(r, ms));


==== tailwind.config.ts ====
import type { Config } from "tailwindcss"

const config: Config = {
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {
      // You can keep any custom extensions here if needed
    },
  },
  plugins: [],
}

export default config

==== tmp/gradio_test.ts ====
import { Client } from "@gradio/client";
import fs from 'fs';

interface ComponentInfo {
  label?: string;
  type?: string;
}

interface AppInfo {
  inputs: ComponentInfo[];
  outputs: ComponentInfo[];
  api_info?: Record<string, any>;
}

async function testGradioConnection() {
  try {
    // Replace with your actual Gradio URL
    const gradioUrl = '/fffiloni/KDTalker';
    console.log(`Connecting to Gradio at: ${gradioUrl}`);

    // Connect to Gradio
    const app = await Client.connect(gradioUrl);
    console.log('âœ… Gradio client connected successfully');

    // Get app info - handle Gradio API response
    const appInfo = await app.view_api();
    const formattedInfo: AppInfo = {
      inputs: [],
      outputs: [],
      api_info: appInfo
    };

    // Extract components from API response
    if (appInfo && typeof appInfo === 'object') {
      try {
        // Handle Gradio API response using type assertions
        const apiData = appInfo as any;
        
        // Get inputs/outputs either from root level or nested in api_data
        const possibleInputs = apiData.api_data?.input_components || 
                              apiData.input_components || 
                              [];
        
        const possibleOutputs = apiData.api_data?.output_components || 
                               apiData.output_components || 
                               [];

        formattedInfo.inputs = Array.isArray(possibleInputs)
          ? possibleInputs.map((comp: Record<string, any>) => ({
              label: comp.label || comp.component || '',
              type: comp.type || 'unknown'
            }))
          : [];

        formattedInfo.outputs = Array.isArray(possibleOutputs)
          ? possibleOutputs.map((comp: Record<string, any>) => ({
              label: comp.label || comp.component || '',
              type: comp.type || 'unknown'
            }))
          : [];
      } catch (err) {
        console.warn('Error processing API response:', err);
      }
    }
    
    fs.writeFileSync('tmp/response_app_info.json', JSON.stringify(formattedInfo, null, 2));
    console.log('ðŸ“„ App info saved to tmp/response_app_info.json');

    // Test prediction with sample data
    console.log('Testing prediction endpoint...');
    const result = await app.predict('/predict', {
      source_image: 'path_to_test_image.jpg', // Replace or read from file
      driven_audio: 'path_to_test_audio.wav'  // Replace or read from file
    });

    console.log('Prediction result:', result.data);
  } catch (error: unknown) {
    console.error('âŒ Gradio test failed');
    
    if (error instanceof Error) {
      console.error(error.message);
      // Write detailed error info
      fs.writeFileSync('tmp/error_log.json', 
        JSON.stringify({
          message: error.message,
          stack: error.stack,
          timestamp: new Date().toISOString()
        }, null, 2));
    } else {
      console.error('Unknown error occurred');
      fs.writeFileSync('tmp/error_log.json', 
        JSON.stringify({
          message: 'Unknown error',
          timestamp: new Date().toISOString()
        }, null, 2));
    }
  }
}

testGradioConnection();


==== tmp/playground.ts ====
type OutputItem = {
  key: string;
  type: 'string' | 'number' | 'boolean' | 'array';
  show: boolean;
  title: string;
  format?: string;
  typeItem?: 'string' | 'number' | 'boolean';
  formatItem?: string;
};

type PropertyValue = {
  type: string;
  items?: {
    type: string;
    format?: string;
  };
  title?: string;
  format?: string;
};

const processOutput = (key: string, value: PropertyValue): OutputItem => {

  console.log({key, value});

  let outputItem: OutputItem = {
    key,
    type: value.type as 'string' | 'number' | 'boolean' | 'array',
    show: true,
    title: value.title || key,
  };

  if (value.type === 'array' && value.items) {
    outputItem.typeItem = value.items.type as 'string' | 'number' | 'boolean';
    if (value.items.format) {
      outputItem.formatItem = value.items.format;
    }
  } else if (value.type === 'string' && value.format) {
    outputItem.format = value.format;
  }

  return outputItem;
};

const outputs1: Record<string, PropertyValue> = {
  "output": {
    "type": "array",
    "items": {
      "type": "string"
    }
  }
};

const outputs2: Record<string, PropertyValue> = {
  "output": {
    "type": "array",
    "items": {
      "type": "string",
      "format": "uri"
    },
    "title": "Output"
  }
};

const outputs3: Record<string, PropertyValue> = {
  "output": {
    "type": "array",
    "items": {
      "type": "string"
    },
    "title": "Output"
  }
};

const outputs4: Record<string, PropertyValue> = {
  "output": {
    "type": "string",
    "title": "Output"
  }
};

const testOutputs = (outputs: Record<string, PropertyValue>) => {
  return Object.entries(outputs).map(([key, value]) => processOutput(key, value));
};

// console.log("Test 1:", testOutputs(outputs1));
console.log("Test 2:", testOutputs(outputs2));
// console.log("Test 3:", testOutputs(outputs3));
// console.log("Test 4:", testOutputs(outputs4));

==== tmp/response_app_info.json ====
{
  "named_endpoints": {
      "/process": {
          "parameters": [
              {
                  "label": "Image",
                  "parameter_name": "input_fg",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "Blob | File | Buffer",
                  "python_type": {
                      "type": "filepath",
                      "description": ""
                  },
                  "component": "Image",
                  "example_input": {
                      "path": "https://raw.githubusercontent.com/gradio-app/gradio/main/test/test_files/bus.png",
                      "meta": {
                          "_type": "gradio.FileData"
                      },
                      "orig_name": "bus.png",
                      "url": "https://raw.githubusercontent.com/gradio-app/gradio/main/test/test_files/bus.png"
                  }
              },
              {
                  "label": "Initial Latent",
                  "parameter_name": "bg_source",
                  "parameter_has_default": true,
                  "parameter_default": "None",
                  "type": "string",
                  "python_type": {
                      "type": "Literal['None', 'Left Light', 'Right Light', 'Top Light', 'Bottom Light']",
                      "description": ""
                  },
                  "component": "Radio",
                  "example_input": "None"
              },
              {
                  "label": "Prompt",
                  "parameter_name": "prompt",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox",
                  "example_input": "Hello!!"
              },
              {
                  "label": "Image Width",
                  "parameter_name": "image_width",
                  "parameter_has_default": true,
                  "parameter_default": 896,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 256 and 4096"
                  },
                  "component": "Slider",
                  "example_input": 256,
                  "description": "numeric value between 256 and 4096"
              },
              {
                  "label": "Image Height",
                  "parameter_name": "image_height",
                  "parameter_has_default": true,
                  "parameter_default": 1152,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 256 and 4096"
                  },
                  "component": "Slider",
                  "example_input": 256,
                  "description": "numeric value between 256 and 4096"
              },
              {
                  "label": "Images",
                  "parameter_name": "num_samples",
                  "parameter_has_default": true,
                  "parameter_default": 1,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 1 and 12"
                  },
                  "component": "Slider",
                  "example_input": 1,
                  "description": "numeric value between 1 and 12"
              },
              {
                  "label": "Seed",
                  "parameter_name": "seed",
                  "parameter_has_default": true,
                  "parameter_default": 12345,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": ""
                  },
                  "component": "Number",
                  "example_input": 3
              },
              {
                  "label": "Steps",
                  "parameter_name": "steps",
                  "parameter_has_default": true,
                  "parameter_default": 25,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 1 and 100"
                  },
                  "component": "Slider",
                  "example_input": 1,
                  "description": "numeric value between 1 and 100"
              },
              {
                  "label": "Negative Prompt",
                  "parameter_name": "n_prompt",
                  "parameter_has_default": true,
                  "parameter_default": "",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox",
                  "example_input": "Hello!!"
              },
              {
                  "label": "CFG Scale",
                  "parameter_name": "cfg",
                  "parameter_has_default": true,
                  "parameter_default": 1,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 1.0 and 32.0"
                  },
                  "component": "Slider",
                  "example_input": 1,
                  "description": "numeric value between 1.0 and 32.0"
              },
              {
                  "label": "Distilled CFG Scale",
                  "parameter_name": "gs",
                  "parameter_has_default": true,
                  "parameter_default": 3.5,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 1.0 and 32.0"
                  },
                  "component": "Slider",
                  "example_input": 1,
                  "description": "numeric value between 1.0 and 32.0"
              },
              {
                  "label": "CFG Re-Scale",
                  "parameter_name": "rs",
                  "parameter_has_default": true,
                  "parameter_default": 1,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 0.0 and 1.0"
                  },
                  "component": "Slider",
                  "example_input": 0,
                  "description": "numeric value between 0.0 and 1.0"
              },
              {
                  "label": "Enable HR Fix",
                  "parameter_name": "enable_hr_fix",
                  "parameter_has_default": true,
                  "parameter_default": true,
                  "type": "boolean",
                  "python_type": {
                      "type": "bool",
                      "description": ""
                  },
                  "component": "Checkbox",
                  "example_input": true
              },
              {
                  "label": "HR Fix Down Scale",
                  "parameter_name": "hr_downscale",
                  "parameter_has_default": true,
                  "parameter_default": 0.5,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 0.1 and 1.0"
                  },
                  "component": "Slider",
                  "example_input": 0.1,
                  "description": "numeric value between 0.1 and 1.0"
              },
              {
                  "label": "Low Pass Denoise Strength",
                  "parameter_name": "lowres_denoise",
                  "parameter_has_default": true,
                  "parameter_default": 0.98,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 0.1 and 1.0"
                  },
                  "component": "Slider",
                  "example_input": 0.1,
                  "description": "numeric value between 0.1 and 1.0"
              },
              {
                  "label": "High Pass Denoise Strength",
                  "parameter_name": "highres_denoise",
                  "parameter_has_default": true,
                  "parameter_default": 0.95,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 0.1 and 1.0"
                  },
                  "component": "Slider",
                  "example_input": 0.1,
                  "description": "numeric value between 0.1 and 1.0"
              }
          ],
          "returns": [
              {
                  "label": "Outputs",
                  "type": "",
                  "python_type": {
                      "type": "List[Dict(image: filepath, caption: str | None)]",
                      "description": ""
                  },
                  "component": "Gallery"
              },
              {
                  "label": "Preprocessed Foreground",
                  "type": "string",
                  "python_type": {
                      "type": "filepath",
                      "description": ""
                  },
                  "component": "Image"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      },
      "/update_quick_prompt": {
          "parameters": [
              {
                  "label": "Prefix Quick List",
                  "parameter_name": "p",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Subject Quick List",
                  "parameter_name": "s",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Illumination Environment Quick List",
                  "parameter_name": "i",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Background Quick List",
                  "parameter_name": "b",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "component": "state",
                  "example": null,
                  "parameter_default": null,
                  "parameter_has_default": true,
                  "parameter_name": null,
                  "hidden": true,
                  "type": ""
              }
          ],
          "returns": [
              {
                  "label": "Prompt",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      },
      "/update_quick_prompt_1": {
          "parameters": [
              {
                  "label": "Prefix Quick List",
                  "parameter_name": "p",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Subject Quick List",
                  "parameter_name": "s",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Illumination Environment Quick List",
                  "parameter_name": "i",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Background Quick List",
                  "parameter_name": "b",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "component": "state",
                  "example": null,
                  "parameter_default": null,
                  "parameter_has_default": true,
                  "parameter_name": null,
                  "hidden": true,
                  "type": ""
              }
          ],
          "returns": [
              {
                  "label": "Prompt",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      },
      "/update_quick_prompt_2": {
          "parameters": [
              {
                  "label": "Prefix Quick List",
                  "parameter_name": "p",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Subject Quick List",
                  "parameter_name": "s",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Illumination Environment Quick List",
                  "parameter_name": "i",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Background Quick List",
                  "parameter_name": "b",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "component": "state",
                  "example": null,
                  "parameter_default": null,
                  "parameter_has_default": true,
                  "parameter_name": null,
                  "hidden": true,
                  "type": ""
              }
          ],
          "returns": [
              {
                  "label": "Prompt",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      },
      "/update_quick_prompt_3": {
          "parameters": [
              {
                  "label": "Prefix Quick List",
                  "parameter_name": "p",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Subject Quick List",
                  "parameter_name": "s",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Illumination Environment Quick List",
                  "parameter_name": "i",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Background Quick List",
                  "parameter_name": "b",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "component": "state",
                  "example": null,
                  "parameter_default": null,
                  "parameter_has_default": true,
                  "parameter_name": null,
                  "hidden": true,
                  "type": ""
              }
          ],
          "returns": [
              {
                  "label": "Prompt",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      }
  },
  "unnamed_endpoints": {}
}

==== tmp/test.ts ====
import { Client, handle_file } from "@gradio/client";

const app = await Client.connect("bytedance-research/UNO-FLUX");


const image1 = "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png";
const image2 = "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png";
					
await client.predict(
  "/load_example", {
    example_tuple: 3,
});
						
await client.predict(
  "/gradio_generate", {
    prompt: "The logo is printed on the cup",
    width: 512,
    height: 512,
    guidance: 4,
    num_steps: 25,
    seed: 61733557,
    image_prompt1: {"path":"/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png","url":"https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png","size":None,"orig_name":"ref1.png","mime_type":None,"is_stream":false,"meta":{"_type":"gradio.FileData"}},
    image_prompt2: {"path":"/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png","url":"https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png","size":None,"orig_name":"ref2.png","mime_type":None,"is_stream":false,"meta":{"_type":"gradio.FileData"}},
    image_prompt3: None,
    image_prompt4: None,
});


==== tmp/test2.ts ====
import { Client, handle_file } from "@gradio/client";

const image1 = "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png";
const image2 = "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png";

(async function() {
  const app = await Client.connect("bytedance-research/UNO-FLUX");

})();





          
await client.predict(
  "/load_example", {
    example_tuple: 3,
});
            
await client.predict(
  "/gradio_generate", {
    prompt: "The logo is printed on the cup",
    width: 512,
    height: 512,
    guidance: 4,
    num_steps: 25,
    seed: 61733557,
    image_prompt1: {"path":"/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png","url":"https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png","size":None,"orig_name":"ref1.png","mime_type":None,"is_stream":false,"meta":{"_type":"gradio.FileData"}},
    image_prompt2: {"path":"/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png","url":"https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png","size":None,"orig_name":"ref2.png","mime_type":None,"is_stream":false,"meta":{"_type":"gradio.FileData"}},
    image_prompt3: None,
    image_prompt4: None,
});


==== tmp/test3.ts ====
import { Client, handle_file } from "@gradio/client";


const CLIENT = "bytedance-research/UNO-FLUX";

const IMAGES = [
  "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png",
  "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png"
];



(async function () {
  try {
    // Fetch example images
    const responses = await Promise.all([
      fetch(IMAGES[0]),
      fetch(IMAGES[1])
    ]);
    
    const images = await Promise.all(responses.map(r => r.blob()));

    const endpoint = "/gradio_generate";
    const params = {
      prompt: "The logo is printed on the cup",
      width: 512,
      height: 512,
      guidance: 4,
      num_steps: 25,
      seed: 61733557,
      image_prompt1: handle_file(images[0]),
      image_prompt2: handle_file(images[1]),
    }

    // Connect to client
    const client = await Client.connect(CLIENT);
    
    // Make prediction
    const result = await client.predict(endpoint, params);

    console.log(result.data);
  } catch (error: any) {
    console.error("Error:", error.message);
  }
})();

==== tsconfig.json ====
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



==== public/next.svg ====
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

==== public/vercel.svg ====
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>

==== src/app/ClientSidebarWrapper.tsx ====
"use client";

import { usePathname } from 'next/navigation';
import { ReactNode } from 'react';

type ClientSidebarWrapperProps = {
  children: ReactNode;
};

export default function ClientSidebarWrapper({ children }: ClientSidebarWrapperProps) {
  const pathname = usePathname();
  const showSidebar = !pathname.startsWith('/create');

  if (!showSidebar) {
    return null;
  }

  return <>{children}</>;
}

==== src/app/api/app/[slug]/get/route.ts ====
import { Slug } from '@/types';
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(
  request: Request,
  { params }: { params: { slug: Slug } },
) {
  try {
    const req = await request.json();

    const slug = params.slug;
    // if(slug !== 'freshink' && slug !== 'createVideo') return NextResponse.json(
    //   { error: `Something went wrong, api, slug ${slug} not allowed` },
    //   { status: 500 }
    // );

    const {id} = req;

    console.log('[slug]/get', {id});
  
    if (!id) return NextResponse.json(
        { error: 'not id /api' },
        { status: 500 }
      );
    
    const replicate = new Replicate({
      auth: process.env.REPLICATE_API_TOKEN as string,
    });
  
    const state = await replicate.predictions.get(id);

    // const state = {
    //   id: "wds8qv2e5hrj20chkc8vmp60vc",
    //   status: "succeeded",
    // }
  
    console.log({state});
    return NextResponse.json({ state }, { status: 201 });
  } catch (error: any) {
    console.error("api/app/[]/get " + error.message);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}

==== src/app/api/app/[slug]/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';
import { Slug } from '@/types';
import { Configurations } from "@/types";
import {getConfigurations} from '@/common/configuration';
import { Client, handle_file } from "@gradio/client";

type Status = "successful" | "failed" | "canceled";

const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;
if (!REPLICATE_API_TOKEN) throw Error(`not REPLICATE_API_TOKEN ${REPLICATE_API_TOKEN}`);

export async function POST(
  request: Request,
  { params }: { params: { slug: Slug } },
) {
  const slug = params.slug;

  console.log('Received request for slug:', slug);

  try {
    const configurations = await getConfigurations(true);

    if (!configurations) {
      console.error('No configurations found');
      return NextResponse.json(
        { error: 'No configurations available' },
        { status: 404 }
      );
    }

    console.log('Fetched configurations:', configurations.map(conf => conf.name));

    const config = configurations.find(conf => conf.name === slug);

    if (!config) {
      console.error(`Configuration not found for slug: ${slug}`);
      return NextResponse.json(
        { error: `Configuration not found for slug: ${slug}` },
        { status: 404 }
      );
    }

    console.log('Found configuration:', config.name);

    if (config) {
      const req = await request.json();
      console.log('elseif conf');

      let indImg = 0;

      if (config && config.type === 'replicate') {
        const replicate = new Replicate({
          auth: REPLICATE_API_TOKEN,
        });

        const model: 
          `${string}/${string}` | `${string}/${string}:${string}` | undefined = config.model;

        if (!model || typeof model !== "string") throw Error(`not model found or format issue ${model}`);

        const version = config.version as string | undefined;

        // I need to check how to convert array of object, to object,

        const input: { [key: string]: any } = {};
        
        // TODO -> Make the extraction of the req automatic, define in the fronted, the name related with the config object ...

        // console.log('Request Parameters:', JSON.stringify(req, null, 2));

        let indxImage = 0;
        config.inputs.forEach(item => {
          if (item.key) {
            if(item.show) {
              const {component} = item;
              if (component === 'image') {
                const {image} = req;
                if(!image) return NextResponse.json(
                  { error: 'not image /api' },
                  { status: 500 }
                );
                console.log({image})
                input[item.key] = image[indxImage];
              } else if (component === 'prompt') {
                const {prompt} = req;
                if(!prompt) return NextResponse.json(
                  { error: 'not image /api' },
                  { status: 500 }
                );
                input[item.key] = prompt;
              }
            } else {
              input[item.key] = item.value;
            }
          }
        });

        if(!input) throw Error('api/app/[]/ input is not a object');

        console.log('xxx ->', {model, version , input});
        
        // const output = await replicate.predictions.create({
        //   model,
        //   version,
        //   input,
        // });

        const output = {
          id: "3h1s8zajrxrgp0chr93t8h6svg"
        };
        
        if (!output) {
          console.log(`api/[${slug}] !output`, {output});
          console.log('Something went wrong');
          return NextResponse.json(
            { error: 'Something went wrong, api not response output' },
            { status: 500 }
          );
        }
        
        return NextResponse.json(
          output,
          { status: 201 }
        );
      } else if (config && config.type === 'gradio') {
        const params: Record<string, any> = {};
        let indImg = 0;

        for (const item of config.inputs) {
          if (item.component === 'image') {
            const image = req.image[indImg];
            if (typeof image === 'string' && image.startsWith('data:image/')) {
              params[item.key] = await handle_file(await convertBase64ToBlob(image));
            } else {
              params[item.key] = await handle_file(image);
            }
            indImg++;
          } else if (item.component === 'audio') {
            const audio = req.audio;
            if (typeof audio === 'string' && audio.startsWith('data:audio/')) {
              params[item.key] = await handle_file(await convertBase64ToBlob(audio));
            } else if (audio instanceof Blob) {
              params[item.key] = await handle_file(audio);
            }
          } else {
            params[item.key] = req[item.key] !== undefined ? req[item.key] : item.value;
          }
        }
        const client = config.client;
        const path = config.path;
        const endpoint = config.endpoint as string;
        console.log('Gradio request params:', {
          client,
          endpoint,
          path,
          params: {
            ...params,
            // Hide large binary data from logs
            source_image: params.source_image ? '[Blob data]' : null,
            driven_audio: params.driven_audio ? '[Audio data]' : null 
          }
        })
        let output: any;
        try {
          // 1. Verify connection
          console.log('Connecting to Gradio client:', client);
          const app = await Client.connect(client as string).catch(err => {
            console.error('Gradio connection failed:', err.message);
            throw new Error(`Failed to connect to Gradio client ${client}: ${err.message}`);
          });
          console.log('Gradio client connected:', !!app);

          // Make prediction with detailed error context
          console.log('Running prediction with params:', {
            endpoint: endpoint, // Log the endpoint being used
            params: Object.keys(params),
            // Log types/sizes for debugging potential data issues
            audio_type: params.driven_audio?.type,
            audio_size: params.driven_audio?.size,
            image_type: params.source_image?.type,
            image_size: params.source_image?.size
          });

          console.log('flag before prediction');
          try {
            output = await app.predict(endpoint, params);
            console.log('flag after prediction');
            console.log('Prediction completed:', {
              output_data_type: typeof output?.data,
              output_status: output?.status // Check if output exists
            });
          } catch (predictError: any) {
            console.error('Gradio prediction failed:', {
              endpoint: endpoint,
              params: Object.keys(params), // Show keys, not full data
              error_message: predictError.message,
              error_stack: predictError.stack,
              gradio_app_info: app.config // Log Gradio app config for context
            });
            // Re-throw the original prediction error to be caught by the outer catch
            throw predictError;
          }

        } catch (error: any) {
          // This catches connection, endpoint verification, and prediction errors
          console.error('Full Gradio operation error:', {
            client: client,
            endpoint: config.endpoint, // Log intended endpoint
            error_message: error.message,
            error_stack: error.stack,
            // Avoid logging potentially large params again if it was a prediction error
            ...(error instanceof Error && !error.message.includes('prediction failed') && { params: Object.keys(params) })
          });
          // Throw a consistent error format
          throw new Error(`Gradio operation failed for ${client}: ${error.message}`);
        }


        console.log('Final Gradio output object:', {output}); // Log the final output object structure
        if (!output) {
          console.log('Something went wrong');
          return NextResponse.json(
            { error: 'Something went wrong' },
            { status: 500 }
          );
        }
        
        return NextResponse.json({
          status: 'succeeded',
          output: output.data
        }, { status: 201 });
      }
    } else if (slug !== 'freshink' 
        && slug !== 'createVideo'
        && slug !== "hairStyle"
        && slug !== "livePortrait"
        && slug !== "upscaler"
        && slug !== 'tryon')
    {
      return NextResponse.json(
        { error: `Something went wrong, api, slug ${slug} not found` },
        { status: 500 }
      );
    }

    const req = await request.json();

    const {sheme} = getModel({slug});

    Object.entries(sheme.input).forEach((item) => {
      if(item[1] === 'image') {
        const {image} = req;
        if(!image) return NextResponse.json(
          { error: 'not image /api' },
          { status: 500 }
        );
        (sheme.input as any)[item[0]] = image;
      } else if (item[1] === 'video') {
        const {video} = req;
        if(!video) return NextResponse.json(
          { error: 'not video req /api' },
          { status: 500 }
        );
        (sheme.input as any)[item[0]] = video;
        // (sheme.input as any)[item[0]] = "https://replicate.delivery/pbxt/LEQxLFMUNZMiKt5PWjyMJIbTdvKAb5j3f0spuiEwt9TEbo8B/d0.mp4";
      } else if(item[1] === 'prompt') {
        const {prompt} = req;
        if(!prompt) return NextResponse.json(
          { error: 'not prompt /api' },
          { status: 500 }
        );
        (sheme.input as any)[item[0]] = prompt;
      }
    })
    
    const replicate = new Replicate({
      auth: REPLICATE_API_TOKEN,
    });
  
    const model: 
      `${string}/${string}` | `${string}/${string}:${string}` | undefined = sheme?.model;
  
    if(!model || typeof model !== "string") throw Error(`not model found or format issue ${model}`);

    const version: string | undefined = sheme.version;
    if(!version) throw Error('api/app/[]/ version not found');
  
    const input = sheme?.input;
    if(!input) throw Error('api/app/[]/ input is not a object');

    console.log('xxx ->', {model, version , input});


    const output = await replicate.predictions.create({
      model,
      version,
      input,
    });

    // const output = {
    //   id: "87h588fapdrgg0cgmgftvtz87r"
    // };


    console.log({output});
    if (!output) {
      console.log('Something went wrong');
      return NextResponse.json(
        { error: 'Something went wrong' },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      output,
      { status: 201 }
    );
  } catch (error: any) {
    // console.error("api/app/[] general error" + JSON.stringify(error.message, null, 2));
    console.error("api/app/[] general error" + error.message);
    console.error("api/app/[] general error" + error.stack);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}

function getModel({slug}: {slug: string}) {
  let sheme;
  let model: `${string}/${string}` | `${string}/${string}:${string}`;

  console.log({slug});

  switch (slug) {
    case 'freshink':
      model = "fofr/sdxl-fresh-ink:8515c238222fa529763ec99b4ba1fa9d32ab5d6ebc82b4281de99e4dbdcec943";
      sheme = {
        model: model,
        input: {
          width: 1024,
          height: 1024,
          prompt: "A fresh ink TOK tattoo",
          refine: "expert_ensemble_refiner",
          scheduler: "K_EULER",
          lora_scale: 0.6,
          num_outputs: 1,
          guidance_scale: 7.5,
          apply_watermark: false,
          high_noise_frac: 0.9,
          negative_prompt: "ugly, broken, distorted",
          prompt_strength: 0.8,
          num_inference_steps: 25
        }
      }
      break;
    case 'createVideo':
      model = "chenxwh/diffsynth-exvideo:b3b0e929bf918153fbc0c5444fbe215f5cdbdbdf610910cf4dfcb6f6006e4783";
      sheme = {
        model,
        input: {
          prompt: "prompt",
          num_frames: 128,
          negative_prompt: "é”™è¯¯çš„çœ¼ç›ï¼Œç³Ÿç³•çš„äººè„¸ï¼Œæ¯å®¹ï¼Œç³Ÿç³•çš„è‰ºæœ¯ï¼Œå˜å½¢ï¼Œå¤šä½™çš„è‚¢ä½“ï¼Œæ¨¡ç³Šçš„é¢œè‰²ï¼Œæ¨¡ç³Šï¼Œé‡å¤ï¼Œç—…æ€ï¼Œæ®‹ç¼ºï¼Œ",
          num_inference_steps: 25,
          num_inference_steps_upscale_video: 25
        }
      }
      break;
    case 'upscaler':
      model = "philz1337x/clarity-upscaler:dfad41707589d68ecdccd1dfa600d55a208f9310748e44bfe35b4a6291453d5e";
      sheme = {
        model,
        input: {
          seed: 1337,
          image: "image",
          prompt: "masterpiece, best quality, highres, <lora:more_details:0.5> <lora:SDXLrender_v2.0:1>",
          dynamic: 6,
          handfix: "disabled",
          pattern: false,
          sharpen: 0,
          sd_model: "juggernaut_reborn.safetensors [338b85bc4f]",
          scheduler: "DPM++ 3M SDE Karras",
          creativity: 0.35,
          lora_links: "",
          downscaling: false,
          resemblance: 0.6,
          scale_factor: 2,
          tiling_width: 112,
          output_format: "png",
          tiling_height: 144,
          custom_sd_model: "",
          negative_prompt: "(worst quality, low quality, normal quality:2) JuggernautNegative-neg",
          num_inference_steps: 18,
          downscaling_resolution: 768
        }
      }
      break;
    case 'hairStyle':
      model = "orpatashnik/styleclip:7af9a66f36f97fee2fece7dcc927551a951f0022cbdd23747b9212f23fc17021";
      sheme = {
        model,
        version: "7af9a66f36f97fee2fece7dcc927551a951f0022cbdd23747b9212f23fc17021",
        input: {
          input: "image",
          target: "prompt",
          neutral: "a face",
          manipulation_strength: 4.1,
          disentanglement_threshold: 0.15
        },
      }
      break;
    case 'livePortrait':
      model = "fofr/live-portrait:067dd98cc3e5cb396c4a9efb4bba3eec6c4a9d271211325c477518fc6485e146";
      const version = "067dd98cc3e5cb396c4a9efb4bba3eec6c4a9d271211325c477518fc6485e146";
      sheme = {
        model,
        version,
        input: {
          face_image: "image",
          driving_video: "video",
          live_portrait_dsize: 512,
          live_portrait_scale: 2.3,
          video_frame_load_cap: 128,
          live_portrait_lip_zero: true,
          live_portrait_relative: true,
          live_portrait_vx_ratio: 0,
          live_portrait_vy_ratio: -0.12,
          live_portrait_stitching: true,
          video_select_every_n_frames: 1,
          live_portrait_eye_retargeting: false,
          live_portrait_lip_retargeting: false,
          live_portrait_lip_retargeting_multiplier: 1,
          live_portrait_eyes_retargeting_multiplier: 1
        }
      }
      break;
    // case 'tryon':

    //   break;
    default:
      throw Error('slug not found');
      break;
  }

  return {sheme};
}

async function convertBase64ToBlob(base64: string): Promise<Blob> {
  const response = await fetch(base64);
  return await response.blob();
}


==== src/app/api/create/fetch-model-details/route.ts ====
import { NextResponse } from 'next/server';
import { Client, handle_file } from "@gradio/client";
import { InputItem, OutputItem } from '@/types';

export async function POST(request: Request) {
  const { type, client, model, version } = await request.json();
  
  try {
    if (type === 'replicte') {
      const response = await fetch(`https://api.replicate.com/v1/models/${model}/versions/${version}`, {
        headers: {
          'Authorization': `Token ${process.env.REPLICATE_API_TOKEN}`,
          'Content-Type': 'application/json',
        },
      });
  
      if (!response.ok) {
        throw new Error('Failed to fetch model details');
      }
  
      const data = await response.json();
      
      const inputs = data.openapi_schema.components.schemas.Input.properties;
      const outputs = data.openapi_schema.components.schemas.Output;
      const required = data.openapi_schema.components.schemas.Input.required;
  
      return NextResponse.json({ inputs, outputs, required });
    } else if (type === 'gradio') {
      console.log('flag1', {client});
      
      const fixedClient = fixClient(client);
      let app = await Client.connect(String(fixedClient));

      console.log({'client': fixedClient, app: !!app});
      
      const app_info = await app.view_api();
      console.log({view_api: app_info});
      console.log(JSON.stringify(app_info, null, 2));
      
      const convertResult = await convertToIO({app_info, app, client: fixedClient});
      if (!convertResult) {
        throw new Error('Failed to convert to IO');
      }
      const { formattedEndpoints, api_info } = convertResult;

      return NextResponse.json({ formattedEndpoints, api_info, view_api: !!app_info }, { status: 200 });
    } else if (type === 'huggingface') { } 
    else if (type === 'fal') {
      const response = await fetch(`https://api.fal.ai/v1/models/${model}/versions/${version}`, {
        headers: {
          'Authorization': `Token ${
            process.env.FAL_API_TOKEN
          }`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch model details');
      }

      const data = await response.json();

      const inputs = data.openapi_schema.components.schemas.Input.properties;
      const outputs = data.openapi_schema.components.schemas.Output;
      const required = data.openapi_schema.components.schemas.Input.required;

      return NextResponse.json({ inputs, outputs, required });
    }
  } catch (error: any) {
    console.error('Error fetching model details:', error.message);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

function fixClient(inputClient: string): string {
  // First check if it looks like a URL
  if (inputClient.includes('://') || inputClient.startsWith('http')) {
    try {
      const url = new URL(inputClient);
      if (url.hostname === "huggingface.co") {
        const parts = url.pathname.split('/').filter(Boolean);
        // Handle both direct model paths and spaces paths
        if (parts[0] === "spaces" && parts.length > 1) {
          return parts.slice(1).join('/');
        } else if (parts.length >= 2) {
          return parts.join('/');
        }
      }
    } catch (e) {
      console.debug('Input is not a valid URL, proceeding as plain client name');
    }
  }
  
  // Clean up non-URL inputs
  return inputClient.startsWith('/') ? inputClient.slice(1) : inputClient;
}

// Define FormattedEndpoint type
interface FormattedEndpoint {
  key: string;
  inputs: Partial<InputItem>[];
  outputs: Partial<OutputItem>[];
}

// Simplified type for the app config
interface AppConfig {
  app_reference: string;
  config: {
    components: Array<{
      id: number;
      type: string;
      props: {
        label?: string;
        value?: any;
        [key: string]: any;
      };
      api_info: {
        type: string;
        items?: { type: string; enum?: string[] };
        properties?: { path: { type: string } };
        description?: string;
      };
    }>;
    dependencies: Array<{
      id: number;
      api_name: string;
      inputs: number[];
      outputs: number[];
    }>;
  };
}

/**
 * Maps Gradio component type to InputItem.component or OutputItem.component
 */
function mapComponent(type: string): InputItem['component'] | OutputItem['component'] {
  const lowerType = type.toLowerCase();
  switch (lowerType) {
    case 'textbox': return 'Textbox';
    case 'dropdown': return 'dropdown';
    case 'slider': return 'slider';
    case 'checkbox': return 'checkbox';
    case 'audio': return 'audio';
    case 'number': return 'number';
    case 'checkboxgroup': return 'checkboxgroup';
    default: return 'Textbox'; // Fallback for inputs
  }
}

/**
 * Maps Gradio api_info.type to InputItem.type or OutputItem.type
 */
function mapType(apiInfo: any): InputItem['type'] | OutputItem['type'] {
  if (apiInfo.type === 'boolean') return 'boolean';
  if (apiInfo.type === 'number') return 'integer'; // Map "number" to "integer" for InputItem
  if (apiInfo.type === 'string') return 'string';
  if (apiInfo.type === 'array') return 'array';
  if (apiInfo.type === 'object' && apiInfo.properties?.path) return 'string'; // FileData as string
  return 'string'; // Fallback
}

/**
 * Formats endpoints from /gradio_api/info or view_api() response
 */
function formatEndpointsFromApiInfo(apiInfo: any): FormattedEndpoint[] {
  const formattedEndpoints: FormattedEndpoint[] = [];
  const { named_endpoints } = apiInfo;

  for (const [key, valueObject] of Object.entries(named_endpoints)) {
    const inputs: InputItem[] = (valueObject as any).parameters.map((item: any) => ({
      key: item.parameter_name,
      component: mapComponent(item.component) as InputItem['component'],
      type: mapType(item.type) as InputItem['type'],
      label: item.label || item.parameter_name,
      value: item.parameter_default,
      description: item.type?.description || item.python_type?.description || undefined,
      show: true,
      required: !item.parameter_has_default,
    }));

    const outputs: OutputItem[] = (valueObject as any).returns.map((item: any, index: number) => ({
      key: item.label ? item.label.toLowerCase().replace(/\s+/g, '_') : `output_${index}`,
      component: mapComponent(item.component) as OutputItem['component'],
      type: mapType(item.type) as OutputItem['type'],
      title: item.label || `Output ${index}`,
      show: true,
      formatItem: item.python_type?.type,
    }));

    formattedEndpoints.push({ key, inputs, outputs });
  }

  return formattedEndpoints;
}

/**
 * Constructs the Gradio Space API URL from client string
 */
function constructAppRoot(client: string): string {
  const spaceName = client.toLowerCase().replace('/', '-');
  return `https://${spaceName}.hf.space`;
}

function formatEndpointsFromConfig(appConfig: AppConfig): FormattedEndpoint[] {
  const { config } = appConfig;

  const componentMap = new Map<number, AppConfig["config"]["components"][0]>();
  config.components.forEach(comp => componentMap.set(comp.id, comp));

  const generateKey = (label: string | undefined, index: number): string => {
    if (!label) return `param_${index}`;
    return label.toLowerCase().replace(/\s+/g, "_").replace(/[^a-z0-9_]/g, "");
  };

  const formattedEndpoints: FormattedEndpoint[] = [];

  config.dependencies
    .filter(dep => dep.api_name)
    .forEach(dep => {
      const endpointPath = `/${dep.api_name}`;

      // Format inputs
      const inputs: InputItem[] = dep.inputs.map((id, index) => {
        const comp = componentMap.get(id);
        if (!comp) {
          console.warn(`Component ID ${id} not found`);
          return {
            key: `param_${index}`,
            component: 'Textbox',
            type: 'string',
            label: `Input ${id}`,
            value: null,
            show: true,
          };
        }

        const { type: componentType, props, api_info } = comp;
        const label = props.label || `Input ${id}`;
        const value = 'value' in props ? props.value : null;

        return {
          key: generateKey(props.label, index),
          component: mapComponent(componentType) as InputItem['component'],
          type: mapType(api_info) as InputItem['type'],
          label,
          value,
          description: api_info.description || undefined,
          show: true,
        };
      });

      // Format outputs
      const outputs: OutputItem[] = dep.outputs.map((id, index) => {
        const comp = componentMap.get(id);
        if (!comp) {
          console.warn(`Component ID ${id} not found`);
          return {
            key: `output_${index}`,
            component: 'number',
            type: 'number',
            title: `Output ${id}`,
            show: true,
          };
        }

        const { type: componentType, props, api_info } = comp;
        const title = props.label || `Output ${id}`;

        return {
          key: generateKey(props.label, index),
          component: mapComponent(componentType) as OutputItem['component'],
          type: mapType(api_info) as OutputItem['type'],
          title,
          show: true,
          formatItem: api_info.type,
        };
      });

      formattedEndpoints.push({
        key: endpointPath,
        inputs,
        outputs,
      });
    });

  return formattedEndpoints;
}

/**
 * Converts Gradio API info or app config into formatted endpoints with multiple fallbacks
 */
interface ConvertToIOResponse {
  formattedEndpoints: FormattedEndpoint[] | null;
  api_info:{
    api: any;
    source: string;
  };
}
async function convertToIO({ app_info, app, client }: { app_info: any; app?: any, client: string }): Promise<ConvertToIOResponse | null> {
  const appRoot = app?.config?.root || constructAppRoot(client);
  console.log('convertToIO', {appRoot});
  const apiUrlInfo = `${appRoot}/info`;
  const apiUrlGradioAPI = `${appRoot}/gradio_api/info`;

  const responseInfo = await fetch(`${appRoot}/info`);
  const apiInfo = await responseInfo.json();

  console.log('flag0', {apiInfo, ok: responseInfo.ok});


  
  if (appRoot) {
    try {
      console.log(`Fetching ${apiUrlInfo}`);
      const response = await fetch(apiUrlInfo);
      console.log('flag2', {response});
      if (response.ok) {
        const apiInfo = await response.json();
        console.log('flag4', {apiInfo});
        if (apiInfo.named_endpoints && Object.keys(apiInfo.named_endpoints).length > 0) {
          console.log("Using /gradio_api/info data");
          return {
            formattedEndpoints: formatEndpointsFromApiInfo(apiInfo), 
            api_info: {
              api: apiInfo, 
              source: "/info"
            }
          };
        }
      } else {
        const response = await fetch(`${appRoot}/gradio_api/info`);
        if (response.ok) {
          const apiGradioApiInfo = await response.json();
          console.log('flag6', {apiGradioApiInfo});
          if (apiGradioApiInfo.named_endpoints && Object.keys(apiGradioApiInfo.named_endpoints).length > 0) {
            return {
              formattedEndpoints: formatEndpointsFromApiInfo(apiGradioApiInfo),
              api_info: {
                api: apiGradioApiInfo,
                source: "/gradio_api/info"
              }
            };
          }
        }

        
      }
    } catch (error: any) {
      console.log(`xxx Fetching ${apiUrlInfo}`);
      const response = await fetch(apiUrlGradioAPI);
      console.log('flag3', {response});
      if (response.ok) {
        const apiInfo = await response.json();
        console.log('flag5', {apiInfo});
        if (apiInfo.named_endpoints && Object.keys(apiInfo.named_endpoints).length > 0) {
          console.log("Using /info data");
          return {
            formattedEndpoints: formatEndpointsFromApiInfo(apiInfo),
            api_info: {
              api: apiInfo, 
              source: "/gradio_api/info"
            }
          };
        }
      }
    }
  }

  // Fallback to app_info from view_api()
  if (app_info && app_info.named_endpoints && Object.keys(app_info.named_endpoints).length > 0) {
    console.log("Falling back to app.view_api() data");
    return {
      formattedEndpoints: formatEndpointsFromApiInfo(app_info),
      api_info: {
        api: app_info, 
        source: "app_info"
      }
    };
  }

  // Final fallback to app.config
  if (app && app.config) {
    console.log("Falling back to app.config");
    return {
      formattedEndpoints: formatEndpointsFromConfig(app as AppConfig), 
      api_info: {
        api: app.config,
        source: "app_config"
      }};
  }

  console.log("No valid data source available");
  return null;
}


==== src/app/api/create/get/route.ts ====
import { NextResponse } from 'next/server';
import clientPromise from '@/lib/mongodb';
import { MongoClient } from 'mongodb';

export async function GET() {
  try {
    const client = await clientPromise;
    const { collection } = await validateMongoDBConnection(client);
    
    const fetchedApps = await collection.find({});
    const apps = await fetchedApps.toArray();

    console.log('Fetched apps:', apps);

    return NextResponse.json(apps, { status: 200 });
  } catch (error: any) {
    console.error('Error in GET /api/create/get:', error);
    return NextResponse.json({ message: 'Error fetching app configurations', error: error.message }, { status: 500 });
  }
}

async function validateMongoDBConnection(client: MongoClient) {
  const dbName = process.env.MONGODB_DB_NAME;
  const collectionName = process.env.MONGODB_COLLECTION_NAME;

  if (!dbName || !collectionName) {
    throw new Error('MONGODB_DB_NAME and MONGODB_COLLECTION_NAME must be set in environment variables');
  }
  
  const database = client.db(dbName);
  const collection = database.collection(collectionName);

  // Verify the database exists, create it if it doesn't
  const dbList = await client.db().admin().listDatabases();
  const dbExists = dbList.databases.some(db => db.name === dbName);
  if (!dbExists) {
    await client.db(dbName).createCollection('temp');
    console.log(`Created "${dbName}" database`);
    await client.db(dbName).dropCollection('temp');
  }

  // Verify the collection exists, create it if it doesn't
  const collections = await database.listCollections({ name: collectionName }).toArray();
  if (collections.length === 0) {
    await database.createCollection(collectionName);
    console.log(`Created "${collectionName}" collection`);
  }

  return { database, collection };
}


==== src/app/api/create/route.ts ====
import { NextResponse } from 'next/server';
import clientPromise from '@/lib/mongodb';
import { MongoClient } from 'mongodb';


export async function POST(request: Request) {
  try {
    const client = await clientPromise;
    const body = await request.json();
    
    const { collection } = await validateMongoDBConnection(client);

    const documentToInsert = {
      ...body,
      createdAt: new Date()
    };

    // Transform keys to strings
    const transformedDocument = Object.fromEntries(
      Object.entries(documentToInsert).map(([key, value]) => [String(key), value])
    );

    const result = await collection.insertOne(transformedDocument);

    return NextResponse.json({ message: 'App configuration created', id: result.insertedId }, { status: 201 });
  } catch (error: any) {
    console.error('Error in POST /api/create-app:', error);
    return NextResponse.json({ message: 'Error creating app configuration', error: error.message }, { status: 500 });
  }
}

async function validateMongoDBConnection(client: MongoClient) {
  const dbName = process.env.MONGODB_DB_NAME;
  const collectionName = process.env.MONGODB_COLLECTION_NAME;

  if (!dbName || !collectionName) {
    throw new Error('MONGODB_DB_NAME and MONGODB_COLLECTION_NAME must be set in environment variables');
  }
  
  const database = client.db(dbName);
  const collection = database.collection(collectionName);

  // Verify the database exists
  const dbList = await client.db().admin().listDatabases();
  const dbExists = dbList.databases.some(db => db.name === dbName);
  if (!dbExists) {
    throw new Error(`Database "${dbName}" does not exist`);
  }

  // Verify the collection exists
  const collections = await database.listCollections({ name: collectionName }).toArray();
  if (collections.length === 0) {
    throw new Error(`Collection "${collectionName}" does not exist`);
  }

  return { database, collection };
}

==== src/app/api/enhancebg/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  // 1. Get request data (in JSON format) from the client
  const req = await request.json();

  const {image, prompt} = req;

  if(!image || !prompt) return NextResponse.json(
      { error: 'not image or prompt /api' },
      { status: 500 }
    );
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    "dhanushreddy291/photo-background-generation:1db5ee211d65558d3fd11fc60bc00073f300d7a3a0b5abbfafbd20239ac58d2f";

  const input = {
    image,
    prompt,
    num_outputs: 1,
    negative_prompt: "3d, cgi, render, bad quality, normal quality",
    num_inference_steps: 30,
    controlnet_conditioning_scale: 1
  };

  const output = await replicate.run(model, { input });

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/experimental/sse/init/route.ts ====
import { NextResponse } from 'next/server';
import { getGradioBaseUrl } from '@/utils/gradio';

// Helper function to determine the correct API path
async function getGradioApiPath(client: string, endpoint: string): Promise<string> {
  const baseUrl = getGradioBaseUrl(client);

  // Try fetching /info to determine the path structure
  try {
    const infoResponse = await fetch(`${baseUrl}/info`);
    if (infoResponse.ok) {
      const infoData = await infoResponse.json();
      const cleanEndpoint = endpoint.startsWith('/') ? endpoint.slice(1) : endpoint;
      if (infoData?.named_endpoints?.[cleanEndpoint]) {
        console.log(`Using /call/${cleanEndpoint} based on /info`);
        return `${baseUrl}/call/${cleanEndpoint}`;
      }
    }
  } catch (e) {
    console.warn("Failed to fetch /info, falling back to /gradio_api/call");
  }

      // Fallback path - ensure no double slashes
      const cleanEndpoint = endpoint.startsWith('/') ? endpoint.slice(1) : endpoint;
      console.log(`Using fallback /gradio_api/call/${cleanEndpoint}`);
      return `${baseUrl}/gradio_api/call/${cleanEndpoint}`;
}
// https://Yuanshi-OminiControl_Art.hf.space/gradio_api/call/infer

    export async function POST(request: Request) {
      try {
        const { client, endpoint, inputs } = await request.json();

        if (!client || !endpoint || !inputs) {
          return NextResponse.json({ error: 'Missing client, endpoint, or inputs' }, { status: 400 });
        }

        const apiPath = await getGradioApiPath(client, endpoint);

        // Prepare headers, including HF token if available
        const headers: HeadersInit = { "Content-Type": "application/json" };
        if (process.env.HF_TOKEN) {
          headers["Authorization"] = `Bearer ${process.env.HF_TOKEN}`;
        }

        console.log(`Initiating prediction via POST to: ${apiPath}`);
        const response = await fetch(apiPath, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify({ data: inputs }) // Send inputs in the 'data' field
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`Gradio POST failed (${response.status}): ${errorText}`);
          return NextResponse.json({ error: `Gradio API request failed: ${errorText}` }, { status: response.status });
        }

        const responseData = await response.json();
        console.log("Gradio POST response:", responseData);

        if (!responseData.event_id) {
           return NextResponse.json({ error: 'Gradio did not return an event_id' }, { status: 500 });
        }

        // Return only the event_id and the client info needed for the stream request
        return NextResponse.json({ event_id: responseData.event_id, client });

      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error during SSE init';
        console.error("SSE Init Error:", errorMessage);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
      }
    }


==== src/app/api/experimental/sse/stream/route.ts ====
import { NextRequest } from 'next/server';
import { getGradioBaseUrl } from '@/utils/gradio';

export const dynamic = 'force-dynamic'; // Ensure dynamic execution

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const eventId = searchParams.get('event_id');
  const client = searchParams.get('client');
  const endpoint = searchParams.get('endpoint');

  if (!eventId || !client || !endpoint) {
    return new Response('Missing event_id, client, or endpoint', { status: 400 });
  }

  const baseUrl = getGradioBaseUrl(client);
  const cleanEndpoint = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint;
  const streamUrl = `${baseUrl}/call/${cleanEndpoint}/${eventId}`;

  console.log(`Attempting to stream from: ${streamUrl}`);

  try {
    const headers: HeadersInit = {};
    if (process.env.HF_TOKEN) {
      headers["Authorization"] = `Bearer ${process.env.HF_TOKEN}`;
    }

    const gradioResponse = await fetch(streamUrl, {
      method: 'GET',
      headers: headers,
      // @ts-ignore - Necessary for streaming
      duplex: 'half'
    });

    if (!gradioResponse.ok) {
      const errorText = await gradioResponse.text();
      console.error(`Gradio SSE request failed (${gradioResponse.status}): ${errorText}`);
      const errorEvent = `event: error_event\ndata: ${JSON.stringify(`Gradio request failed: ${gradioResponse.status}`)}\n\n`;
      return new Response(errorEvent, { status: 200, headers: { 'Content-Type': 'text/event-stream' } });
    }

    if (!gradioResponse.body) {
      throw new Error('Gradio response body is null');
    }

    const reader = gradioResponse.body.getReader();
    const stream = new ReadableStream({
      async start(controller) {
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            controller.enqueue(value);
          }
        } catch (error) {
          console.error("SSE Stream Error:", error);
          controller.error(error);
        } finally {
          controller.close();
          reader.releaseLock();
        }
      },
      cancel() {
        reader.cancel();
      }
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error("SSE Stream Error:", errorMessage);
    const errorEvent = `event: error_event\ndata: ${JSON.stringify(errorMessage)}\n\n`;
    return new Response(errorEvent, { status: 200, headers: { 'Content-Type': 'text/event-stream' } });
  }
}


==== src/app/api/illuminai/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  const req = await request.json();

  const {image, prompt, source} = req;

  console.log('/api', {image, prompt, source});

  if(!image || !prompt || !source) {
    return NextResponse.json(
      { error: 'not image, prompt or source /api' },
      { status: 500 }
    );
  }
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    "zsxkib/ic-light:d41bcb10d8c159868f4cfbd7c6a2ca01484f7d39e4613419d5952c61562f1ba7";

  const input = {
    cfg: 2,
    steps: 25,
    width: 512,
    height: 640,
    prompt: prompt,
    light_source: "Left Light",
    highres_scale: 1.5,
    output_format: "webp",
    subject_image: image,
    lowres_denoise: 0.9,
    output_quality: 80,
    appended_prompt: "best quality",
    highres_denoise: 0.5,
    negative_prompt: "lowres, bad anatomy, bad hands, cropped, worst quality, dark",
    number_of_images: 1
  }

  let output: any | null = null;

  try {
    output = await replicate.run(model, { input });
  } catch (error: any) {
    console.log('illuminai /api', {error});
    return NextResponse.json(
      { error: `Something went wrong, ${error.message}` },
      { status: 500 }
    );
  }

  
  
  // const output = [
  //   "https://replicate.delivery/pbxt/DCiXOO8IjXKeM6ecacI0hP7jEBfHX5uYt3a0bf85dNNYBwHMB/generated_0.webp"
  // ]

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/inter-design/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  const req = await request.json();

  const image = req.image;
  const theme = req.theme;
  const room = req.room;

  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    'jagilley/controlnet-hough:854e8727697a057c525cdb45ab037f64ecca770a1769cc52287c2e56472a247b';

  const input = {
    image,
    prompt: `A ${theme} ${room} Editorial Style Photo, Symmetry, Straight On, Modern Living Room, Large Window, Leather, Glass, Metal, Wood Paneling, Neutral Palette, Ikea, Natural Light, Apartment, Afternoon, Serene, Contemporary, 4k`,
    a_prompt: `best quality, extremely detailed, photo from Pinterest, interior, cinematic photo, ultra-detailed, ultra-realistic, award-winning`,
  };

  const output = await replicate.run(model, { input });

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/preview/get/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;
if (!REPLICATE_API_TOKEN) throw Error('REPLICATE_API_TOKEN not found');

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    
    if (!id) {
      return NextResponse.json(
        { error: 'Prediction ID is required' },
        { status: 400 }
      );
    }

    // For Gradio results (which are immediate)
    if (id.startsWith('gradio_')) {
      return NextResponse.json({
        status: 'succeeded',
        output: null // Output was already returned in the POST response
      });
    }

    // For Replicate results
    const replicate = new Replicate({
      auth: REPLICATE_API_TOKEN!,
    });

    const prediction = await replicate.predictions.get(id);
    
    return NextResponse.json({
      status: prediction.status,
      output: prediction.output,
    });
  } catch (error: any) {
    console.error('Error checking prediction status:', error);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}


==== src/app/api/preview/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';
import { Client, handle_file } from "@gradio/client";

const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;
if (!REPLICATE_API_TOKEN) throw Error('REPLICATE_API_TOKEN not found');

async function convertBase64ToBlob(base64: string): Promise<Blob> {
  const response = await fetch(base64);
  return await response.blob();
}

interface ConfigInput {
  key: string;
  component: string;
  show?: boolean;
  value?: any;
}

interface PreviewConfig {
  type: 'replicate' | 'gradio';
  model?: string;
  version?: string;
  client?: string;
  path?: string;
  inputs: ConfigInput[];
  endpoint?: string;
}

export async function POST(request: Request) {
  console.log('Preview POST request received');
  try {
    const { config, params } = await request.json();
    console.log('Preview request:', { config, params });

    if (!config) {
      return NextResponse.json(
        { error: 'Configuration is required' },
        { status: 400 }
      );
    }

    // Handle Replicate models
    if (config.type === 'replicate') {
      const replicate = new Replicate({
        auth: REPLICATE_API_TOKEN,
      });

      if (!config.model || typeof config.model !== 'string') {
        throw new Error('Model identifier is required for Replicate models');
      }

      if (!config.version) {
        throw new Error('Model version is required for Replicate models');
      }

      // Process inputs according to configuration
      const input: { [key: string]: any } = {};
      const typedConfig = config as PreviewConfig;
      typedConfig.inputs.forEach((item: ConfigInput) => {
        if (item.show) {
          switch (item.component) {
            case 'image':
              if (params.image && params.image[item.key]) {
                input[item.key] = params.image[item.key];
              }
              break;
            case 'prompt':
              input[item.key] = params[item.key];
              break;
            case 'textbox':
              input[item.key] = params[item.key];
              break;
            default:
              input[item.key] = params[item.key];
          }
        } else if (item.value !== undefined) {
          // Use default value for hidden inputs
          input[item.key] = item.value;
        }
      });

      console.log('Replicate input:', input);

      const prediction = await replicate.predictions.create({
        model: typedConfig.model as `${string}/${string}`,
        version: typedConfig.version,
        input,
      });

      console.log('Replicate prediction started:', prediction);

      return NextResponse.json({ 
        id: prediction.id,
        status: prediction.status
      }, { status: 201 });
    }
    // Handle Gradio models
    else if (config.type === 'gradio') {
      const typedConfig = config as PreviewConfig;
      if (!typedConfig.client || !typedConfig.path || !typedConfig.endpoint) {
        throw new Error('Client and path are required for Gradio models');
      }

      const processedParams: Record<string, any> = {};

      // Process each input
      for (const item of typedConfig.inputs) {
        const input = item as ConfigInput;
        
        if (!input.show) {
          if (input.value !== undefined) {
            processedParams[input.key] = input.value;
          }
          continue;
        }

        switch (input.component) {
          case 'image': {
            const image = params.image && params.image[input.key];
            if (image) {
              if (typeof image === 'string' && image.startsWith('data:image/')) {
                processedParams[input.key] = await handle_file(await convertBase64ToBlob(image));
              } else {
                processedParams[input.key] = await handle_file(image);
              }
            }
            break;
          }
          case 'textbox':
            processedParams[input.key] = params[input.key];
            break;
          case 'prompt':
            processedParams[input.key] = params[input.key];
            break;
          default:
            processedParams[input.key] = params[input.key] !== undefined ? params[input.key] : input.value;
            break;
        }
      }

      console.log('Gradio params:', {processedParams, typedConfig});

      let app;

      try {
        app = await Client.connect(typedConfig.client!);
        console.log('app:', {path: typedConfig.client, processedParams});
      } catch (error:any) {
        throw new Error(`Error connecting app to Gradio client: ${error.message}`);
      }
      console.log('Gradio app connected:', !!app);

      let result;

      // Validate parameters
      if (!processedParams || typeof processedParams !== 'object') {
        throw new Error('Invalid parameters for prediction');
      }

      const predictParams = {
        endpoint: typedConfig.endpoint,
        data: processedParams,
      }
      console.log('Gradio predict params:', predictParams);
      
      try {
        // Get API info to validate endpoint and parameters
        // const apiInfo = await app.view_api();
        
        // if (!apiInfo.named_endpoints[typedConfig.endpoint]) {
        //   console.error('Available endpoints:', apiInfo.named_endpoints);
        //   // TODO we need to manage the alternative
        //   throw new Error(`Endpoint ${typedConfig.endpoint} not found in app`);
        // }
        // console.log('after apiInfo:');

        // const endpointInfo = apiInfo.named_endpoints[typedConfig.endpoint];
        // const requiredParams = endpointInfo.parameters
        //   ? endpointInfo.parameters
        //       .filter((p: any) => !p.parameter_has_default)
        //       .map((p: any) => p.parameter_name)
        //   : [];

        // const missingParams = requiredParams.filter(
        //   (param: string) => processedParams[param] === undefined
        // );
        
        // if (missingParams.length > 0) {
        //   throw new Error(`Missing required parameters: ${missingParams.join(', ')}`);
        // }

        // Log detailed parameter info before prediction
        console.log('Final prediction parameters:', {
          endpoint: typedConfig.endpoint,
          params: processedParams,
          paramTypes: Object.entries(processedParams).map(([k, v]) => ({
            param: k,
            type: typeof v,
            value: v
          }))
        });

        // Prepare final prediction parameters
        const predictionParams = {...processedParams};

        // Convert image Blobs directly to base64 strings
        if (predictionParams.input_fg instanceof Blob) {
          const arrayBuffer = await predictionParams.input_fg.arrayBuffer();
          const base64String = Buffer.from(arrayBuffer).toString('base64');
          predictionParams.input_fg = `data:image/png;base64,${base64String}`; 
        }
        if (predictionParams.scribble_map instanceof Blob) {
          const arrayBuffer = await predictionParams.scribble_map.arrayBuffer();
          const base64String = Buffer.from(arrayBuffer).toString('base64');
          predictionParams.scribble_map = `data:image/png;base64,${base64String}`; 
        }

        // Log the final parameters being sent
        console.log('Final prediction parameters (base64 converted):', {
          endpoint: typedConfig.endpoint,
          params: predictionParams,
          paramTypes: Object.entries(predictionParams).map(([k, v]) => ({
            param: k,
            type: typeof v,
            value: typeof v === 'string' && v.length > 100 ? v.substring(0, 100) + '...' : v
          }))
        });

        try {
          result = await app.predict(typedConfig.endpoint, predictionParams);
        } catch (error: any) {
          console.error('Detailed prediction error:', {
            error: error.message,
            stack: error.stack,
            endpoint: typedConfig.endpoint,
            params: processedParams,
            paramTypes: Object.entries(processedParams).map(([k, v]) => ({
              param: k,
              type: typeof v,
              value: v
            }))
          });
          throw new Error(`Prediction failed for endpoint ${typedConfig.endpoint}: ${error.message}`);
        }
      } catch (error: any) {
        console.error('Detailed prediction error:', {
          error: error.message,
          stack: error.stack,
          endpoint: typedConfig.endpoint,
          params: processedParams
        });
        throw new Error(`Prediction failed: ${error.message}`);
      }

      console.log('Gradio result:', JSON.stringify(result, null, 2));

      if (!result) {
        throw new Error('Gradio model returned no output');
      }

      return NextResponse.json({
        status: 'succeeded',
        output: result.data
      }, { status: 201 });
    }

    throw new Error('Unsupported model type');
  } catch (error: any) {
    console.error('Error in preview:', error);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    if (!id) {
      return NextResponse.json(
        { error: 'Prediction ID is required' },
        { status: 400 }
      );
    }
    
    // For Gradio results (which are immediate)
    if (id.startsWith('gradio_')) {
      return NextResponse.json({
        status: 'succeeded',
        output: null // Output was already returned in the POST response
      });
    }
    
    // For Replicate results
    const replicate = new Replicate({
      auth: REPLICATE_API_TOKEN!,
    });
    
    const prediction = await replicate.predictions.get(id);
    console.log('Replicate prediction status:', prediction);
    
    return NextResponse.json({
      status: prediction.status,
      output: prediction.output,
    });
  } catch (error: any) {
    console.error('Error checking prediction status:', error);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}


==== src/app/api/removebg/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  // 1. Get request data (in JSON format) from the client
  const req = await request.json();

  const {image} = req;

  if(!image) return NextResponse.json(
      { error: 'not image or prompt /api' },
      { status: 500 }
    );
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    "smoretalk/rembg-enhance:4067ee2a58f6c161d434a9c077cfa012820b8e076efa2772aa171e26557da919";

  const model2 =
    "codeplugtech/background_remover:37ff2aa89897c0de4a140a3d50969dc62b663ea467e1e2bde18008e3d3731b2b";

  const input = {
    image
  };

  const output = await replicate.run(model2, { input });

  // const output = "https://replicate.delivery/pbxt/P9oH8knhkOqvAlGPiLI72IwWs8OJ65u7uIZc1wOqkiOa4dwE/out.png"

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('route', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/simpson/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  // 1. Get request data (in JSON format) from the client
  const req = await request.json();

  const {image, prompt} = req;

  if(!image || !prompt) return NextResponse.json(
      { error: 'not image or prompt /api' },
      { status: 500 }
    );
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const modelS =
    "fofr/sdxl-simpsons-characters:f4d36a72b43ea2fd511cab0afb32539955ee5b28b65c8e3fb7d8abd254be8e91";

  const model = 
    "fofr/pulid-base:65ea75658bf120abbbdacab07e89e78a74a6a1b1f504349f4c4e3b01a655ee7a";

  // const input = {
  //   width: 1024,
  //   height: 1024,
  //   prompt: prompt,
  //   refine: "expert_ensemble_refiner",
  //   scheduler: "K_EULER",
  //   lora_scale: 0.6,
  //   num_outputs: 1,
  //   guidance_scale: 7.5,
  //   apply_watermark: false,
  //   high_noise_frac: 0.8,
  //   negative_prompt: "ugly, broken, distorted, artefacts, 3D, render, photography",
  //   prompt_strength: 0.8,
  //   num_inference_steps: 30
  // }

  const input = {
    width: 1024,
    height: 1024,
    prompt: prompt,
    face_image: image,
    face_style: "high-fidelity",
    output_format: "webp",
    output_quality: 80,
    negative_prompt: "boy",
    checkpoint_model: "animated - starlightXLAnimated_v3",
    number_of_images: 1
  }
  

  const output = await replicate.run(model, { input });

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/api/upscale/route.ts ====
import { NextResponse } from 'next/server';
import Replicate from 'replicate';

export async function POST(request: Request) {
  const req = await request.json();

  const {image} = req;

  // console.log('/api', {image});

  if(!image) {
    return NextResponse.json(
      { error: 'not image /api' },
      { status: 500 }
    );
  }
  
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN as string,
  });

  const model =
    "philz1337x/clarity-upscaler:dfad41707589d68ecdccd1dfa600d55a208f9310748e44bfe35b4a6291453d5e";
  
  const input = {
    seed: 1337,
    image: image,
    prompt: "masterpiece, best quality, highres, <lora:more_details:0.5> <lora:SDXLrender_v2.0:1>",
    dynamic: 6,
    handfix: "disabled",
    pattern: false,
    sharpen: 0,
    sd_model: "juggernaut_reborn.safetensors [338b85bc4f]",
    scheduler: "DPM++ 3M SDE Karras",
    creativity: 0.35,
    lora_links: "",
    downscaling: false,
    resemblance: 0.6,
    scale_factor: 2,
    tiling_width: 112,
    output_format: "png",
    tiling_height: 144,
    custom_sd_model: "",
    negative_prompt: "(worst quality, low quality, normal quality:2) JuggernautNegative-neg",
    num_inference_steps: 18,
    downscaling_resolution: 768
  }

  let output: any | null = null;

  try {
    output = await replicate.run(model, { input });
  } catch (error: any) {
    console.log({error});
    return NextResponse.json(
      { error: `Something went wrong, ${error.message}` },
      { status: 500 }
    );
  }

  if (!output) {
    console.log('Something went wrong');
    return NextResponse.json(
      { error: 'Something went wrong' },
      { status: 500 }
    );
  }

  console.log('Output', output);
  return NextResponse.json({ output }, { status: 201 });
}


==== src/app/app/[slug]/ClientPage.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState, useEffect, useCallback } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon, FaceSmileIcon, VideoCameraIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu";
import { Configuration, ImageAreaProps, InputItem, OutputItem } from "@/types";
import { sleep } from "@/utils";
import { Prompt } from "@/components/prompt";
import { Slider, Checkbox, CheckboxGroup, NumberInput, NumberOutput } from "@/components/numericInput";
import { AudioOutput } from "@/components/audioOutput";
import { TextOutput } from "@/components/textOutput";
import { useRouter } from 'next/navigation';
import { notFound } from 'next/navigation';
import { getConfigurations } from '@/common/configuration';

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type UploadedVideoProps = {
  video: File;
  removeVideo(): void;
  file: {
    name: string;
    size: string;
  };
};

type UploadedAudioProps = {
  audio: File;
  audioUrl: string | null;
  removeAudio(): void;
  file: {
    name: string;
    size: string;
  };
};

function UploadedAudio({ audio, audioUrl, removeAudio, file }: UploadedAudioProps) {
  return (
    <div className="p-4 bg-gray-800 rounded-md mb-4">
      <p className="text-sm text-gray-300">
        Audio ready: {file.name} ({file.size})
      </p>
      {audioUrl && (
        <audio 
          src={audioUrl} 
          controls
          className="mt-2 w-full"
        />
      )}
      <button
        onClick={removeAudio}
        className="mt-2 text-red-400 hover:text-red-300 text-sm"
      >
        Remove Audio
      </button>
    </div>
  );
}

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const sources = ["None", "Left Light", "Right Light", "Bottom Light", "Top Light"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const acceptedVideoTypes = {
  "video/*": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB
const maxVideoSize = 100 * 1024 * 1024; // 100MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a room and let our AI generate a new design.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full m-3">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black z-10"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedVideoProps} props The component props
 */
function UploadedVideo({ file, video, removeVideo }: UploadedVideoProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <video
          src={URL.createObjectURL(video)}
          className="h-full w-full object-cover"
          controls
          autoPlay
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black z-10"
        onClick={removeVideo}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[], id: number): void;
  }
) {
  return (
    <Dropzone
      onDrop={(acceptedFiles, rejectedFiles) => props.onImageDrop(acceptedFiles, rejectedFiles, props.id as number)}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function AudioDropzone(
  props: ImageAreaProps & {
    onAudioDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
    onRecordAudio(blob: Blob): void;
  }
) {
  const [isRecording, setIsRecording] = useState(false);
  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);
  const [audioChunks, setAudioChunks] = useState<Blob[]>([]);
  const [permissionStatus, setPermissionStatus] = useState<'prompt'|'granted'|'denied'>('prompt');
  const [permissionError, setPermissionError] = useState<string|null>(null);

  const checkPermission = async () => {
    try {
      const permissionResult = await navigator.permissions.query({ name: 'microphone' as PermissionName });
      setPermissionStatus(permissionResult.state as 'granted'|'denied');
      permissionResult.onchange = () => {
        setPermissionStatus(permissionResult.state as 'granted'|'denied');
      };
    } catch (err) {
      console.warn('Permission API not supported, falling back to direct request');
    }
  };

  const startRecording = async () => {
    try {
      if (permissionStatus === 'denied') {
        setPermissionError('Microphone access was previously denied. Please update permissions in your browser settings.');
        return;
      }

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
        .catch(err => {
          if (err.name === 'NotAllowedError') {
            setPermissionStatus('denied');
            setPermissionError('Microphone access is required for recording. Please allow microphone access and try again.');
          }
          throw err;
        });

      setPermissionStatus('granted');
      setPermissionError(null);
      const recorder = new MediaRecorder(stream);
      setMediaRecorder(recorder);
      
      recorder.ondataavailable = (e) => {
        setAudioChunks(prev => [...prev, e.data]);
      };
      
      recorder.onstop = () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        props.onRecordAudio(audioBlob);
        stream.getTracks().forEach(track => track.stop());
      };
      
      recorder.start();
      setIsRecording(true);
      setAudioChunks([]);
    } catch (err) {
      console.error('Error starting recording:', err);
    }
  };

  const stopRecording = () => {
    if (mediaRecorder) {
      mediaRecorder.stop();
      setIsRecording(false);
    }
  };

  return (
    <div className="space-y-4">
      <Dropzone
        onDrop={props.onAudioDrop}
        accept={{
          "audio/*": [".mp3", ".wav"],
        }}
        maxSize={100 * 1024 * 1024} // 100MB
        multiple={false}
      >
        {({ getRootProps, getInputProps }) => (
          <>
            <input {...getInputProps()} />
            <button
              {...getRootProps()}
              type="button"
              className="relative block minh-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
            >
              <props.icon className="mx-auto h-12 w-12 text-gray-400" />
              <span className="mt-2 block text-sm font-semibold text-gray-300">
                {props.title}
              </span>
            </button>
          </>
        )}
      </Dropzone>
      
      <div className="flex justify-center gap-4">
        <button
          type="button"
          onClick={isRecording ? stopRecording : startRecording}
          className={`px-4 py-2 rounded-md ${
            isRecording 
              ? 'bg-red-500 hover:bg-red-600' 
              : 'bg-green-500 hover:bg-green-600'
          } text-white`}
        >
          {isRecording ? 'Stop Recording' : 'Record Audio'}
        </button>
      </div>
    </div>
  );
}

function VideoDropzone(
  props: ImageAreaProps & {
    onVideoDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onVideoDrop}
      accept={{
        "video/*": [".mp4"],
      }}
      maxSize={maxVideoSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

interface ModelInput {
  prompt: boolean;
  image: number;
  video: boolean;
  select: boolean;
}

interface ModelOutput {
  image: boolean;
  video: boolean;
}

interface Model {
  input: ModelInput;
  output: ModelOutput;
}

function layout({slug}: {slug: string}): { model: Model } {
  let model: Model = {
    input: {
      prompt: false,
      image: 0,
      video: false,
      select: false,
    },
    output: {
      image: false,
      video: false,
    }
  }

  switch(slug) {
    case "createVideo":
      model.input.prompt = model.output.video = true;
      break;
    case "upscaler":
      model.input.image = 1;
      model.output.image = true;
      break;
    case "hairStyle":
      model.input.image = 1;
      model.output.image 
        = model.input.prompt
        = true;
      break;
    case "livePortrait":
      model.input.image = 1;
      model.input.video = true;
      model.output.video = true;
      break;
    default:
      break;
  }

  return {model};
}

type Slug = "createVideo" | "freshink" | "hairStyle" | "upscaler" | "livePortrait" | 'tryon' | 'logo' | 'EVF-SAM';
type Status = "starting" | "processing" | "succeeded" | "failed" | "canceled";
/**
 * Display the home page
 */
export default function ClientPage({ slug, initialConfigurations }: { slug: Slug, initialConfigurations: Configuration[] }) {
  const [loading, setLoading] = useState(true);
  const [retryCount, setRetryCount] = useState(0);
  const [config, setConfig] = useState<Configuration | null>(null);
  const [outputImage, setOutputImage] = useState<string[] | null>(null);
  const [base64Images, setBase64Images] = useState<string[]>([]);
  const [outputVideo, setOutputVideo] = useState<string | null>(null);
  const [base64Video, setBase64Video] = useState<string | null>(null);
  const [source, setSource] = useState<string>(sources[0]);
  const [prompt, setPrompt] = useState<string | null>(null);
  const [error, setError] = useState<string | null>("");
  const [files, setFiles] = useState<File[]>([]);
  const [video, setVideo] = useState<File | null>(null);
  const [audio, setAudio] = useState<File | null>(null);
  const [base64Audio, setBase64Audio] = useState<string | null>(null);

  const handleRecordedAudio = (blob: Blob) => {
    const audioFile = new File([blob], 'recording.wav', { type: 'audio/wav' });
    setAudio(audioFile);
    console.log('Audio file set:', audioFile.name, audioFile.size);
    
    const reader = new FileReader();
    reader.readAsDataURL(blob);
    reader.onload = () => {
      const result = reader.result as string;
      setBase64Audio(result);
      console.log('Recorded audio converted to base64:', result.substring(0, 50) + '...');
      console.log('Audio state updated - audio:', audioFile, 'base64:', !!result);
    };
  };

  const fetchConfig = useCallback(async () => {
    const configurations = await getConfigurations();
    const foundConfig = configurations.find(conf => conf.name === slug);
    if (foundConfig) {
      setConfig(foundConfig);
      setLoading(false);
    } else if (retryCount < 2) {
      setTimeout(() => {
        setRetryCount(prev => prev + 1);
      }, 1000);
    } else {
      setLoading(false);
    }
  }, [slug, retryCount]);

  useEffect(() => {
    fetchConfig();
  }, [fetchConfig]);

  useEffect(() => {
    if (!loading && !config) {
      window.location.reload();
    }
  }, [loading, config]);

  if (loading) {
    return <div>Loading... Attempt {retryCount + 1} of 3</div>;
  }

  if (!config) {
    return notFound();
  }

  console.log({config});

  const {model} = layout({slug});
  
  let contImg = 0;

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[],
    id: number,
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError(`Please upload a PNG or JPEG image less than ${maxFileSize}MB.`);
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFiles((prevFiles) => ({ ...prevFiles, [id]: acceptedFiles[0] }));

    // Convert to base64
    convertImageToBase64(acceptedFiles[0], id);
  }

  function onAudioDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError(`Please upload an MP3 or WAV file less than 100MB.`);
      return;
    }

    setAudio(null);
    console.info(acceptedFiles);
    setError("");
    setAudio(acceptedFiles[0]);

    // Convert to base64
    const reader = new FileReader();
    reader.readAsDataURL(acceptedFiles[0]);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Audio(binaryStr);
    };
  }

  function onVideoDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError(`Please upload a MP4 video less than ${maxVideoSize}MB.`);
      return;
    }

    removeVideo();

    console.info(acceptedFiles);
    setError("");
    setVideo(acceptedFiles[0]);

    // Convert to base64
    convertVideoToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File, id: number): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Images(prevImg => ({...prevImg, [id]: binaryStr}));
    };
  }

  function convertVideoToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Video(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(id?: number): void {
    // setFiles((prevFiles) => ({ ...prevFiles, [id]: null }));
    setOutputImage(null);
  }

  /**
   * Remove the uploaded video
   * @returns void
   */
  function removeVideo(): void {
    setVideo(null);
    setOutputVideo(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    if (outputImage && Array.isArray(outputImage) && outputImage.length > 0) {
      saveAs(outputImage[0], "output.png"); // Use the first image in the array
    }
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage({slug}: {slug: Slug}): Promise<void> {
    const params: any = { 
      prompt, 
      image: base64Images, 
      video: base64Video,
      audio: base64Audio 
    };
    
    if (config?.inputs) {
      let imgI = 0;
      for (const [key, value] of Object.entries(config.inputs)) {
        if (value.show) {
          const {component} = value;
          if (component === 'image') {
            if(!params[component][imgI]) {
              alert(`must to fill the ${component} ${imgI}`)
              return;
            }
            imgI++;
          } else if(params[component]) {
            console.log(`${component} ${imgI} filled`);
          } else {
            alert(`must to fill the ${component}`)
            // return;
          }
        }
      }
    }
    
    for (const [key, value] of Object.entries(model.input)) {
      if (value) {
        if (typeof value === 'number') {
          for(let i= 0; i < value ;i++) {
            if (params[key][i]) { 
              console.log('Ok', {key, i});
            } else {
              console.log('alert', key, params[key]);
              setError(`Must fill the field ${key} ${value}`);
              return; // Exit the function early
            }
          }
        } else {
          if (params[key]) {
            console.log('Ok', key);
          } else {
            console.log('alert', key, params[key]);
            setError(`Must fill the field ${key}`);
            return;
          }
        }
      }
    }

    setLoading(true);

    let prediction: any;

    if (slug === 'EVF-SAM') {
      if(!prompt) {
        alert('Please upload the files.');
        return;
      }
      if (initialConfigurations) {
        const evfSamConfig = initialConfigurations.find(conf => conf.name === 'EVF-SAM');
        if (evfSamConfig) {
          const formData = new FormData();
          formData.append(evfSamConfig.inputs[0].key, files[0]);
          formData.append(evfSamConfig.inputs[1].key, prompt);

          console.log('flag1', {formData});

          const response = await fetch(`/api/app/${slug}`, {
            method: "POST",
            body: formData,
          });
          if (response.status !== 201) {
            console.log('err ', {response})
            setError("error");
            setLoading(false);
            return;
          }
          console.log('flag2');
          
          const responseJSON = await response.json();
          console.log('flag3', {responseJSON})

          console.log({responseJSON});
          
          prediction = {
            state: {
              output: responseJSON[0].url,
            }
          }
        }
      }
    } else {
      let response: any;
      let result: any;
      let status: Status | null = null;


      console.log('clientPagw', {params});

      const genA = await fetch(`/api/app/${slug}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(params),
      });

      if (!genA.ok) {
        setError(genA.statusText);
        setLoading(false);
        return;
      }
      
      const responseData = await genA.json();

      console.log({responseData});
  
      const id = responseData.id;
      

      if (id) {
        do {
          await sleep(1_000);
          response = await fetch(`/api/app/${slug}/get`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ id }),
          });
          result = await response.json();
          
          if (result.error) {
            setError(result.error);
            setLoading(false);
            return;
          }
    
          status = result.state.status;
    
          console.log({status});
        } while (status !== 'succeeded' && status !== 'failed');
        if (status === 'failed') throw Error("status failed");
      } else {
        // Handle Gradio format if present
        if (Array.isArray(responseData) && responseData[0]?.url) {
          // Extract just the URLs from the Gradio response objects
          const urls = responseData.map(item => item.url);
          result = {
            status: 'succeeded',
            output: urls
          };
          console.log('array and url',{result});
        } else {
          result = {
            status: 'succeeded',
            output: responseData.output
          };
        }
      }
      
      prediction = result;
      console.log('Final prediction:', prediction);
    }
    
    
    if (config && config.outputs) {
      console.log({outputs: config.outputs});
      config.outputs.forEach((item: OutputItem) => {
        const {component} = item; // Change 'type' to 'component'
        console.log({prediction});
        const out = prediction?.state?.output || prediction.output;
        console.log({out});
        if (component === 'image') { // Update the condition to check 'component'
          if (Array.isArray(out)) { // Check if output is an array)
            const urls = out.map((item) => item.url);
            if (urls.length > 0) {
              setOutputImage(urls); // Set the entire array
            } else {
              setOutputImage(out);
            }
          } else if (typeof out === 'string') {
            setOutputImage([out]); // Wrap single string in an array
          } else {
            console.error('Invalid output format');
            throw Error('Invalid output format');
          }
        } else if (component === 'video') {
          if (config?.outputs && config.outputs.length > 0) {
            const key = config.outputs[0].key;
            setOutputVideo(out[key]);
          } else {
            console.error('Invalid key');
            throw Error('Invalid key');
          }
        }
      })
    }

    if(model.output.video) {
      console.log({prediction});
      const videox = prediction.state.output ? prediction.state.output[0] : null;
      console.log({videox})
      setOutputVideo(videox);
    } else if(model.output.image) {
      // Handle Gradio format if present
      if (Array.isArray(prediction.output) && prediction.output[0]?.url) {
        setOutputImage([prediction.output[0].url]);
      } else {
        setOutputImage(prediction.output[0]);
      }
    }

    setLoading(false);
  }
  
  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={() => submitImage({slug})} />
      
      <div className="flex flex-row">
        <div className="flex flex-col w-1/2">
          <h1 className="mx-auto">Input</h1>
          <section className="mx-4 mt-9 flex flex-col space-y-8 lg:mx-6 gap-4 lg:space-x-8 lg:space-y-0 xl:mx-8">
            {config?.inputs.map((item: InputItem, index: number) => {
              if (('show' in item) && item['show']) {
                const { component } = item;
                switch (component.toLowerCase()) {
                  case 'image':
                    const Img = !files[contImg] ?
                      (<ImageDropzone
                        key={index}
                        id={contImg}
                        title={`Drag 'n drop your image here or click to upload`}
                        onImageDrop={onImageDrop}
                        icon={slug === 'hairStyle' ? FaceSmileIcon : PhotoIcon}
                      />)
                      :
                      (<UploadedImage
                        key={index}
                        image={files[contImg]}
                        removeImage={() => removeImage(contImg)}
                        file={{ name: files[contImg].name, size: fileSize(files[contImg].size) }}
                      />)
                    contImg += 1;
                    return Img;
                  case 'prompt':
                    return(
                      <Prompt
                        key={index}
                        label={item.label as string}
                        placeholder={item.placeholder as string} 
                        description={item.description as string}
                        placeholderTextArea={item.value as string}
                        setPrompt={setPrompt}
                      />)
                  case 'textbox':
                    return(
                      <Prompt
                        key={index}
                        label={item.label as string}
                        placeholder={item.placeholder as string} 
                        description={item.description as string}
                        placeholderTextArea={item.value as string}
                        setPrompt={setPrompt}
                      />)
                  case 'number':
                    return (
                      <NumberInput
                        key={index}
                        label={item.label as string || 'Value'}
                        description={item.description as string}
                        min={Number(item.min) || 0}
                        max={Number(item.max) || 100}
                        step={Number(item.step) || 1}
                        defaultValue={Number(item.value) || 50}
                        onChange={(value) => setPrompt(value.toString())}
                      />
                    )
                  case 'slider':
                    return (
                      <Slider
                        key={index}
                        label={item.label as string}
                        description={item.description as string}
                        min={item.min as number || 0}
                        max={item.max as number || 100}
                        step={item.step as number || 1}
                        defaultValue={item.value as number || 50}
                        onChange={(value) => setPrompt(value.toString())}
                      />
                    )
                  case 'checkbox':
                    return (
                      <Checkbox
                        key={index}
                        label={item.label as string}
                        description={item.description as string}
                        defaultChecked={item.value as boolean}
                        onChange={(checked) => setPrompt(checked.toString())}
                      />
                    )
                  case 'checkboxgroup':
                    return (
                      <CheckboxGroup
                        key={index}
                        label={item.label as string}
                        description={item.description as string}
                        options={item.options as string[] || []}
                        defaultSelected={(item.value as string[]) || []}
                        onChange={(selected) => setPrompt(JSON.stringify(selected))}
                      />
                    )
                  case 'dropdown':
                    return (
                      <SelectMenu
                        key={index}
                        label={item.label as string}
                        options={item.options as string[] || []}
                        selected={(item.value as string) || (item.options as string[])?.[0] || ''}
                        onChange={(value) => setPrompt(value)}
                      />
                    )
                  case 'audio':
                    return !audio ? (
                      <AudioDropzone
                        key={index}
                        title={`Drag 'n drop your audio here or click to upload`}
                        onAudioDrop={onAudioDrop}
                        onRecordAudio={handleRecordedAudio}
                        icon={VideoCameraIcon}
                      />
                    ) : (
                      <UploadedAudio
                        audio={audio}
                        audioUrl={base64Audio}
                        removeAudio={() => {
                          setAudio(null);
                          setBase64Audio(null);
                        }}
                        file={{
                          name: audio.name,
                          size: fileSize(audio.size)
                        }}
                      />
                    )
                  default:
                    return <div>no supported {item.key} type {component}</div>;
                }
              }
            })}
            {model.input.prompt && 
              <div className="w-80">
                <label className="block text-sm font-medium leading-6 text-gray-300">
                  Prompt,
                  <br/>
                  {slug === 'freshink' ? 
                    ("describe the tatto you want to create")
                      : slug === 'createVideo'
                        ? "describe the video you want to create"
                        : "describe the hair style"
                  }
                </label>
                <textarea
                  className="mt-2 w-full border bg-slate-800 text-sm text-gray-300 leading-6 text-left pl-3 py-1 rounded-md"
                  placeholder={
                    slug === 'freshink' ? 
                      ("A fresh ink TOK tattoo") 
                        : slug === 'createVideo' 
                          ? "bonfire, on the stone"
                          : "a face with a bowlcut"
                    }
                  onChange={(e) => setPrompt(e.target.value)}
                />
              </div>
            }
            {model.input.select && <SelectMenu
                label="Light Source"
                options={sources}
                selected={source}
                onChange={setSource}
              />
            }
            {
              Array.from({ length: model.input.image }).map((_, index) => (
                !files[index] ? (
                  <ImageDropzone 
                    key={index}
                    id={index}
                    title={`Drag 'n drop your image here or click to upload`}
                    onImageDrop={onImageDrop}
                    icon={slug === 'hairStyle' ? FaceSmileIcon : PhotoIcon}
                  />
                ) : (
                  <UploadedImage
                    key={index}
                    image={files[index]}
                    removeImage={() => removeImage(index)}
                    file={{ name: files[index].name, size: fileSize(files[index].size) }}
                  />
                )
              ))
            }

            {model.input.video && (
              !video ? (
                <VideoDropzone
                  title={`Drag 'n drop your video here or click to upload`}
                  onVideoDrop={onVideoDrop}
                  icon={VideoCameraIcon}
                />
              ) : (
                <UploadedVideo
                  video={video}
                  removeVideo={removeVideo}
                  file={{ name: video.name, size: fileSize(video.size) }}
                />
              )
            )}
          </section>
        </div>

        <div className="flex flex-col w-1/2">
          <h1 className="mx-auto">Output</h1>
          <section className="mx-4 mt-9 flex flex-col gap-4">
            {config && config.outputs && config.outputs.map((item: OutputItem, index: number) => {
              if (('show' in item) && item['show']) {
                if (item.type === 'array' && item.format === 'uri') {
                  // Check if outputImage is an array and has items
                  if (Array.isArray(outputImage) && outputImage.length > 0) {
                    return (
                      <div key={index} className="flex flex-col">
                        {outputImage.map((imgUri, imgIndex) => (
                          <ImageOutput
                            key={imgIndex}
                            title={item.title || 'Output'}
                            downloadOutputImage={downloadOutputImage}
                            outputImage={imgUri} // Use each URI for the ImageOutput
                            icon={SparklesIcon}
                            loading={loading}
                          />
                        ))}
                      </div>
                    );
                  } else {
                    // Show a placeholder or loading state before generation
                    return (
                      <ImageOutput
                        key={index}
                        title={item.title || 'Output'}
                        downloadOutputImage={downloadOutputImage}
                        outputImage={null} // Placeholder before generation
                        icon={SparklesIcon}
                        loading={loading}
                      />
                    );
                  }
                }

                switch (item.component.toLowerCase()) {
                  case 'image':
                    return <ImageOutput
                      key={index}
                      title={item.placeholder as string}
                      downloadOutputImage={downloadOutputImage}
                      outputImage={Array.isArray(outputImage) ? outputImage[0] : outputImage} // Ensure outputImage is a string or null
                      icon={SparklesIcon}
                      loading={loading}
                    />
                  case 'video':
                    return <video
                      key={index}
                      src={outputVideo as string}
                      width="520"
                      height="340"
                      controls
                      autoPlay
                      className="h-full w-full object-cover"
                    >
                      Your browser does not support the video tag.
                    </video>
                  case 'audio':
                    return (
                      <AudioOutput
                        key={index}
                        title={item.title || 'Audio Output'}
                        audioUrl={item.value as string || null}
                      />
                    )
                  case 'number':
                    return (
                      <NumberOutput
                        key={index}
                        title={item.title || 'Numeric Output'}
                        value={item.value || null}
                      />
                    )
                  case 'textbox':
                    return (
                      <TextOutput
                        key={index}
                        title={item.title}
                        placeholder={item.placeholder}
                        value={item.value}
                      />
                    )
                  default:
                    return <div>no supported {item.component} type</div>;
                }
              }
            })}

            {model.output.image && (
              <ImageOutput
                title={`AI-generated output goes here`}
                downloadOutputImage={downloadOutputImage}
                outputImage={Array.isArray(outputImage) ? outputImage[0] : outputImage} // Ensure outputImage is a string or null
                icon={SparklesIcon}
                loading={loading}
              />
            )}
            {model.output.video && (
              <video
                src={outputVideo as string}
                width="520"
                height="340"
                controls
                autoPlay
                className="h-full w-full object-cover"
              >
                Your browser does not support the video tag.
              </video>
            )}
          </section>
        </div>
      </div>
    </main>
  );
}


==== src/app/app/[slug]/page.tsx ====
import { Suspense } from 'react';
import { notFound } from 'next/navigation';
import ClientPage from './ClientPage';
import { Slug } from '@/types';
import {getConfigurations} from '@/common/configuration';


export default async function Page({ params }: { params: { slug: Slug } }) {
  const configurations = await getConfigurations();

  if (!configurations) {
    return notFound();
  }

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ClientPage slug={params.slug} initialConfigurations={configurations} />
    </Suspense>
  );
}

==== src/app/chat/[slug]/page.tsx ====
"use client"
import {PaperAirplaneIcon, XCircleIcon} from '@heroicons/react/24/outline';
import ReactMarkdown from 'react-markdown';

import { useEffect, useState } from "react"

type ErrorNotificationProps = {
  errorMessage: string;
};


function PageNotFound() {
  return (<div className="w-full h-screen text-white flex justify-center items-center">
    <div className="mx-auto ">
      404 Page not found
    </div>
  </div>)
}

function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

type Slug = "dates" | "trip" | "viral";
function isSlug(value: string): value is Slug {
  return value === "dates" || value === "trip" || value === "viral";
}
export default function Home({ params }: { params: { slug: Slug } }) {
  const [isValidSlug, setIsValidSlug] = useState<boolean>(false);
  const [question, setQuestion] = useState<string>("questions");
  const [answer, setAnswer] = useState<string>('');
  const [plan, setPlan] = useState("");
  const [start, setStart] = useState(false);
  const [sessionId, setSessionId] = useState<string>();
  const [error, setError] = useState<string | null>("");

  useEffect(() => {
    if (isSlug(params.slug)) setIsValidSlug(true);
    else setIsValidSlug(false);
  },[params.slug]);

  if (!isValidSlug) return <PageNotFound />;

  const BASE_URL_CHAT = process.env.BASE_URL_CHAT_AGENT_PY;
  if(!BASE_URL_CHAT) throw Error('not BASE_URL_CHAT ...');

  async function handleStart() {
    try {
      const res = await fetch(BASE_URL_CHAT + '/start_flow', {
        method: 'POST',
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({slug: params.slug}),
      });
  
      const { session_id, question} = await res.json();

      console.log({session_id});

      if(!session_id && !question) throw Error('no session_id, or question');

      setSessionId(session_id);
      setQuestion(question);
      setStart(true);
    } catch (error: any) {
      console.error(error.message);
      setError(`${error.message}`);
    }
  }

  async function handleAnswer() {
    if(!answer) {
      alert('please answer the question ...');
      return;
    }
    try {
      const params = {
        answer,
      }

      const response = await fetch(BASE_URL_CHAT+'/answer'+`/${sessionId}`,{
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(params),
      });
      
      const {next_question, trip_plan} = await response.json();

      console.log({next_question});

      if(next_question) {
        setAnswer('');
        setQuestion(next_question);
      } else if(trip_plan) {
        console.log({trip_plan});
        setPlan(trip_plan);
      } else {
        throw Error('no next_question or trip_plan');
      }
    } catch (error: any) {
      console.error(error.message);
    }
  }

  return (
    <div className="lg:pl-72 flex flex-col min-h-screen justify-center">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      {start && <div className="mx-auto flex flex-col gap-2">
        <label htmlFor="answer">{question}</label>
        <textarea name="anwer" id="answer" className="bg-inherit border"
          onChange={(e) => setAnswer(e.target.value)} 
          value={answer}
        />
        <button className="border flex flex-row justify-center gap-2 p-1 items-center hover:bg-blue-950"
          onClick={handleAnswer}
        >
          Send 
          <PaperAirplaneIcon className="h-5 w-5 shrink-0" />
        </button>
      </div>}
      {!start && 
        <div className='mx-auto'>
          <button 
          className="border flex flex-row min-w-[200px] justify-center gap-2 p-2 items-center hover:bg-blue-950"
          onClick={handleStart}
          >
            {params.slug}
            <PaperAirplaneIcon className="h-5 w-5 shrink-0" />
          </button>
        </div>
      }
      {plan && <div className='mx-auto p-6 border rounded '>
        <ReactMarkdown>{plan}</ReactMarkdown>
      </div>}
    </div>
  )
}

==== src/app/create/list/page.tsx ====
'use client';

import { useEffect, useState } from 'react';
import { Configurations } from '@/types'; // Adjust the import path as necessary
import {getConfigurations} from '@/common/configuration';
import { useRouter } from 'next/navigation';

const AppList = () => {
  const router = useRouter();
  const [apps, setApps] = useState<Configurations>([]);

  useEffect(() => {
    const fetchApps = async () => {
      try {
        // Combine fetched apps with configurationObj
        setApps(await getConfigurations());
      } catch (error) {
        console.error('Error fetching apps:', error);
      }
    };

    fetchApps();
  }, []);

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 p-6 bg-gray-900">
      {apps.map((app) => (
        <div 
          key={app.name} 
          className="bg-gray-800 shadow-lg rounded-lg p-6 hover:bg-gray-700 transition-colors cursor-pointer"
          onClick={() => router.push(`/app/${app.name}`)}
        >
          <h3 className="text-xl font-bold mb-4 text-blue-400">{app.name}</h3>
          <div className="space-y-2">
            <InfoItem label="Type" value={app.type ?? 'N/A'} />
            <InfoItem label="Client" value={app.client ?? 'N/A'} />
            <InfoItem label="Path" value={app.path ?? 'N/A'} />
            <InfoItem label="Endpoint" value={app.endpoint ?? 'N/A'} />
            <InfoItem label="Model" value={app.model ?? 'N/A'} />
            <InfoItem label="Version" value={app.version ?? 'N/A'} />
            <InfoItem label="Inputs" value={app.inputs.map(input => input.key).join(', ')} />
            <InfoItem label="Outputs" value={app.outputs ? app.outputs.map(output => output.key).join(', ') : 'N/A'} />
          </div>
        </div>
      ))}
    </div>
  );
};

const InfoItem = ({ label, value }: { label: string; value: string }) => (
  <p className="text-sm text-gray-300">
    <span className="font-semibold text-gray-100">{label}:</span> {value}
  </p>
);

export default AppList;

==== src/app/create/page.tsx ====
"use client";

import { useState, useRef, useEffect } from 'react';
import { InputItem, OutputItem, Configuration } from "@/types";
import { PlusCircle, X, ChevronDown, ArrowRight } from 'lucide-react';
import { useRouter } from 'next/navigation';
import { getConfigurations } from '@/common/configuration';
import AppPreview from '@/components/AppPreview';

interface GradioEndpoint {
  key: string;
  inputs: InputItem[];
  outputs: OutputItem[];
}

const JsonEditor = ({ value, onChange }: { value: string; onChange: (value: string) => void }) => {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const scrollPositionRef = useRef<number>(0);

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.scrollTop = scrollPositionRef.current;
    }
  }, [value]);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    onChange(e.target.value);
  };

  const handleScroll = () => {
    if (textareaRef.current) {
      scrollPositionRef.current = textareaRef.current.scrollTop;
    }
  };

  return (
    <textarea
      ref={textareaRef}
      value={value}
      onChange={handleChange}
      onScroll={handleScroll}
      className="w-full h-[60vh] px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none overflow-auto"
    />
  );
};

export default function CreateApp() {
  const router = useRouter();

  const [isRawDataStep, setIsRawDataStep] = useState(true);
  const [appType, setAppType] = useState<'gradio' | 'replicate'>('gradio');
  const [rawData, setRawData] = useState('');
  const [modelUrl, setModelUrl] = useState('');
  const [modelData, setModelData] = useState<any>(null);
  const [editMode, setEditMode] = useState<'form' | 'json' | 'preview'>('form');
  const [implementationStep, setImplementationStep] = useState<number>(1);
  const [jsonConfig, setJsonConfig] = useState('');
  const [appName, setAppName] = useState('');
  const [inputs, setInputs] = useState<InputItem[]>([]);
  const [outputs, setOutputs] = useState<OutputItem[]>([]);
  const [path, setPath] = useState('/predict');
  const [client, setClient] = useState('');
  const [modelInput, setModelInput] = useState('');
  const [model, setModel] = useState('');
  const [version, setVersion] = useState<string | null>(null);
  const [errorMessage, setErrorMessage] = useState('');
  const [modelDetails, setModelDetails] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [configurations, setConfigurations] = useState<any[]>([]);
  const [loadingMessage, setLoadingMessage] = useState<string | null>(null); // State for loading message
  const [successMessage, setSuccessMessage] = useState<string | null>(null); // State for success message
  const [endpoint, setEndpoint] = useState('');
  const [endpoints, setEndpoints] = useState<string[]>([]);
  const [gradioEndpoints, setGradioEndpoints] = useState<GradioEndpoint[] | undefined>(undefined);

  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const currentConfig = {
      name: appName,
      type: appType,
      ...(appType === 'gradio' ? { client, path, endpoint } : { model, version }),
      endpoint,
      inputs: inputs.map(input => ({
        type: input.type,
        key: input.key,
        show: input.show,
        placeholder: input.placeholder || "",
        gradioName: input.gradioName || "",
        label: input.label || "",
        description: input.description || "",
        component: input.component || "",
        value: input.value !== undefined ? input.value : null
      })),
      outputs: outputs.map(output => ({
        type: output.type,
        key: output.key,
        show: output.show,
        placeholder: output.placeholder || ""
      }))
    };
    setJsonConfig(JSON.stringify(currentConfig, null, 2));
  }, [appName, appType, client, path, model, version, inputs, outputs, endpoint]);

  useEffect(() => {
    if (configurations.length > 0) {
      const initialInputs = configurations[0].inputs.map((input: InputItem) => ({
        ...input,
        type: input.type === 'string' ? 'string' : 'array' // Adjusted to only check for 'string' and 'array'
      }));
      setInputs(initialInputs);
    }
  }, [configurations]);

  useEffect(() => {
    if (gradioEndpoints) {
      const gradioEndpoint = gradioEndpoints.find((item) => item.key === endpoint);
      console.log({gradioEndpoint});
      if (gradioEndpoint) {
        const { inputs, outputs, key } = gradioEndpoint;
        console.log({key, inputs, outputs});
        setInputs(inputs || []);
        setOutputs(outputs || []);
      }
    }
  }, [endpoint]);

  const handleInputChange = (index: number, field: keyof InputItem, value: any) => {
    setInputs(prevInputs => {
      const updatedInputs = [...prevInputs];
      updatedInputs[index] = { ...updatedInputs[index], [field]: value };
      return updatedInputs;
    });
  };

  const handleOutputChange = (index: number, field: keyof OutputItem, value: any) => {
    setOutputs(prevOutputs => {
      const updatedOutputs = [...prevOutputs];
      updatedOutputs[index] = { ...updatedOutputs[index], [field]: value };
      updateJsonConfig(inputs, updatedOutputs);
      return updatedOutputs;
    });
  };

  const addInput = () => {
    setInputs([...inputs, { component: 'prompt', type: 'string', key: '', show: false }]);
  };

  const addOutput = () => {
    setOutputs([...outputs, { component: 'image', type: 'string', key: '', show: true }]);
  };

  const updateInput = (index: number, field: keyof InputItem, value: any) => {
    const newInputs = [...inputs];
    newInputs[index] = { ...newInputs[index], [field]: value };
    setInputs(newInputs);
  };

  const updateOutput = (index: number, field: keyof OutputItem, value: any) => {
    const newOutputs = [...outputs];
    newOutputs[index] = { ...newOutputs[index], [field]: value };
    setOutputs(newOutputs);
  };

  const removeInput = (index: number) => {
    const newInputs = inputs.filter((_, i) => i !== index);
    setInputs(newInputs);
  };

  const removeOutput = (index: number) => {
    const newOutputs = outputs.filter((_, i) => i !== index);
    setOutputs(newOutputs);
  };

  const isFormValid = () => {
    const isInputsValid = inputs.length > 0 && inputs.every(input => input.key.trim() !== '');
    const isOutputsValid = outputs.length > 0;
    return isInputsValid && isOutputsValid && appName.trim() !== '';
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isFormValid()) {
      alert('Please fill all required fields and add at least one input and one output.');
      return;
    }

    const newApp: Configuration = {
      name: appName,
      type: appType,
      inputs,
      outputs,
    };

    if (appType === 'gradio') {
      newApp.client = client;
      newApp.path = path;
      newApp.endpoint = endpoint;
    } else {
      newApp.model = model as `${string}/${string}`;
      newApp.version = version;
    }

    // Use SSE if enabled and Gradio app
    if (process.env.USE_SSE_EXPERIMENTAL === 'true' && appType === 'gradio') {
      try {
        const eventSource = new EventSource(`/api/experimental/sse/predict?client=${client}&endpoint=${endpoint}`);
        
        eventSource.onmessage = (event) => {
          const result = JSON.parse(event.data);
          // Update preview with result
          setOutputs(prev => prev.map((out, i) => ({
            ...out,
            value: result[i] || out.value
          })));
        };

        eventSource.onerror = () => {
          alert('SSE connection failed - falling back to regular API');
          eventSource.close();
          submitRegular(newApp);
        };

        return;
      } catch (error) {
        console.error('SSE failed, falling back:', error);
      }
    }

    submitRegular(newApp);
  };

  const submitRegular = async (newApp: Configuration) => {
    try {
      const response = await fetch('/api/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(newApp),
      });

      if (response.ok) {
        alert('App created successfully!');
        router.push(`/app/${appName}`);
      } else {
        alert('Failed to create app');
      }
    } catch (error) {
      console.error('Error creating app:', error);
      alert('An error occurred while creating the app');
    }
  };

  const handleRawDataChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setRawData(e.target.value);
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
    }
  };
  
  const handleParseRawData = () => {
    console.log({rawData});
    
    setErrorMessage('');

    const isReplicate = /\breplicate\.run\(/.test(rawData);
    if (!isReplicate) {
      setErrorMessage('Invalid format for Replicate raw data. Please check your input.');
      return;
    }
    
    console.log({isReplicate});
    
    if (isReplicate) {
      const step2Regex = /"([^:]+\/[^:]+):([^"]+)"/;
      const modelMatch = rawData.match(step2Regex);
      console.log("Step 2:", modelMatch ? modelMatch.slice(1) : "No match");

      if (modelMatch) {
        const model = modelMatch[1];
        const version = modelMatch[2];
        
        const step3Regex = /input:\s*({[\s\S]*?})\s*}/;
        const inputMatch = rawData.match(step3Regex);
        console.log("Step 3:", inputMatch ? "Input object found" : "No input object");
        
        if (inputMatch) {
          console.log("Input Match:", inputMatch[1]);

          const inputString = inputMatch[1];

          const configuration: Configuration = {
            name: model,
            type: 'replicate',
            model: model as `${string}/${string}`,
            version: version,
            inputs: Object.entries(eval(`(${inputString})`)).map(([key, value]: [string, any]) => ({
              type: Array.isArray(value) ? 'array' : typeof value === 'boolean' ? 'boolean' : typeof value === 'number' && Number.isInteger(value) ? 'integer' : 'string',
              key,
              value: value as any, // Explicitly cast value to any
              show: false,
              required: value.required || false,
              component: value.component || 'prompt'
            }))
          };

          console.log("Configuration:", JSON.stringify(configuration, null, 2));

          setAppName(configuration.name);
          setAppType(configuration.type);
          setModel(configuration.model as string);
          setVersion(configuration.version || null);
          setInputs(configuration.inputs);
          setIsRawDataStep(false);
        } else {
          console.error("Error: No input object found in raw data. Please check the format.");
        }
      }
    } else {
      console.log("Type not identified as replicate");
    }
  };

  const handleJsonChange = (newValue: string) => {
    setJsonConfig(newValue);
    try {
      const parsedConfig = JSON.parse(newValue);
      setAppName(parsedConfig.name);
      setAppType(parsedConfig.type);
      if (parsedConfig.type === 'gradio') {
        setClient(parsedConfig.client);
        setPath(parsedConfig.path);
        setEndpoint(parsedConfig.endpoint);
      } else {
        setModel(parsedConfig.model);
        setVersion(parsedConfig.version);
      }
      setInputs(parsedConfig.inputs.map((input: any) => ({
        type: input.type,
        key: input.key,
        show: input.show,
        placeholder: input.placeholder || "",
        gradioName: input.gradioName || "",
        label: input.label || "",
        description: input.description || "",
        component: input.component || "",
        value: input.value !== undefined ? input.value : null
      })));
      setOutputs(parsedConfig.outputs.map((output: any) => ({
        type: output.type,
        key: output.key,
        show: output.show,
        placeholder: output.placeholder || ""
      })));
    } catch (error) {
      console.error('Invalid JSON:', error);
    }
  };

  const handleFetchModel = async () => {
    try {
      const response = await fetch(modelUrl);
      if (!response.ok) {
        throw new Error('Failed to fetch model data');
      }
      const data = await response.json();
      setModelData(data);
    } catch (error) {
      console.error('Error fetching model:', error);
      alert('Error fetching model data. Please check the URL and try again.');
    }
  };

  const handleModelInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setModelInput(e.target.value);
    const [modelPart, versionPart] = e.target.value.split(':');
    setModel(modelPart.trim());
    setVersion(versionPart ? versionPart.trim() : null);
  };

  interface PropertyValue {
    type: 'string' | 'array' | 'integer' | 'boolean';
    default?: string | number | boolean;
    description?: string;
    title?: string;
    required?: boolean;
    items?: {
      type?: string;
      format?: string;
    };
    format?: string; // Add this line
    component?: 'image' | 'prompt' | 'checkbox' | 'number' | 'video';
  }

  const handleFetchModelDetails = async (type: 'replicate' | 'gradio') => {
    try {
      setIsLoading(true);
      setLoadingMessage(`Fetching ${type === 'gradio' ? 'Gradio space' : 'Replicate model'} details...`);

      const response = await fetch('/api/create/fetch-model-details', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ type, client, model, version }), // Send model and version in the request body
      });

      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      
      const data = await response.json();

      console.log('Fetched data:', data);

      // Populate inputs based on the schema
      const { formattedEndpoints, view_api }: { formattedEndpoints: GradioEndpoint[], api_info: any, view_api: boolean } = data;
      
      console.log({formattedEndpoints});

      if (view_api) {
        console.log('API view is available');
        alert('API view is available');
      } else {
        console.log('API view is NOT available');
        alert('API view is NOT available');

      }

      // I: I have the enpoints on formattedEndpoints
      // 2 I should have a select on endpoint, and be able to select the endpoint
      //    When changes the endpoint should appear the Inputs and Outputs,

      // I have to change the logic, when 

      // O: can be able to select the endpoint when is gradio.

      // It should happens depends on the endpoint, for example have one as default.
      // So here I should just I mean, update the endpoint, and for that endpoint,
      //  update the respective inputs and outputs,
      // So I can select the formattedParams to zero, and so on, and get the inputs, and otputs for that.
      // And, yeah, maybe review the useEffect, when something change here,

      let inputItems: InputItem[] = [];
      let outputItems: OutputItem[] = [];


      if (type === 'gradio') {
        console.log({type})

        const endpoints = formattedEndpoints.map((item: any) => item.key);
        const defaultEndpoint = endpoints[0]; // Default to first endpoint

        // Set Gradio endpoints and default endpoint
        setEndpoints(endpoints);
        setEndpoint(defaultEndpoint);
        setGradioEndpoints(formattedEndpoints);
        
        // Find the default endpoint data
        const defaultGradioEndpoint = formattedEndpoints.find((item) => item.key === defaultEndpoint);
        if (defaultGradioEndpoint) {
          inputItems = defaultGradioEndpoint.inputs || [];
          outputItems = defaultGradioEndpoint.outputs || [];

          // Immediately set inputs and outputs
          setInputs(inputItems);
          setOutputs(outputItems);

          // Sync JSON config with default endpoint data
          updateJsonConfig(inputItems, outputItems);
        }

        setIsRawDataStep(false); 
      } else if (type === 'replicate') {
        // Process inputs
        inputItems = Object.entries(inputs).map(([key, value]) => {
          const typedValue = value as PropertyValue;
          return {
            component: typedValue.component || 'prompt',
            key,
            type: typedValue.type,
            value: (typedValue.default !== undefined ? typedValue.default : null) as string | number | boolean | undefined,
            show: false,
            placeholder: typedValue.description || '',
            label: typedValue.title || '',
            required: false,
          };
        });
      
        // Process outputs
        const processOutput = (key: string, value: PropertyValue): OutputItem => {
          let outputItem: OutputItem = {
            component: value.component || 'image',
            key,
            type: value.type as 'string' | 'number' | 'boolean' | 'array',
            show: true,
            title: value.title || key,
            placeholder: value.description || '',
          };
        
          if (value.type === 'array' && value.items) {
            outputItem.typeItem = value.items.type as 'string' | 'number' | 'boolean';
            if (value.items.format) {
              outputItem.formatItem = value.items.format;
            }
          } else if (value.type === 'string' && value.format) {
            outputItem.format = value.format;
          }
        
          return outputItem;
        };

        outputItems = Object.entries(outputs).map(([key, value]) => processOutput(key, value as PropertyValue));
      }
        

      // Sort inputs to have required fields at the top
      // const sortedInputs = [
      //   ...inputItems.filter((input: InputItem) => input.required),
      //   ...inputItems.filter((input: InputItem) => !input.required),
      // ];

      const validInputs = inputItems.filter((item): item is InputItem => item !== undefined);
      const validOutputs = outputItems.filter((item): item is OutputItem => item !== undefined);
      setInputs(validInputs);
      setOutputs(validOutputs);
      updateJsonConfig(validInputs, validOutputs);
      setIsRawDataStep(false);
    } catch (error: any) {
      console.error('Error fetching model details:', error.message);
      alert('Error fetching model data. Please check the URL and try again.');
    } finally {
      // Always reset loading states regardless of success/failure
      setIsLoading(false);
      setLoadingMessage(null);
    }
  };

  const fetchConfigurations = async () => {
    setIsLoading(true);
    try {
      const timestamp = Date.now();
      const configurations = await getConfigurations(true);
      // Handle configurations as needed
    } catch (error) {
      console.error('Error fetching configurations:', error);
      alert('Failed to fetch configurations.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleBack = () => {
    setIsRawDataStep(true);
    fetchConfigurations();
  };

  // Component to render inputs dynamically
  const renderInput = (input: InputItem) => {
    switch (input.type) {
      case 'string':
        return <input type="text" value={input.value || ''} placeholder={input.placeholder} />;
      case 'array':
        return (
          <select multiple>
            {/* Populate options based on your needs */}
            <option value="uri">URI</option>
            {/* Add more options as needed */}
          </select>
        );
      default:
        return null;
    }
  };

  const updateJsonConfig = (inputs: InputItem[], outputs: OutputItem[]) => {
    const config: Configuration = {
      name: appName,
      type: appType,
      inputs,
      outputs: outputs.map(output => {
        // Include all properties, including formatItem if it exists
        const outputItem: OutputItem = {
          key: output.key,
          type: output.type,
          show: output.show,
          title: output.title,
          placeholder: output.placeholder,
          component: output.component || 'image'
        };
        if (output.format) outputItem.format = output.format;
        if (output.typeItem) outputItem.typeItem = output.typeItem;
        if (output.formatItem) outputItem.formatItem = output.formatItem;
        return outputItem;
      })
    };

    if (appType === 'replicate') {
      config.model = model as `${string}/${string}`;
      config.version = version;
    } else if (appType === 'gradio') {
      config.client = client;
      config.path = path;
      config.endpoint = endpoint;
    }

    setJsonConfig(JSON.stringify(config, null, 2));
  };

  const handleAppNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setAppName(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handleAppTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setAppType(e.target.value as 'gradio' | 'replicate');
    updateJsonConfig(inputs, outputs);
  };

  const handleModelChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setModel(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handleVersionChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setVersion(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handleClientChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setClient(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handlePathChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setPath(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  const handleEndpointChange = (e: React.ChangeEvent<HTMLInputElement> | React.ChangeEvent<HTMLSelectElement>) => {
    setEndpoint(e.target.value);
    updateJsonConfig(inputs, outputs);
  };

  return (
    <div className="max-w-4xl mx-auto p-4 sm:p-6 space-y-4 sm:space-y-6 bg-gray-800 rounded-lg shadow-lg mt-8 sm:mt-16">
      {isRawDataStep ? (
        <>
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-lg font-semibold text-gray-200">Enter Model Details</h2>
            <button
              type="button"
              onClick={() => setIsRawDataStep(false)}
              className="flex items-center bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600"
            >
              <ArrowRight size={20} />
              <span className="ml-1">Skip Step</span>
            </button>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-300 mb-1">App Type:</label>
            <select
              value={appType}
              onChange={(e) => setAppType(e.target.value as 'gradio' | 'replicate')}
              className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="replicate">Replicate</option>
              <option value="gradio">Gradio</option>
            </select>
          </div>

          {appType === 'replicate' && (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-300 mb-1">Model:Version</label>
                <input
                  type="text"
                  value={modelInput}
                  onChange={handleModelInputChange}
                  placeholder="owner/model_name:version"
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <button
                type="button"
                onClick={() => handleFetchModelDetails('replicate')}
                disabled={isLoading || !model}
                className="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-400"
              >
                {isLoading ? (
                  <span className="flex items-center justify-center">
                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Fetching...
                  </span>
                ) : 'Fetch Model Details'}
              </button>
            </div>
          )}

          {appType === 'gradio' && (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-300 mb-1">Client:</label>
                <input
                  type="text"
                  value={client}
                  onChange={(e) => setClient(e.target.value)}
                  placeholder="Enter the gradio client"
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <button
                type="button"
                onClick={() => handleFetchModelDetails('gradio')}
                disabled={isLoading || !client}
                className="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-400"
              >
                {isLoading ? (
                  <span className="flex items-center justify-center">
                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Fetching...
                  </span>
                ) : 'Fetch Model Details'}
              </button>
              {/* <div>
                <label className="block text-sm font-medium text-gray-300 mb-1">Raw Data (Optional):</label>
                <textarea
                  ref={textareaRef}
                  value={rawData}
                  onChange={handleRawDataChange}
                  className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500 h-[20vh]"
                  placeholder='Paste raw data here (optional)...'
                />
              </div> */}
            </div>
          )}

          {/* {appType === 'gradio' && (
            <button
              type="button"
              onClick={handleParseRawData}
              className="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600"
            >
              Parse Raw Data
            </button>
          )} */}
        </>
      ) : (
        <> {/* Add fragment to wrap form and preview */}
          <form onSubmit={handleSubmit}>
            <div className="flex justify-between items-center mb-4">
              <div className="flex space-x-4">
                <button
                type="button" 
                onClick={() => setEditMode('form')} 
                className={`px-4 py-2 rounded-md ${editMode === 'form' ? 'bg-blue-500 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                Form
              </button>
              <button 
                type="button" 
                onClick={() => setEditMode('json')} 
                className={`px-4 py-2 rounded-md ${editMode === 'json' ? 'bg-blue-500 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                JSON
              </button>
              <button 
                type="button" 
                onClick={() => {
                  setEditMode('preview');
                  setImplementationStep(2);
                }} 
                className={`px-4 py-2 rounded-md ${editMode === 'preview' ? 'bg-blue-500 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                Preview
              </button>
            </div>
              <button
                type="submit"
                className="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600"
              >
                Create App
              </button>
            </div>

            {/* Keep form and json modes inside the form */}
            {editMode === 'form' ? (
            <>
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-300 mb-1">App Name:</label>
                  <input
                    type="text"
                    value={appName}
                    onChange={handleAppNameChange}
                    className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-300 mb-1">App Type:</label>
                  <select
                    value={appType}
                    onChange={handleAppTypeChange}
                    className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="gradio">Gradio</option>
                    <option value="replicate">Replicate</option>
                  </select>
                </div>
              </div>

              {appType === 'gradio' ? (
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Client:</label>
                    <input
                      type="text"
                      value={client}
                      onChange={handleClientChange}
                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Path:</label>
                    <input
                      type="text"
                      value={path}
                      onChange={handlePathChange}
                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Endpoint:</label>
                    {endpoints ? (
                      <select
                      value={endpoint}
                      onChange={handleEndpointChange}
                      className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                      >
                        {endpoints && endpoints.map((item: string) => 
                          (<option key={item} value={item}>{item}</option>)
                        )}
                      </select>
                    ) : (
                      <input
                        type="text"
                        value={endpoint}
                        onChange={handleEndpointChange}
                        className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                      />
                    )}
                  </div>
                </div>
              ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Model:</label>
                    <input
                      type="text"
                      value={model}
                      onChange={handleModelChange}
                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Version:</label>
                    <input
                      type="text"
                      value={version || ''}
                      onChange={handleVersionChange}
                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                  </div>
                  {appType === 'replicate' && (
                    <div className="mt-4">
                      <button
                        type="button"
                        onClick={() => handleFetchModelDetails('replicate')}
                        className="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600"
                      >
                        Re-fetch Model Details
                      </button>
                    </div>
                  )}
                </div>
              )}

              {/* Show loading message with more visibility */}
              {loadingMessage && (
                <div className="my-4 p-3 bg-blue-900/30 border border-blue-500 rounded-md text-blue-200 flex items-center">
                  <svg className="animate-spin h-5 w-5 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  {loadingMessage}
                </div>
              )}

              {/* Hide inputs and outputs while loading */}
              {isLoading ? (
                <div className="text-gray-300">Loading...</div>
              ) : (
                <>
                  <div>
                    <h3 className="text-lg font-semibold text-gray-200 mb-2">Inputs:</h3>
                    {inputs.map((input, index) => (
                      <div key={index} className="mb-4 p-4 bg-gray-700 rounded-md">
                        <div className="grid grid-cols-2 gap-4">
                          <input
                            type="text"
                            value={input.key}
                            onChange={(e) => handleInputChange(index, 'key', e.target.value)}
                            placeholder="Key"
                            className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          />
                            <select
                              value={input.component}
                              onChange={(e) => handleInputChange(index, 'component', e.target.value as InputItem['component'])}
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            >
                              <option value="prompt">Prompt</option>
                              <option value="image">Image</option>
                              <option value="audio">Audio</option>
                              <option value="checkbox">Checkbox</option>
                              <option value="number">Number</option>
                              <option value="video">Video</option>
                            </select>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mt-2">
                          <input
                            type="text"
                            value={input.value || ''}
                            onChange={(e) => handleInputChange(index, 'value', e.target.value)}
                            placeholder="Value"
                            className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          />
                          <div className="flex items-center justify-between">
                            <label className="flex items-center space-x-2 text-gray-300">
                              <input
                                type="checkbox"
                                checked={input.show}
                                onChange={(e) => handleInputChange(index, 'show', e.target.checked)}
                                className="form-checkbox h-5 w-5 text-blue-500"
                              />
                              <span>Show</span>
                            </label>
                            <button
                              type="button"
                              onClick={() => removeInput(index)}
                              className="p-2 bg-red-500 text-white rounded-md hover:bg-red-600"
                            >
                              <X size={20} />
                            </button>
                          </div>
                        </div>
                        {input.show && (
                          <div className="grid grid-cols-2 gap-4 mt-4">
                            <input
                              type="text"
                              value={input.placeholder || ''}
                              onChange={(e) => handleInputChange(index, 'placeholder', e.target.value)}
                              placeholder="Placeholder"
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            />
                            <input
                              type="text"
                              value={input.label || ''}
                              onChange={(e) => handleInputChange(index, 'label', e.target.value)}
                              placeholder="Label"
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            />
                            <select
                              value={input.type}
                              onChange={(e) => handleInputChange(index, 'type', e.target.value as InputItem['type'])}
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            >
                              <option value="string">String</option>
                              <option value="array">Array</option>
                              <option value="number">Number</option>
                              <option value="boolean">Boolean</option>
                            </select>
                          </div>
                        )}
                      </div>
                    ))}
                    <button 
                      type="button" 
                      onClick={addInput} 
                      className="w-full mt-2 px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-600 flex items-center justify-center"
                    >
                      <PlusCircle size={20} className="mr-2" />
                      Add Input
                    </button>
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold text-gray-200 mb-2">Outputs:</h3>
                    {outputs.map((output, index) => (
                      <div key={index} className="mb-4 p-4 bg-gray-700 rounded-md">
                        <div className="grid grid-cols-2 gap-4">
                          <input
                            type="text"
                            value={output.title}
                            onChange={(e) => handleOutputChange(index, 'title', e.target.value)}
                            placeholder="Title"
                            className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          />
                          <select
                            value={output.component}
                            onChange={(e) => handleOutputChange(index, 'component', e.target.value as OutputItem['component'])}
                            className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          >
                            <option value="image">Image</option>
                            <option value="prompt">Prompt</option>
                            <option value="checkbox">Checkbox</option>
                            <option value="number">Number</option>
                            <option value="video">Video</option>
                          </select>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mt-2">
                          <input
                            type="text"
                            value={output.placeholder || ''}
                            onChange={(e) => handleOutputChange(index, 'placeholder', e.target.value)}
                            placeholder="Placeholder"
                            className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                          />
                          <div className="flex items-center justify-between">
                            <label className="flex items-center space-x-2 text-gray-300">
                              <input
                                type="checkbox"
                                checked={output.show}
                                onChange={(e) => handleOutputChange(index, 'show', e.target.checked)}
                                className="form-checkbox h-5 w-5 text-blue-500"
                              />
                              <span>Show</span>
                            </label>
                            <button
                              type="button"
                              onClick={() => removeOutput(index)}
                              className="p-2 bg-red-500 text-white rounded-md hover:bg-red-600"
                            >
                              <X size={20} />
                            </button>
                          </div>
                        </div>
                        {output.show && (
                          <div className="mt-4 grid grid-cols-2 gap-4">
                            <input
                              type="text"
                              value={output.key}
                              onChange={(e) => handleOutputChange(index, 'key', e.target.value)}
                              placeholder="Key"
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            />
                            <select
                              value={output.type}
                              onChange={(e) => handleOutputChange(index, 'type', e.target.value as OutputItem['type'])}
                              className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                            >
                              <option value="string">String</option>
                              <option value="number">Number</option>
                              <option value="boolean">Boolean</option>
                              <option value="array">Array</option>
                            </select>
                            {output.type === 'array' && (
                              <>
                                <select
                                  value={output.typeItem || ''}
                                  onChange={(e) => handleOutputChange(index, 'typeItem', e.target.value as OutputItem['typeItem'])}
                                  className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                                >
                                  <option value="">Select Item Type</option>
                                  <option value="string">String</option>
                                  <option value="number">Number</option>
                                  <option value="boolean">Boolean</option>
                                </select>
                                <input
                                  type="text"
                                  value={output.formatItem || ''}
                                  onChange={(e) => handleOutputChange(index, 'formatItem', e.target.value)}
                                  placeholder="Format Item"
                                  className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                                />
                              </>
                            )}
                            {output.type === 'string' && (
                              <input
                                type="text"
                                value={output.format || ''}
                                onChange={(e) => handleOutputChange(index, 'format', e.target.value)}
                                placeholder="Format"
                                className="w-full mt-2 px-3 py-2 bg-gray-600 border border-gray-500 rounded-md text-white"
                              />
                            )}
                          </div>
                        )}
                      </div>
                    ))}
                    <button 
                      type="button" 
                      onClick={addOutput} 
                      className="w-full mt-2 px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-600 flex items-center justify-center"
                    >
                      <PlusCircle size={20} className="mr-2" />
                      Add Output
                    </button>
                  </div>
                  {successMessage && <div className="text-green-300">{successMessage}</div>}
                </>
              )}
            </>
            ) : editMode === 'json' ? (
              <JsonEditor value={jsonConfig} onChange={handleJsonChange} />
            ) : null}
          </form>

          {/* Render AppPreview outside the form when in preview mode */}
          {editMode === 'preview' && (
            <AppPreview
              config={{
                name: appName,
                type: appType,
                ...(appType === 'gradio' ?
                  { client, path, endpoint, endpoints } :
                  { model: `${model.split('/')[0]}/${model.split('/')[1]}`, version }
                ),
                inputs,
                outputs
              }}
              onEndpointChange={(newEndpoint) => {
                setEndpoint(newEndpoint);
                if (gradioEndpoints) {
                  const newGradioEndpoint = gradioEndpoints.find((item) => item.key === newEndpoint);
                  if (newGradioEndpoint) {
                    const { inputs: newInputs, outputs: newOutputs } = newGradioEndpoint;
                    setInputs(newInputs || []);
                    setOutputs(newOutputs || []);
                  }
                }
              }}
              onAppNameChange={setAppName}
            />
          )}
        </> // Close fragment
      )}

      {modelData && (
        <div className="mt-4 p-4 bg-gray-700 rounded-md">
          <h3 className="text-lg font-semibold text-gray-200">Model Data:</h3>
          <pre className="text-gray-300">{JSON.stringify(modelData, null, 2)}</pre>
        </div>
      )}
    </div>
  );
}


==== src/app/desktop-sidebar.tsx ====
import { usePathname } from "next/navigation";
import { navigation } from "@/common";
import { classNames } from "@/utils";
import Link from "next/link";

export function DesktopSidebar() {
  const pathName = usePathname();

  return (
    <aside className="hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col">
      {/* Sidebar component, swap this element with another sidebar if you like */}
      <div className="flex grow flex-col gap-y-5 overflow-y-auto bg-gray-900 px-6">
        <div className="flex h-16 shrink-0 items-center">
          <h1 className="bg-gradient-to-r from-blue-600 via-green-500 to-indigo-400 bg-clip-text text-xl font-semibold text-transparent">
            J4 Tools
          </h1>
        </div>

        <nav className="flex flex-1 flex-col">
          <ul role="list" className="flex flex-1 flex-col gap-y-7">
            <li>
              <ul role="list" className="-mx-2 space-y-1">
                {navigation.map((item) => (
                  <li key={item.name}>
                    <Link
                      href={item.href}
                      className={classNames(
                        pathName === item.href
                          ? "bg-gray-800 text-white"
                          : "text-gray-400 hover:bg-gray-800 hover:text-white",
                        "group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6 transition-all duration-300"
                      )}
                    >
                      <item.icon
                        className="h-6 w-6 shrink-0"
                        aria-hidden="true"
                      />
                      {item.name}
                    </Link>
                  </li>
                ))}
              </ul>
            </li>
          </ul>
        </nav>
      </div>
    </aside>
  );
}


==== src/app/enhancebg/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu"
import { ImageAreaProps } from "@/types";
import { Field, Input, Label, Description, } from "@headlessui/react";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const themes = ["Modern", "Vintage", "Minimalist", "Professional"];
const rooms = ["Living Room", "Dining Room", "Bedroom", "Bathroom", "Office"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a product and let our AI generate a new background.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [prompt, setPrompt] = useState<string | null>(null);
  const [theme, setTheme] = useState<string>(themes[0]);
  const [room, setRoom] = useState<string>(rooms[0]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file || !prompt) {
      setError("Please upload an image & fill the prompt");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/inter-design", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image, prompt }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    // Output returns an array of two images
    // Here we show the second image
    setOutputImage(result.output[0]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      {/* <section className="mx-4 mt-9 flex w-fit flex-col space-y-8 lg:mx-6 lg:flex-row lg:space-x-8 lg:space-y-0 xl:mx-8"> */}
        {/* <Input name="full_name" type="text" /> */}
        {/* <SelectMenu
          label="Model"
          options={themes}
          selected={theme}
          onChange={setTheme}
        />
        <SelectMenu
          label="Room type"
          options={rooms}
          selected={room}
          onChange={setRoom}
        /> */}
      {/* </section> */}
      <Field className="flex flex-col px-4 gap-1 lg:px-6 xl:gap-1 xl:px-8">
        <Label className="text-sm/6 font-medium text-white">Prompt</Label>
        <Description className="text-sm/6 text-white/50">Describe what is the background you want the image change for.</Description>
        <Input 
        className="border bg-slate-500 rounded-lg w-full"
        name="prompt"
        onChange={(e)=> setPrompt(e.target.value)}
        />
      </Field>

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/favicon.ico ====
(Skipped binary or unreadable file)

==== src/app/globals.css ====
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 255, 255, 255;
  --background-start-rgb: 0, 0, 0;
  --background-end-rgb: 0, 0, 0;
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

==== src/app/header.tsx ====
import { usePathname } from "next/navigation";
import { Bars3Icon } from "@heroicons/react/24/outline";

type HeaderProps = {
  onClick(): void;
};

export function Header({ onClick }: HeaderProps) {
  const pathName = usePathname();
  console.log(pathName);

  return (
    <header className="sticky top-0 z-40 flex items-center gap-x-6 px-4 py-4 shadow-sm sm:px-6 lg:hidden">
      <button
        type="button"
        className="-m-2.5 p-2.5 text-gray-400 lg:hidden"
        onClick={onClick}
      >
        <span className="sr-only">Open sidebar</span>
        <Bars3Icon className="h-6 w-6" aria-hidden="true" />
      </button>
      <div className="flex-1 text-sm font-semibold leading-6 text-white">
        {pathName === "/" ? "Home" : "History"}
      </div>
    </header>
  );
}


==== src/app/illuminai/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu";
import { ImageAreaProps } from "@/types";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const sources = ["None", "Left Light", "Right Light", "Bottom Light", "Top Light"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a room and let our AI generate a new design.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [source, setSource] = useState<string>(sources[0]);
  const [prompt, setPrompt] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file) {
      setError("Please upload an image.");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/illuminai", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image, source, prompt }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    setOutputImage(result.output[0]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      <section className="mx-4 mt-9 flex w-fit flex-col space-y-8 lg:mx-6 lg:flex-row lg:space-x-8 lg:space-y-0 xl:mx-8">
        <div className="w-80">
          <label className="block text-sm font-medium leading-6 text-gray-300">
            Prompt
          </label>
          <textarea
          className="mt-2 w-full border bg-slate-800 text-sm text-gray-300 leading-6 text-left pl-3 py-1 rounded-md"
          // type="text"
          onChange={(e) => setPrompt(e.target.value)}
          />
        </div>
        <SelectMenu
          label="Light Source"
          options={sources}
          selected={source}
          onChange={setSource}
        />
        {/* <SelectMenu
          label="Room type"
          options={rooms}
          selected={room}
          onChange={setRoom}
        /> */}
      </section>

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/layout.tsx ====
import './globals.css';
import { Analytics } from '@vercel/analytics/react';
import { Inter } from 'next/font/google';
import { Sidebar } from './sidebar';
import ClientSidebarWrapper from './ClientSidebarWrapper';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
  title: 'Interior Designer AI',
  description: 'Upload a sample room photo and get a design back in seconds.',
  robots: 'index, follow',
  openGraph: {
    title: 'Interior Designer AI',
    description: 'Upload a sample room photo and get a design back in seconds.',
    url: 'https://interior-designer-ai.vercel.app/',
    locale: 'en_US',
    type: 'website',
    images: [
      {
        url: 'https://interior-designer-ai.vercel.app/app-screenshot.png',
        width: 1200,
        height: 630,
        alt: 'Screenshot of the Interior Designer AI app',
      },
    ],
  },
};

type RootLayoutProps = {
  children: React.ReactNode;
};

export default function RootLayout({ children }: RootLayoutProps) {
  return (
    <html lang='en'>
      <body className={`${inter.className}`}>
        <ClientSidebarWrapper>
          <Sidebar />
        </ClientSidebarWrapper>
        <main>
          {children}
        </main>
        <Analytics />
      </body>
    </html>
  );
}

==== src/app/mobile-sidebar.tsx ====
import { Fragment } from "react";
import { usePathname } from "next/navigation";
import { XMarkIcon } from "@heroicons/react/24/outline";
import { Transition } from "@headlessui/react";
import { Dialog } from "@headlessui/react";
import { navigation } from "@/common";
import { classNames } from "@/utils";

type SidebarProps = {
  sidebarOpen: boolean;
  setSidebarOpen(open: boolean): void;
};

export function MobileSidebar({ sidebarOpen, setSidebarOpen }: SidebarProps) {
  const pathName = usePathname();

  return (
    <Transition.Root show={sidebarOpen} as={Fragment}>
      <Dialog
        as="div"
        className="relative z-50 lg:hidden"
        onClose={setSidebarOpen}
      >
        <Transition.Child
          as={Fragment}
          enter="transition-opacity ease-linear duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="transition-opacity ease-linear duration-300"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-gray-900/80" />
        </Transition.Child>

        <div className="fixed inset-0 flex">
          <Transition.Child
            as={Fragment}
            enter="transition ease-in-out duration-300 transform"
            enterFrom="-translate-x-full"
            enterTo="translate-x-0"
            leave="transition ease-in-out duration-300 transform"
            leaveFrom="translate-x-0"
            leaveTo="-translate-x-full"
          >
            <Dialog.Panel className="relative mr-16 flex w-full max-w-xs flex-1">
              <Transition.Child
                as={Fragment}
                enter="ease-in-out duration-300"
                enterFrom="opacity-0"
                enterTo="opacity-100"
                leave="ease-in-out duration-300"
                leaveFrom="opacity-100"
                leaveTo="opacity-0"
              >
                <div className="absolute left-full top-0 flex w-16 justify-center pt-5">
                  <button
                    type="button"
                    className="-m-2.5 p-2.5"
                    onClick={() => setSidebarOpen(false)}
                  >
                    <span className="sr-only">Close sidebar</span>
                    <XMarkIcon
                      className="h-6 w-6 text-white"
                      aria-hidden="true"
                    />
                  </button>
                </div>
              </Transition.Child>

              {/* Sidebar component, swap this element with another sidebar if you like */}
              <aside className="flex grow flex-col gap-y-5 overflow-y-auto bg-gray-900 px-6 pb-2 ring-1 ring-white/10">
                <div className="flex h-16 shrink-0 items-center">
                  <h1 className="bg-gradient-to-r from-blue-600 via-green-500 to-indigo-400 bg-clip-text text-xl font-semibold text-transparent">
                    Interior Designer
                  </h1>
                </div>
                <nav className="flex flex-1 flex-col">
                  <ul role="list" className="flex flex-1 flex-col gap-y-7">
                    <li>
                      <ul role="list" className="-mx-2 space-y-1">
                        {navigation.map((item) => (
                          <li key={item.name}>
                            <a
                              href={item.href}
                              className={classNames(
                                pathName === item.href
                                  ? "bg-gray-800 text-white"
                                  : "text-gray-400 hover:bg-gray-800 hover:text-white",
                                "group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6 transition-all duration-300"
                              )}
                            >
                              <item.icon
                                className="h-6 w-6 shrink-0"
                                aria-hidden="true"
                              />
                              {item.name}
                            </a>
                          </li>
                        ))}
                      </ul>
                    </li>
                  </ul>
                </nav>
              </aside>
            </Dialog.Panel>
          </Transition.Child>
        </div>
      </Dialog>
    </Transition.Root>
  );
}


==== src/app/on-device/[slug]/page.tsx ====
(Skipped binary or unreadable file)

==== src/app/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu";
import { ImageAreaProps } from "@/types";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const themes = ["Modern", "Vintage", "Minimalist", "Professional"];
const rooms = ["Living Room", "Dining Room", "Bedroom", "Bathroom", "Office"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a room and let our AI generate a new design.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [theme, setTheme] = useState<string>(themes[0]);
  const [room, setRoom] = useState<string>(rooms[0]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file) {
      setError("Please upload an image.");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/inter-design", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image, theme, room }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    // Output returns an array of two images
    // Here we show the second image
    setOutputImage(result.output[1]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      <section className="mx-4 mt-9 flex w-fit flex-col space-y-8 lg:mx-6 lg:flex-row lg:space-x-8 lg:space-y-0 xl:mx-8">
        <SelectMenu
          label="Model"
          options={themes}
          selected={theme}
          onChange={setTheme}
        />
        <SelectMenu
          label="Room type"
          options={rooms}
          selected={room}
          onChange={setRoom}
        />
      </section>

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/providers.tsx ====
"use client"

import { ThemeProvider } from "next-themes"

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
      {children}
    </ThemeProvider>
  )
}

==== src/app/removebg/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu"
import { ImageAreaProps } from "@/types";
import { Field, Input, Label, Description, } from "@headlessui/react";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const themes = ["Modern", "Vintage", "Minimalist", "Professional"];
const rooms = ["Living Room", "Dining Room", "Bedroom", "Bathroom", "Office"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a product and let our AI generate a new background.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [theme, setTheme] = useState<string>(themes[0]);
  const [room, setRoom] = useState<string>(rooms[0]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file) {
      setError("Please upload an image");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/removebg", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image }),
    });

    const result = await response.json();

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    // Output returns an array of two images
    // Here we show the second image
    setOutputImage(result.output);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/selectmenu.tsx ====
import { Fragment } from "react";
import { classNames } from "@/utils";
import { Listbox, Transition } from "@headlessui/react";
import { ListboxButton, ListboxOption, ListboxOptions } from '@headlessui/react'
import { CheckIcon, ChevronUpDownIcon } from "@heroicons/react/20/solid";

type SelectMenuProps = {
  label: string;
  options: string[];
  selected: string;
  onChange(value: string): void;
};

export function SelectMenu({
  label,
  options,
  selected,
  onChange,
}: SelectMenuProps) {
  return (
    <Listbox value={selected} onChange={onChange}>
      {({ open }) => (
        <div className="w-80">
          <label className="block text-sm font-medium leading-6 text-gray-300">
            {label}
          </label>
          <div className="relative mt-2">
            <ListboxButton className="relative w-full cursor-default rounded-md py-1.5  pl-3 pr-10 text-left text-gray-300 shadow-sm ring-1 ring-inset ring-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-600 dark:bg-slate-800 sm:text-sm sm:leading-6">
              <span className="block truncate">{selected}</span>
              <span className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2">
                <ChevronUpDownIcon
                  className="h-5 w-5 text-gray-400"
                  aria-hidden="true"
                />
              </span>
            </ListboxButton>

            <Transition
              show={open}
              as={Fragment}
              leave="transition ease-in duration-100"
              leaveFrom="opacity-100"
              leaveTo="opacity-0"
            >
              <ListboxOptions className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md py-1 text-gray-300 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none dark:bg-slate-800 sm:text-sm">
                {options.map((option, index) => (
                  <ListboxOption
                    key={`${option}_${index}`}
                    value={option}
                    className={({ active }) =>
                      classNames(
                        active ? "bg-indigo-600 text-white" : "text-gray-300",
                        "relative cursor-default select-none py-2 pl-8 pr-4"
                      )
                    }
                  >
                    {({ selected, active }) => (
                      <>
                        <span
                          className={classNames(
                            selected ? "font-semibold" : "font-normal",
                            "block truncate"
                          )}
                        >
                          {option}
                        </span>

                        {selected ? (
                          <span
                            className={classNames(
                              active ? "text-white" : "text-indigo-600",
                              "absolute inset-y-0 left-0 flex items-center pl-1.5"
                            )}
                          >
                            <CheckIcon className="h-5 w-5" aria-hidden="true" />
                          </span>
                        ) : null}
                      </>
                    )}
                  </ListboxOption>
                ))}
              </ListboxOptions>
            </Transition>
          </div>
        </div>
      )}
    </Listbox>
  );
}


==== src/app/sidebar.tsx ====
"use client";

import { useState } from "react";
import { Header } from "./header";
import { MobileSidebar } from "./mobile-sidebar";
import { DesktopSidebar } from "./desktop-sidebar";

export function Sidebar() {
  const [sidebarOpen, setSidebarOpen] = useState<boolean>(false);

  return (
    <>
      <MobileSidebar
        sidebarOpen={sidebarOpen}
        setSidebarOpen={setSidebarOpen}
      />
      <DesktopSidebar />
      <Header onClick={() => setSidebarOpen(true)} />
    </>
  );
}


==== src/app/simpson/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu"
import { ImageAreaProps } from "@/types";
import { Field, Input, Label, Description, } from "@headlessui/react";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const themes = ["Modern", "Vintage", "Minimalist", "Professional"];
const rooms = ["Living Room", "Dining Room", "Bedroom", "Bathroom", "Office"];

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a product and let our AI generate a new background.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [prompt, setPrompt] = useState<string | null>(null);
  const [theme, setTheme] = useState<string>(themes[0]);
  const [room, setRoom] = useState<string>(rooms[0]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file || !prompt) {
      setError("Please upload an image & fill the prompt");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/simpson", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image, prompt }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    // Output returns an array of two images
    // Here we show the second image
    setOutputImage(result.output[0]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      {/* <section className="mx-4 mt-9 flex w-fit flex-col space-y-8 lg:mx-6 lg:flex-row lg:space-x-8 lg:space-y-0 xl:mx-8"> */}
        {/* <Input name="full_name" type="text" /> */}
        {/* <SelectMenu
          label="Model"
          options={themes}
          selected={theme}
          onChange={setTheme}
        />
        <SelectMenu
          label="Room type"
          options={rooms}
          selected={room}
          onChange={setRoom}
        /> */}
      {/* </section> */}
      <Field className="flex flex-col px-4 gap-1 lg:px-6 xl:gap-1 xl:px-8">
        <Label className="text-sm/6 font-medium text-white">Prompt</Label>
        <Description className="text-sm/6 text-white/50">Describe the simpson charachter.</Description>
        <Input 
        className="border bg-slate-500 rounded-lg w-full"
        name="prompt"
        onChange={(e)=> setPrompt(e.target.value)}
        />
      </Field>

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/app/upscaler/page.tsx ====
"use client";

import Dropzone from "react-dropzone";
import { saveAs } from "file-saver";
import { useState } from "react";
import { FileRejection } from "react-dropzone";
import { ThreeDots } from "react-loader-spinner";
import { FaTrashAlt } from "react-icons/fa";
import { FaDownload } from "react-icons/fa";
import { XCircleIcon } from "@heroicons/react/20/solid";
import { PhotoIcon } from "@heroicons/react/24/outline";
import { SparklesIcon } from "@heroicons/react/24/outline";
import { SelectMenu } from "@/app/selectmenu";
import { ImageAreaProps } from "@/types";

type ErrorNotificationProps = {
  errorMessage: string;
};

type ActionPanelProps = {
  isLoading: boolean;
  submitImage(): void;
};

type UploadedImageProps = {
  image: File;
  removeImage(): void;
  file: {
    name: string;
    size: string;
  };
};

type ImageOutputProps = ImageAreaProps & {
  loading: boolean;
  outputImage: string | null;
  downloadOutputImage(): void;
};

const acceptedFileTypes = {
  "image/jpeg": [".jpeg", ".jpg", ".png"],
};

const maxFileSize = 5 * 1024 * 1024; // 5MB

/**
 * Display an error notification
 * @param {ErrorNotificationProps} props The component props
 */
function ErrorNotification({ errorMessage }: ErrorNotificationProps) {
  return (
    <div className="mx-4 mb-10 rounded-md bg-red-50 p-4 lg:mx-6 xl:mx-8">
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <p className="text-sm font-medium text-red-800">{errorMessage}</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Display the action panel
 * @param {ActionPanelProps} props The component props
 */
function ActionPanel({ isLoading, submitImage }: ActionPanelProps) {
  const isDisabled = isLoading;

  return (
    <section className="mx-4 bg-gray-900 shadow sm:rounded-lg lg:mx-6 xl:mx-8">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-start sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-300 lg:text-xl">
              Upload a photo or image
            </h3>
            <div className="mt-2 max-w-xl text-sm text-gray-500">
              <p>
                Upload an image of a room and let our AI generate a new design.
              </p>
            </div>
          </div>
          <div className="mt-5 sm:ml-6 sm:mt-0 sm:flex sm:flex-shrink-0 sm:items-center">
            <button
              type="button"
              disabled={isDisabled}
              onClick={submitImage}
              className={`${
                isDisabled
                  ? "cursor-not-allowed bg-indigo-300 text-gray-300 hover:bg-indigo-300 hover:text-gray-300"
                  : "bg-indigo-600 text-white"
              } inline-flex items-center rounded-md px-3 py-2 text-sm font-semibold shadow-sm transition-all duration-300 hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600 lg:px-3.5 lg:py-2.5`}
            >
              Design
              <SparklesIcon className="ml-2 h-4 w-4 text-gray-300" />
            </button>
          </div>
        </div>
      </div>
    </section>
  );
}

/**
 * Display the image output
 * @param {ImageOutputProps} props The component props
 */
function ImageOutput(props: ImageOutputProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button
        type="button"
        className={`${
          props.loading ? "flex items-center justify-center" : ""
        } relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        {!props.outputImage && props.loading ? (
          <span className="flex flex-col items-center">
            <ThreeDots
              height="50"
              width="60"
              color="#eee"
              ariaLabel="three-dots-loading"
              visible={props.loading}
            />
            <span className="block text-sm font-semibold text-gray-300">
              Processing the output image
            </span>
          </span>
        ) : null}

        {!props.outputImage && !props.loading ? (
          <>
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </>
        ) : null}

        {!props.loading && props.outputImage ? (
          <img
            src={props.outputImage}
            alt="output"
            className="h-full w-full object-cover"
          />
        ) : null}
      </button>

      {!props.loading && props.outputImage ? (
        <button
          onClick={props.downloadOutputImage}
          className="group absolute right-1 top-1 bg-yellow-500 p-2 text-black"
        >
          <FaDownload className="h-4 w-4 duration-300 group-hover:scale-110" />
        </button>
      ) : null}
    </section>
  );
}

/**
 * Display the uploaded image
 * @param {UploadedImageProps} props The component props
 */
function UploadedImage({ file, image, removeImage }: UploadedImageProps) {
  return (
    <section className="relative min-h-[206px] w-full">
      <button className="relative block h-full w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
        <img
          src={URL.createObjectURL(image)}
          alt={image.name}
          className="h-full w-full object-cover"
        />
      </button>

      <button
        className="group absolute right-1 top-1 rounded bg-yellow-500 p-2 text-black"
        onClick={removeImage}
      >
        <FaTrashAlt className="h-4 w-4 duration-300 group-hover:scale-110" />
      </button>

      <div className="text-md absolute left-0 top-0 bg-opacity-50 p-2 pl-3.5 text-white">
        {file.name} ({file.size})
      </div>
    </section>
  );
}

/**
 * Display the image dropzone
 * @param {ImageAreaProps} props The component props
 */
function ImageDropzone(
  props: ImageAreaProps & {
    onImageDrop(acceptedFiles: File[], rejectedFiles: FileRejection[]): void;
  }
) {
  return (
    <Dropzone
      onDrop={props.onImageDrop}
      accept={acceptedFileTypes}
      maxSize={maxFileSize}
      multiple={false}
    >
      {({ getRootProps, getInputProps }) => (
        <>
          <input {...getInputProps()} />
          <button
            {...getRootProps()}
            type="button"
            className="relative block min-h-[206px] w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            <props.icon className="mx-auto h-12 w-12 text-gray-400" />
            <span className="mt-2 block text-sm font-semibold text-gray-300">
              {props.title}
            </span>
          </button>
        </>
      )}
    </Dropzone>
  );
}

/**
 * Display the home page
 */
export default function HomePage() {
  const [outputImage, setOutputImage] = useState<string | null>(null);
  const [base64Image, setBase64Image] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>("");
  const [file, setFile] = useState<File | null>(null);

  /**
   * Handle the image drop event
   * @param {Array<File>} acceptedFiles The accepted files
   * @param {Array<FileRejection>} rejectedFiles The rejected files
   * @returns void
   */
  function onImageDrop(
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ): void {
    // Check if any of the uploaded files are not valid
    if (rejectedFiles.length > 0) {
      console.info(rejectedFiles);
      setError("Please upload a PNG or JPEG image less than 5MB.");
      return;
    }

    removeImage();

    console.info(acceptedFiles);
    setError("");
    setFile(acceptedFiles[0]);

    // Convert to base64
    convertImageToBase64(acceptedFiles[0]);
  }

  /**
   * Convert the image to base64
   * @param {File} file The file to convert
   * @returns void
   */
  function convertImageToBase64(file: File): void {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Image(binaryStr);
    };
  }

  /**
   * Convert the file size to a human-readable format
   * @param {number} size The file size
   * @returns {string}
   */
  function fileSize(size: number): string {
    if (size === 0) {
      return "0 Bytes";
    }

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(size) / Math.log(k));

    return parseFloat((size / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  /**
   * Remove the uploaded image
   * @returns void
   */
  function removeImage(): void {
    setFile(null);
    setOutputImage(null);
  }

  /**
   * Download the output image
   * @returns void
   */
  function downloadOutputImage(): void {
    saveAs(outputImage as string, "output.png");
  }

  /**
   * Submit the image to the server
   * @returns {Promise<void>}
   */
  async function submitImage(): Promise<void> {
    if (!file) {
      setError("Please upload an image.");
      return;
    }

    setLoading(true);

    const response = await fetch("/api/upscale", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: base64Image }),
    });

    const result = await response.json();
    console.log(result);

    if (result.error) {
      setError(result.error);
      setLoading(false);
      return;
    }

    setOutputImage(result.output[0]);
    setLoading(false);
  }

  return (
    <main className="flex min-h-screen flex-col py-10 lg:pl-72">
      {error ? <ErrorNotification errorMessage={error} /> : null}
      <ActionPanel isLoading={loading} submitImage={submitImage} />

      <section className="mt-10 grid flex-1 gap-6 px-4 lg:px-6 xl:grid-cols-2 xl:gap-8 xl:px-8">
        {!file ? (
          <ImageDropzone
            title={`Drag 'n drop your image here or click to upload`}
            onImageDrop={onImageDrop}
            icon={PhotoIcon}
          />
        ) : (
          <UploadedImage
            image={file}
            removeImage={removeImage}
            file={{ name: file.name, size: fileSize(file.size) }}
          />
        )}

        <ImageOutput
          title={`AI-generated output goes here`}
          downloadOutputImage={downloadOutputImage}
          outputImage={outputImage}
          icon={SparklesIcon}
          loading={loading}
        />
      </section>
    </main>
  );
}


==== src/common/configuration.ts ====
import { Configurations } from "@/types";

const configurationsObj: Configurations = [
  {
    name: 'pyramid-flow',
    type: 'gradio',
    client: 'Pyramid-Flow/pyramid-flow',
    path: '/generate_video',
    inputs: [
      { component: 'prompt', type: 'string', key: 'prompt', value: null, show: true },
      { component: 'image', type: 'string', key: 'image', value: null, show: true },
      { component: 'prompt', type: 'integer', key: 'duration', value: 1, show: false },
      { component: 'prompt', type: 'integer', key: 'guidance_scale', value: 1 },
      { component: 'prompt', type: 'integer', key: 'video_guidance_scale', value: 1 },
      { component: 'prompt', type: 'integer', key: 'frames_per_second', value: 8 }
    ],
    outputs: [
      { component: 'video', type: 'string', key: 'visualitation', placeholder: 'video output', show: true }
    ]
  },
  {
    name: 'Hivision',
    type: 'gradio',
    client: 'TheEeeeLin/HivisionIDPhotos',
    path: '/idphoto_inference',
    inputs: [
      { component: 'image', type: 'string', key: 'input_image', value: 'https://theeeeelin-hivisionidphotos.hf.space/file=/tmp/gradio/5bf86fbc980e461b32c5e52a47b8f5c0909f27e3ab146f7e0155e72f49be4e06/test2.jpg', show: true },
      { component: 'prompt', type: 'string', key: 'mode_option', label: 'Mode Option', value: "Size List", show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'size_list_option', label: 'Size List Option', value: "One inch (413, 295)", show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'color_option', label: 'Color Option', value: "Blue", show: true }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'render_option', label: 'Render Option', value: "Solid Color", show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'image_kb_options', label: 'Image KB Options', value: "Not Set", show: false },
      { component: 'number', type: 'integer', key: 'custom_color_R', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'custom_color_G', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'custom_color_B', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'custom_size_height', value: 413, show: false }, // Added component and changed show to false
      { component: 'number', type: 'integer', key: 'custom_size_width', value: 295, show: false }, // Added component and changed show to false
      { component: 'number', type: 'integer', key: 'custom_image_kb', value: 50, show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'language', label: 'Language', value: "English", show: false }, // Added component and changed show to false
      { component: 'prompt', type: 'string', key: 'matting_model_option', label: 'Matting Model Option', value: "modnet_photographic_portrait_matting", show: false }, // Added component and changed show to false
    ],
    outputs: [
      { component: 'image', type: 'string', placeholder: 'Visualitation', key:'visulization', show: true },
      { component: 'image', type: 'string', placeholder: 'mask', key:'mask', show: true },
    ],
  },
  {
    name: 'FineGrainImageEnhancer',
    type: 'gradio',
    client: 'finegrain/finegrain-image-enhancer',
    path: '/process',
    inputs: [
      { component: 'image', type: 'string', key: 'input_image', value: null, show: true }, // Added input for image
      { component: 'prompt', type: 'string', key: 'prompt', value: "Hello!!", show: false },
      { component: 'prompt', type: 'string', key: 'negative_prompt', value: "Hello!!", show: false },
      { component: 'number', type: 'integer', key: 'seed', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'upscale_factor', value: 1, show: false },
      { component: 'number', type: 'integer', key: 'controlnet_scale', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'controlnet_decay', value: 0.5, show: false },
      { component: 'number', type: 'integer', key: 'condition_scale', value: 2, show: false },
      { component: 'number', type: 'integer', key: 'tile_width', value: 64, show: false },
      { component: 'number', type: 'integer', key: 'tile_height', value: 64, show: false },
      { component: 'number', type: 'integer', key: 'denoise_strength', value: 0, show: false },
      { component: 'number', type: 'integer', key: 'num_inference_steps', value: 1, show: false },
      { component: 'prompt', type: 'string', key: 'solver', value: "DDIM", show: false },
    ],
    outputs: [
      { component: 'image', type: 'string', placeholder: 'Processed Image', key: 'output_image', show: true },
    ],
  },
  {
    name: 'EVF-SAM',
    type: 'gradio',
    client: 'wondervictor/evf-sam',
    path: '/predict',
    inputs: [
      { component: 'image', type: 'string', key: 'image_np', value: null, show: true },
      { component: 'prompt' ,type: 'string', key: 'prompt', label: 'Prompt', description: 'Use a phrase or sentence to describe the object you want to segment. Currently we only support English', value: null, show: true },
    ],
    outputs: [
      { component: 'image', type: 'array', placeholder: 'Visualitation', key:'visulization', show: true },
      { component: 'image', type: 'array', placeholder: 'mask', key:'mask', show: true },
    ],
  },
  {
    name: 'Spanish-F5',
    type: 'gradio',
    client: 'jpgallegoar/Spanish-F5',
    path: '/predict',
    inputs: [
      { component: 'image', type: 'string', key: 'image_np', value: null, show: true },
      { component: 'prompt' ,type: 'string', key: 'prompt', label: 'Prompt', description: 'Use a phrase or sentence to describe the object you want to segment. Currently we only support English', value: null, show: true },
    ],
    outputs: [
      { component: 'image', type: 'array', placeholder: 'Visualitation', key:'visulization', show: true },
      { component: 'image', type: 'array', placeholder: 'mask', key:'mask', show: true },
    ],
  },
  {
    name: 'logo-context',
    type: 'gradio',
    client: 'multimodalart/logo-in-context',
    path: '/generate',
    inputs: [
      { component: 'image', type: 'string', key: 'image', placeholder: 'Upload Logo Imagen',value: null, show: true }, // Added input for image
      { component: 'prompt', type: 'string', key: 'prompt_description', label: 'Describe your logo', value: "Hello!!", show: true },
      { component: 'prompt', type: 'string', key: 'prompt_user', label: 'Where should the logo be applied?', value: "Hello!!", show: true },
    ],
    outputs: [
      { component: 'image', type: 'array', placeholder: 'Processed Image', key: 'output_image', show: true },
    ],
  },
  {
    name: 'consistent-character-gradio',
    type: 'gradio',
    client: 'Kwai-Kolors/Kolors-Character-With-Flux',
    path: '/generate',
    inputs: [
      { component: 'image', type: 'string', key: 'image', placeholder: 'Upload Logo Imagen',value: null, show: true }, // Added input for image
      { component: 'prompt', type: 'string', key: 'prompt_description', label: 'Describe your logo', value: "Hello!!", show: true },
      { component: 'prompt', type: 'string', key: 'prompt_user', label: 'Where should the logo be applied?', value: "Hello!!", show: true },
    ],
    outputs: [
      { component: 'image', type: 'string', placeholder: 'Processed Image', key: 'output_image', show: true },
    ],
  },
  {
    name: "flux-ip-adapter",
    type: "gradio",
    client: "InstantX/flux-IP-adapter",
    path: "/process_image",
    inputs: [
      { component: 'image', type: 'string', key: 'image', placeholder: 'Upload Logo Imagen',value: null, show: true },
      { component: 'prompt', type: 'string', key: 'prompt', label: 'Describe your logo', value: "Hello!!", show: true },
      { component: 'prompt', type: 'integer', key: 'scale', value: 0.7, show: false },
      { component: 'prompt', type: 'integer', key: 'seed', value: 42, show: false },
      { component: 'checkbox', type: 'boolean', key: 'randomize_seed', value: true, show: false },
      { component: 'checkbox', type: 'boolean', key: 'width', value: 1024, show: false },
      { component: 'checkbox', type: 'boolean', key: 'height', value: 1024, show: false },
    ],
    outputs: [
      { component: 'image', type: 'array', format: 'string', placeholder: 'Processed Image', key: 'output_image', show: true },
      { component: 'prompt', type: 'array', placeholder: 'Processed Image', key: 'seed', show: true },
    ]
  },
  {
    name: 'consistent-character-replicate',
    type: 'replicate',
    model: 'fofr/consistent-character',
    version: '9c77a3c2f884193fcee4d89645f02a0b9def9434f9e03cb98460456b831c8772',
    inputs: [
      { component: 'prompt', type: 'string', key: 'prompt', label: 'Prompt', description: 'the prompt to generate the character', value: 'A closeup headshot photo of a young woman in a grey sweater', show: true },
      { component: 'image', type: 'string', key: 'subject', value: 'https://replicate.delivery/pbxt/L0gy7uyLE5UP0uz12cndDdSOIgw5R3rV5N6G2pbt7kEK9dCr/0_3.webp', show: true },
      { component: 'prompt', type: 'string', key: 'output_format', value: 'webp', show: false },
      { component: 'prompt', type: 'integer', key: 'output_quality', value: 80, show: false },
      { component: 'prompt', type: 'string', key: 'negative_prompt', value: "", show: false },
      { component: 'prompt', type: 'boolean', key: 'randomise_poses', value: true, show: false },
      { component: 'number', type: 'boolean', key: 'number_of_outputs', label: 'number of outputs', value: 5, show: false },
      { component: 'number', type: 'boolean', key: 'number_of_images_per_pose', label: 'number of images per pose', value: 1, show: false },
    ],
    outputs: [
      { component: 'image', type: 'array', typeItem: 'string', format: 'uri', placeholder: 'characther', key:'output', show: true },
    ],
  },{
    "name": "HiDream",
    "type": "gradio",
    "client": "HiDream-ai/HiDream-I1-Dev",
    "path": "/predict",
    "endpoint": "/generate_with_status",
    "inputs": [
      {
        "type": "string",
        "key": "prompt",
        "show": true,
        "placeholder": "",
        "gradioName": "",
        "label": "Prompt",
        "description": "",
        "component": "Textbox",
        "value": null
      },
      {
        "type": "string",
        "key": "aspect_ratio",
        "show": false,
        "placeholder": "",
        "gradioName": "",
        "label": "Aspect Ratio",
        "description": "",
        "component": "Textbox",
        "value": "4:3"
      },
      {
        "type": "integer",
        "key": "seed",
        "show": false,
        "placeholder": "",
        "gradioName": "",
        "label": "Seed (use -1 for random)",
        "description": "",
        "component": "number",
        "value": 82706
      }
    ],
    "outputs": [
      {
        "type": "string",
        "key": "generated_image",
        "show": true,
        "placeholder": "",
        "component": "image",
      },
      {
        "type": "number",
        "key": "seed_used",
        "show": false,
        "placeholder": "",
        "component": "prompt",
      },
      {
        "type": "string",
        "key": "value_15",
        "show": false,
        "placeholder": "",
        "component": "prompt",
      },
      {
        "type": "string",
        "key": "details",
        "show": false,
        "placeholder": "",
        "component": "prompt",
      }
    ]
  }
]

// New function to fetch configurations
async function fetchConfigurations(timestamp?: number) {
  try {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const url = `${baseUrl}/api/create/get${timestamp ? `?timestamp=${timestamp}` : ''}`;
    const response = await fetch(url, { next: { revalidate: 3600 } });
    if (!response.ok) throw new Error('Failed to fetch configurations');
    return response.json();
  } catch (error) {
    console.error('Error fetching configurations:', error);
    return null;
  }
}

// Combine local configurations with fetched configurations
async function getConfigurations(forceRefresh: boolean = false): Promise<Configurations> {
  const timestamp = forceRefresh ? Date.now() : undefined;
  const fetchedConfigurations = await fetchConfigurations(timestamp);
  console.log({fetchedConfigurations});
  return fetchedConfigurations ? [...configurationsObj, ...fetchedConfigurations] : configurationsObj;
}

export  {getConfigurations};


==== src/common/index.ts ====
import { 
  HomeIcon,
  BoltIcon, 
  BoltSlashIcon, 
  SunIcon, 
  CubeTransparentIcon,
  CakeIcon,
  PaintBrushIcon,
  VideoCameraIcon,
  FaceSmileIcon,
  CpuChipIcon,
  MicrophoneIcon,
  SpeakerWaveIcon,
  PaperAirplaneIcon,
  UserCircleIcon
} from '@heroicons/react/24/outline';
import { NavItem } from '@/types';

export const navigation: Array<NavItem> = [
  { name: 'Interior Design', href: '/', icon: HomeIcon },
  { name: 'IlluminAI', href: '/illuminai', icon: SunIcon },
  { name: 'Upscaler', href: '/app/upscaler', icon:  CubeTransparentIcon},
  { name: 'Enhance Background', href: '/enhancebg', icon: BoltIcon },
  { name: 'Remove Background', href: '/removebg', icon: BoltSlashIcon },
  { name: 'Become Simpson', href: '/simpson', icon: CakeIcon },
  { name: 'FreshInk', href: '/app/freshink', icon: PaintBrushIcon },
  { name: 'Create Video', href: '/app/createVideo', icon: VideoCameraIcon },
  { name: 'Hair Style', href: '/app/hairStyle', icon: FaceSmileIcon },
  { name: 'Live Portrait', href: '/app/livePortrait', icon: MicrophoneIcon },
  { name: 'tts', href: '/on-device/tts', icon: SpeakerWaveIcon },
  { name: 'Trip Planner', href: '/chat/trip', icon: PaperAirplaneIcon },
  { name: 'TryOn', href: '/app/tryon', icon: UserCircleIcon },
  { name: 'Sam2', href: '/app/sam2', icon: UserCircleIcon },
  { name: 'Logo', href: '/app/logo', icon: UserCircleIcon },
  { name: 'EVF-SAM', href: '/app/EVF-SAM', icon: UserCircleIcon },
];


==== src/components/AppPreview.tsx ====
import { useState, useEffect, useRef } from 'react';
import { Configuration } from '@/types';
import { PhotoIcon, FaceSmileIcon, SparklesIcon, VideoCameraIcon, MicrophoneIcon } from "@heroicons/react/24/outline";
import { ThreeDots } from "react-loader-spinner";
import { Prompt } from './prompt';
import { NumberInput, Slider, Checkbox, CheckboxGroup, NumberOutput } from './numericInput';
import { FaDownload } from "react-icons/fa";
import { SelectMenu } from "@/app/selectmenu";
import Dropzone, { FileRejection } from 'react-dropzone';

interface AppPreviewProps {
  config: Configuration & {
    endpoints?: string[];
  };
  onEndpointChange?: (endpoint: string) => void;
  onAppNameChange?: (name: string) => void;
}

export default function AppPreview({ config, onEndpointChange, onAppNameChange }: AppPreviewProps) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [inputValues, setInputValues] = useState<{ [key: string]: string | number | boolean | null }>({});
  const [outputValues, setOutputValues] = useState<{ [key: string]: string | number | boolean | null }>({});

  const [files, setFiles] = useState<Record<string, File>>({});
  const [base64Images, setBase64Images] = useState<Record<string, string>>({});

  // Reset all states when endpoint changes
  useEffect(() => {
    setInputValues({});
    setOutputValues({});
    setFiles({});
    setBase64Images({});
    setError(null);
  }, [config.endpoint]);

  // Initialize input values from config
  useEffect(() => {
    const initialValues: Record<string, any> = {};
    config.inputs.forEach(input => {
      if (input.show) {
        initialValues[input.key] = input.value ?? null;
      }
    });
    setInputValues(initialValues);
  }, [config.inputs]);

  const handleInputChange = (key: string, value: any) => {
    setInputValues(prev => ({
      ...prev,
      [key]: value
    }));
  };

  const onImageDrop = (
    acceptedFiles: File[],
    rejectedFiles: FileRejection[],
    key: string
  ): void => {
    if (rejectedFiles.length > 0) {
      setError(`Please upload a PNG or JPEG image less than 5MB.`);
      return;
    }

    setError("");
    setFiles(prev => ({ ...prev, [key]: acceptedFiles[0] }));

    // Convert to base64
    const reader = new FileReader();
    reader.readAsDataURL(acceptedFiles[0]);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Images(prev => ({ ...prev, [key]: binaryStr }));
      handleInputChange(key, binaryStr);
    };
  };

  const onAudioDrop = (
    acceptedFiles: File[],
    rejectedFiles: FileRejection[],
    key: string
  ): void => {
    if (rejectedFiles.length > 0) {
      setError(`Please upload an MP3, WAV or OGG audio file less than 10MB.`);
      return;
    }

    setError("");
    setFiles(prev => {
      const newFiles = { ...prev };
      if (acceptedFiles[0]) {
        newFiles[key] = acceptedFiles[0];
      } else {
        delete newFiles[key];
      }
      return newFiles;
    });

    // Convert to base64
    const reader = new FileReader();
    reader.readAsDataURL(acceptedFiles[0]);
    reader.onload = () => {
      const binaryStr = reader.result as string;
      setBase64Images(prev => {
        const newImages = { ...prev };
        if (binaryStr) {
          newImages[key] = binaryStr;
        } else {
          delete newImages[key];
        }
        return newImages;
      });
      handleInputChange(key, binaryStr);
    };
  };

  const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
  const eventSourceRef = useRef<EventSource | null>(null);

  // Cleanup SSE connection on component unmount
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        console.log("Closing SSE connection on unmount");
        eventSourceRef.current.close();
      }
    };
  }, []);

  const fetchRegularPreview = async () => {
    console.log('Fetching regular preview');
    setLoading(true);
    setOutputValues({});
    setError(null);

    try {
      const params: any = {};
      config.inputs.forEach(input => {
        if (!input.show) return;
        params[input.key] = inputValues[input.key] ?? null;
        if (input.component === 'image' && base64Images[input.key]) {
          params[input.key] = base64Images[input.key];
        }
        // Add handling for other file types if needed (audio, video)
      });

      const response = await fetch('/api/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ config, params })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Request failed with status ' + response.status }));
        throw new Error(errorData.error || `Request failed with status ${response.status}`);
      }

      const responseData = await response.json();
      // Define a type for the expected result structure
      type PredictionResult = {
        status: 'succeeded' | 'failed' | 'processing' | 'starting';
        output?: any; // Can be array, object, or primitive
        error?: string;
      };

      let result: PredictionResult;

      if (responseData.id && config.type === 'replicate') { // Only poll for Replicate
        console.log("Polling Replicate prediction:", responseData.id);
        let status = responseData.status;
        let pollCount = 0;
        const maxPolls = 60; // Poll for max 60 seconds

        // Initialize result before loop
        result = { status: responseData.status, output: responseData.output };

        while (status !== 'succeeded' && status !== 'failed' && pollCount < maxPolls) {
          await sleep(1000);
          const pollResponse = await fetch(`/api/preview/get?id=${responseData.id}`);
          // Assign the fetched result, ensuring it matches PredictionResult type
          result = await pollResponse.json() as PredictionResult;
          console.log("Poll status:", result.status);
          if (result.error) throw new Error(result.error);
          status = result.status;
          pollCount++;
        }
        if (status === 'failed') throw new Error(result.error || 'Processing failed');
        if (pollCount >= maxPolls && status !== 'succeeded') throw new Error('Prediction timed out');

      } else { // Gradio or immediate Replicate result
        result = { status: 'succeeded', output: responseData.output };
      }

      // Map outputs
      const outputs: Record<string, any> = {};
      console.log('Mapping outputs:', { result, configOutputs: config.outputs });
      (config.outputs || []).forEach((output, index) => {
        if (!output.show || !result || result.output === undefined) return; // Add checks for result and result.output

        if (Array.isArray(result.output)) {
           if (output.type === 'array') {
             outputs[output.key] = result.output; // Assign whole array if expected
           } else {
             // Ensure index is within bounds
             if (index < result.output.length) {
              outputs[output.key] = result.output[index]; // Assign by index otherwise
             } else {
              console.warn(`Output index ${index} out of bounds for result array.`);
             }
           }
        } else if (typeof result.output === 'object' && result.output !== null) {
           // Handle cases where output might be an object with keys matching output keys
          outputs[output.key] = result.output[output.key] ?? result.output;
        } else {
           // Assign single value to the first output key
          if (index === 0) {
          outputs[output.key] = result.output;
          }
        }
      });

      console.log('Setting outputs:', outputs);
      setOutputValues(outputs);
    } catch (err) {
      console.error("Regular preview fetch error:", err);
      setError(err instanceof Error ? err.message : 'An error occurred during preview.');
    } finally {
      setLoading(false);
    }
  };

  const handleSubmitPreview = async () => {
    console.log('App Preview Submit');
    setError(null);
    setOutputValues({}); // Clear previous outputs

    // Close any existing SSE connection
    if (eventSourceRef.current) {
      console.log("Closing previous SSE connection");
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }

    // Validate inputs
    let hasErrors = false;
    config.inputs.forEach(input => {
      if (!input.show) return;
      // Basic check: if required is true (or undefined, assuming required by default if shown)
      // and the value is null/undefined/empty string, and it's not a file input with a file selected
      const isFileSelected = (input.component === 'image' || input.component === 'audio' || input.component === 'video') && files[input.key];
      const valueIsEmpty = inputValues[input.key] === null || inputValues[input.key] === undefined || inputValues[input.key] === '';

      if ((input.required !== false) && valueIsEmpty && !isFileSelected) {
        setError(`Input "${input.label || input.key}" is required.`);
        hasErrors = true;
      }
    });
    if (hasErrors) return;

    setLoading(true);

    // Check feature flag and app type
    const useSSE = process.env.NEXT_PUBLIC_USE_SSE_EXPERIMENTAL === 'true' && config.type === 'gradio';
    console.log('Using SSE:', useSSE);
    console.log('Input values:', inputValues);

    if (useSSE) {
      console.log('Attempting SSE connection for Gradio preview...');
      try {
        // Construct query parameters for SSE endpoint
        const params = new URLSearchParams();
        params.append('client', config.client || '');
        params.append('endpoint', config.endpoint || '');

        // Add input values to query params
        config.inputs.forEach(input => {
          if (input.show) {
            const value = inputValues[input.key];
            if (value !== null && value !== undefined) {
              // Handle file inputs (send base64)
              if ((input.component === 'image' || input.component === 'audio' || input.component === 'video') && base64Images[input.key]) {
                 params.append(input.key, base64Images[input.key]);
              } else if (typeof value === 'boolean') {
                 params.append(input.key, value.toString());
              } else {
                 params.append(input.key, String(value)); // Convert numbers etc. to string
              }
            }
          }
        });

        // Phase 1: POST to /init to get event_id
        const inputData: any[] = [];
        config.inputs.forEach(input => {
          if (input.show) {
            const value = inputValues[input.key];
            if ((input.component === 'image' || input.component === 'audio' || input.component === 'video') && base64Images[input.key]) {
              inputData.push({ 
                name: files[input.key]?.name || 'input_file', 
                data: base64Images[input.key], 
                is_file: true 
              });
            } else {
              inputData.push(value ?? null);
            }
          } else {
            inputData.push(input.value ?? null);
          }
        });

        const initResponse = await fetch('/api/experimental/sse/init', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            client: config.client,
            endpoint: config.endpoint,
            inputs: inputData
          })
        });

        if (!initResponse.ok) {
          const errorData = await initResponse.json().catch(() => ({ error: 'Init request failed' }));
          throw new Error(errorData.error || `SSE Init failed: ${initResponse.status}`);
        }

        const { event_id, client: returnedClient } = await initResponse.json();
        if (!event_id) throw new Error('Did not receive event_id from init endpoint');

        // Phase 2: GET from /stream using the event_id
        const streamUrl = `/api/experimental/sse/stream?event_id=${event_id}&client=${returnedClient}&endpoint=${config.endpoint}`;
        const eventSource = new EventSource(streamUrl);
        eventSourceRef.current = eventSource; // Store reference for cleanup

        eventSource.onmessage = (event) => {
          console.log('SSE Message:', event.data ? event.data.substring(0,100) + '...' : 'No data');
          setLoading(false); // Stop loading indicator on first message (might be heartbeat or generating)
          try {
            // Check for specific SSE events if the backend sends them
             if (event.type === 'message') { // Default event type
               const messageData = JSON.parse(event.data);
               // Assuming messageData is the array of outputs or final result object
               const outputs: Record<string, any> = {};
                (config.outputs || []).forEach((output, index) => {
                  if (!output.show) return;
                  if (Array.isArray(messageData)) {
                    outputs[output.key] = messageData[index];
                  } else if (typeof messageData === 'object' && messageData !== null) {
                    outputs[output.key] = messageData[output.key] ?? messageData; // Try matching key or assign whole object
                  } else {
                    // Assign single value to the first output key
                    if (index === 0) {
                       outputs[output.key] = messageData;
                    }
                  }
                });
                setOutputValues(prev => ({ ...prev, ...outputs })); // Merge updates
             } else if (event.type === 'generating') {
                console.log("SSE Generating:", event.data);
                // Potentially update UI with intermediate state
             } else if (event.type === 'complete') {
                console.log("SSE Complete event received.");
                eventSource.close();
                eventSourceRef.current = null;
             } else if (event.type === 'heartbeat') {
                console.log("SSE Heartbeat");
             }

          } catch (parseError) {
            console.error('Error parsing SSE data:', parseError, "Raw data:", event.data);
            setError('Received invalid data from server.');
            eventSource.close();
            eventSourceRef.current = null;
            setLoading(false);
          }
        };

        eventSource.onerror = (error) => {
          console.error('SSE Error:', error);
          // Avoid setting error if it was just closed normally
          if (eventSourceRef.current) {
             setError('SSE connection failed.');
             eventSource.close();
             eventSourceRef.current = null;
             setLoading(false);
          }
          // Optional: Fallback to regular fetch
          // fetchRegularPreview();
        };

        // Note: The backend currently sends 'message' event. If it sends 'complete' or custom 'error_event',
        // add specific listeners here like:
        // eventSource.addEventListener('complete', () => { ... });
        // eventSource.addEventListener('error_event', (event: any) => { ... });


      } catch (err) {
        console.error('Error initiating SSE:', err);
        setError(err instanceof Error ? err.message : 'Failed to start SSE connection.');
        setLoading(false);
        // Optional: Fallback
        // fetchRegularPreview();
      }
    } else {
      // Use existing fetch implementation for Replicate or if SSE is disabled
      fetchRegularPreview();
    }
  };

  const downloadOutputImage = (url: string) => {
    const link = document.createElement('a');
    link.href = url;
    link.download = 'output.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const downloadOutputAudio = (url: string) => {
    const link = document.createElement('a');
    link.href = url;
    link.download = 'output.mp3';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="mx-auto w-full max-w-4xl">
      <div className="flex flex-col space-y-8">
        <div className="space-y-4">
          <div className="flex items-center space-x-4">
            <label className="text-sm font-medium text-gray-300">App Name:</label>
            <input
              type="text"
              value={config.name || ''}
              onChange={(e) => onAppNameChange?.(e.target.value)}
              placeholder="Enter app name"
              className="flex-grow px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          {config.type === 'gradio' && (
            <div className="flex items-center space-x-4">
              <label className="text-sm font-medium text-gray-300">Endpoint:</label>
              <select
                value={config.endpoint}
                onChange={(e) => onEndpointChange?.(e.target.value)}
                className="flex-grow px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                {config.endpoints?.map(item => (
                  <option key={item} value={item}>{item}</option>
                ))}
              </select>
            </div>
          )}
        </div>
        {error && (
          <div className="rounded-md bg-red-50 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-red-700">{error}</p>
              </div>
            </div>
          </div>
        )}

        <div className="grid grid-cols-2 gap-8">
          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-300">Inputs</h3>
            {config.inputs.map((input, index) => {
              if (!input.show) return null;

              switch (input.component.toLowerCase()) {
                case 'prompt':
                  return (
                    <Prompt
                      key={index}
                      label={input.label || input.key}
                      placeholder={input.placeholder || ''}
                      description={input.description || ''}
                      placeholderTextArea={input.value?.toString() || ''}
                      setPrompt={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'textbox':
                  return (
                    <Prompt
                      key={index}
                      label={input.label || input.key}
                      placeholder={input.placeholder || ''}
                      description={input.description || ''}
                      placeholderTextArea={input.value?.toString() || ''}
                      setPrompt={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'image':
                  return (
                    <Dropzone
                      key={index}
                      onDrop={(accepted, rejected) => onImageDrop(accepted, rejected, input.key)}
                      accept={{ 'image/*': ['.png', '.jpg', '.jpeg'] }}
                      maxSize={5 * 1024 * 1024}
                    >
                      {({ getRootProps, getInputProps }) => (
                        <div {...getRootProps()} className="relative block w-full rounded-lg border-2 border-dashed border-gray-300 p-12 text-center hover:border-gray-400 focus:outline-none">
                          <input {...getInputProps()} />
                          {files[input.key] ? (
                            <img
                              src={URL.createObjectURL(files[input.key])}
                              alt="Preview"
                              className="mx-auto h-48 w-auto object-contain"
                            />
                          ) : (
                            <>
                              <PhotoIcon className="mx-auto h-12 w-12 text-gray-400" />
                              <span className="mt-2 block text-sm font-medium text-gray-300">
                                Drop an image here or click to upload
                              </span>
                            </>
                          )}
                        </div>
                      )}
                    </Dropzone>
                  );
                case 'number':
                  return (
                    <NumberInput
                      key={index}
                      label={input.label || input.key}
                      description={input.description}
                      min={input.min}
                      max={input.max}
                      step={input.step}
                      defaultValue={input.value as number}
                      onChange={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'slider':
                  return (
                    <Slider
                      key={index}
                      label={input.label || input.key}
                      description={input.description}
                      min={input.min}
                      max={input.max}
                      step={input.step}
                      defaultValue={input.value as number}
                      onChange={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'checkbox':
                  return (
                    <Checkbox
                      key={index}
                      label={input.label || input.key}
                      description={input.description}
                      defaultChecked={input.value as boolean}
                      onChange={(checked) => handleInputChange(input.key, checked)}
                    />
                  );
                case 'dropdown':
                  return (
                    <SelectMenu
                      key={index}
                      label={input.label || input.key}
                      options={input.options || []}
                      selected={input.value as string || (input.options || [])[0] || ''}
                      onChange={(value) => handleInputChange(input.key, value)}
                    />
                  );
                case 'audio':
                  return (
                    <Dropzone
                      key={index}
                      onDrop={(accepted, rejected) => onAudioDrop(accepted, rejected, input.key)}
                      accept={{ 'audio/*': ['.mp3', '.wav', '.ogg'] }}
                      maxSize={10 * 1024 * 1024}
                    >
                      {({ getRootProps, getInputProps }) => (
                        <div {...getRootProps()} className="relative block w-full rounded-lg border-2 border-dashed border-gray-300 p-6 text-center hover:border-gray-400 focus:outline-none">
                          <input {...getInputProps()} />
                          {files[input.key] ? (
                            <div className="space-y-2">
                              <div className="flex items-center justify-between">
                                <span className="text-sm font-medium text-gray-300 truncate max-w-xs">
                                  {files[input.key].name}
                                </span>
                                <span className="text-xs text-gray-400">
                                  {(files[input.key].size / (1024 * 1024)).toFixed(2)}MB
                                </span>
                              </div>
                              <audio 
                                src={URL.createObjectURL(files[input.key])} 
                                controls
                                className="w-full mt-2"
                              />
                              <button 
                                type="button"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setFiles(prev => {
                                    const newFiles = {...prev};
                                    delete newFiles[input.key];
                                    return newFiles;
                                  });
                                  setBase64Images(prev => {
                                    const newImages = {...prev};
                                    delete newImages[input.key];
                                    return newImages;
                                  });
                                }}
                                className="text-xs text-red-400 hover:text-red-300"
                              >
                                Remove Audio
                              </button>
                            </div>
                          ) : (
                            <>
                              <MicrophoneIcon className="mx-auto h-10 w-10 text-gray-400" />
                              <p className="mt-2 text-sm font-medium text-gray-300">
                                Drop audio file or click to browse
                              </p>
                              <p className="text-xs text-gray-400 mt-1">
                                MP3, WAV, OGG (max 10MB)
                              </p>
                            </>
                          )}
                        </div>
                      )}
                    </Dropzone>
                  );
                default:
                  return (
                    <div key={index}>
                      Unsupported input type: {input.component}
                    </div>
                  );
              }
            })}
          </div>

          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-300">Outputs</h3>
            {config.outputs?.map((output, index) => {
              if (!output.show) return null;

              return (
                <div key={index} className="relative">
                  <div className="mb-2 text-sm font-medium text-gray-300">
                    {output.title || output.key}
                    {loading ? (
                      <div className="flex h-full items-center justify-center">
                        <ThreeDots
                          height="50"
                          width="60"
                          color="#eee"
                          ariaLabel="loading"
                          visible={true}
                        />
                      </div>
                    ) : outputValues[output.key] ? (
                      <div className="relative">
                        {output.component === 'image' && (
                          <>
                            {console.log('Rendering image with:', {
                              outputKey: output.key,
                              value: outputValues[output.key],
                              fullOutputValues: outputValues
                            })}
                            <img
                              src={String(outputValues[output.key])}
                              alt={output.title || 'Output'}
                              className="h-full w-full rounded-lg object-contain"
                            />
                            <button
                              onClick={() => downloadOutputImage(String(outputValues[output.key]))}
                              className="absolute right-2 top-2 rounded bg-gray-700 p-2 hover:bg-gray-600"
                            >
                              <FaDownload className="h-4 w-4 text-gray-300" />
                            </button>
                          </>
                        )}
                        {(output.component === 'textbox' || output.component === 'prompt') && (
                          <div className="text-gray-300">
                            {String(outputValues[output.key])}
                          </div>
                        )}
                        {output.component === 'audio' && outputValues[output.key] && (
                          <div className="space-y-2">
                            <audio 
                              src={String(outputValues[output.key])} 
                              controls
                              className="w-full"
                            />
                            <button
                              onClick={() => downloadOutputAudio(String(outputValues[output.key]))}
                              className="flex items-center text-sm text-gray-300 hover:text-white"
                            >
                              <FaDownload className="mr-1 h-3 w-3" />
                              Download Audio
                            </button>
                          </div>
                        )}
                      </div>
                    ) : (
                      <div className="flex h-full items-center justify-center text-gray-500">
                        Output will appear here
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        <div className="flex justify-end">
          <button
            onClick={handleSubmitPreview}
            disabled={loading || !config.name}
            className={`inline-flex items-center rounded-md px-4 py-2 text-sm font-medium shadow-sm ${
              loading || !config.name
                ? 'cursor-not-allowed bg-gray-600 text-gray-400'
                : 'bg-indigo-600 text-white hover:bg-indigo-700'
            }`}
          >
            {loading ? 'Processing...' : 'Test Configuration'}
            <SparklesIcon className="ml-2 h-4 w-4" />
          </button>
        </div>
      </div>
    </div>
  );
}


==== src/components/audioOutput.tsx ====
type AudioOutputProps = {
  title?: string;
  audioUrl: string | null;
};

export function AudioOutput({ title, audioUrl }: AudioOutputProps) {
  return (
    <div className="w-80 p-4 rounded-lg border border-gray-600 bg-slate-800">
      <div className="text-sm font-medium text-gray-300 mb-2">
        {title || 'Audio Output'}
      </div>
      {audioUrl ? (
        <audio
          controls
          className="w-full"
          src={audioUrl}
        >
          Your browser does not support the audio element.
        </audio>
      ) : (
        <div className="text-gray-500 text-sm italic">
          No audio available yet
        </div>
      )}
    </div>
  );
}

==== src/components/numericInput.tsx ====
type NumberInputProps = {
  label: string;
  description?: string;
  min?: number;
  max?: number;
  step?: number;
  defaultValue?: number;
  onChange: (value: number) => void;
};

export function NumberInput({
  label,
  description,
  min = 0,
  max = 100,
  step = 1,
  defaultValue = 50,
  onChange
}: NumberInputProps) {
  return (
    <div className="w-80">
      <label className="block text-sm font-medium leading-6 text-gray-300">
        {label}
      </label>
      {description && (
        <div className="text-sm text-gray-500">
          {description}
        </div>
      )}
      <input
        type="number"
        min={min}
        max={max}
        step={step}
        defaultValue={defaultValue}
        onChange={(e) => onChange(Number(e.target.value))}
        className="mt-2 block w-full rounded-md border-0 bg-slate-800 py-1.5 text-gray-300 shadow-sm ring-1 ring-inset ring-gray-600 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6"
      />
    </div>
  );
}

type SliderProps = {
  label: string;
  description?: string;
  min?: number;
  max?: number;
  step?: number;
  defaultValue?: number;
  onChange: (value: number) => void;
};

export function Slider({
  label, 
  description,
  min = 0,
  max = 100,
  step = 1,
  defaultValue = 50,
  onChange 
}: SliderProps) {
  return (
    <div className="w-80">
      <label className="block text-sm font-medium leading-6 text-gray-300">
        {label}
      </label>
      {description && (
        <div className="text-sm text-gray-500">
          {description}
        </div>
      )}
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        defaultValue={defaultValue}
        onChange={(e) => onChange(Number(e.target.value))}
        className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-2"
      />
      <div className="mt-1 text-xs text-gray-400">
        Value: {defaultValue}
      </div>
    </div>
  );
}

type CheckboxProps = {
  label: string;
  description?: string;
  defaultChecked?: boolean;
  onChange: (checked: boolean) => void;
};

export function Checkbox({
  label,
  description,
  defaultChecked = false,
  onChange
}: CheckboxProps) {
  return (
    <div className="w-80">
      <label className="flex items-center text-sm font-medium text-gray-300">
        <input
          type="checkbox"
          defaultChecked={defaultChecked}
          onChange={(e) => onChange(e.target.checked)}
          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600 mr-2"
        />
        {label}
      </label>
      {description && (
        <div className="mt-1 text-sm text-gray-500 ml-6">
          {description}
        </div>
      )}
    </div>
  );
}

type CheckboxGroupProps = {
  label: string;
  description?: string;
  options?: string[];
  defaultSelected?: string[];
  onChange: (selected: string[]) => void;
};

export function CheckboxGroup({
  label,
  description,
  options = [],
  defaultSelected = [],
  onChange
}: CheckboxGroupProps) {
  return (
    <div className="w-80">
      <label className="block text-sm font-medium leading-6 text-gray-300">
        {label}
      </label>
      {description && (
        <div className="text-sm text-gray-500">
          {description}
        </div>
      )}
      <div className="mt-2 space-y-2">
        {(options || []).map((option) => (
          <label key={option} className="flex items-center text-sm text-gray-300">
            <input
              type="checkbox"
              defaultChecked={defaultSelected.includes(option)}
              onChange={(e) => {
                const newSelected = e.target.checked
                  ? [...defaultSelected, option]
                  : defaultSelected.filter(item => item !== option);
                onChange(newSelected);
              }}
              className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600 mr-2"
            />
            {option}
          </label>
        ))}
      </div>
    </div>
  );
}

type NumberOutputProps = {
  title?: string;
  value: string | number | null;
};

export function NumberOutput({ title, value }: NumberOutputProps) {
  return (
    <div className="w-80 p-4 rounded-lg border border-gray-600 bg-slate-800">
      <div className="text-sm font-medium text-gray-300 mb-2">
        {title || 'Output Value'}
      </div>
      <div className="text-2xl font-bold text-gray-100">
        {value ?? ''}
      </div>
    </div>
  );
}

==== src/components/prompt.tsx ====

type Props = {
  label:string, 
  placeholder: string
  placeholderTextArea: string,
  description: string,
  setPrompt: (value: string) => void;
}
export function Prompt({label,description ,placeholder, placeholderTextArea, setPrompt}: Props) {
  return (
    <div className="w-80">
      <label className="block text-sm font-medium leading-6 text-gray-300">
        {label}
      </label>
      <div>
        {description}
      </div>
      <textarea
        className="mt-2 w-full border bg-slate-800 text-sm text-gray-300 leading-6 text-left pl-3 py-1 rounded-md"
        placeholder={placeholderTextArea}
        onChange={(e) => setPrompt(e.target.value)}
      />
    </div>
  )
}

==== src/components/textOutput.tsx ====
type TextOutputProps = {
  title?: string;
  placeholder?: string;
  value?: string;
};

export function TextOutput({ title, placeholder, value }: TextOutputProps) {
  return (
    <div className="w-80 p-4 rounded-lg border border-gray-600 bg-slate-800">
      <div className="text-sm font-medium text-gray-300 mb-2">
        {title || 'Text Output'}
      </div>
      <div className="text-lg text-gray-100 break-words">
        {value || placeholder || ''}
      </div>
    </div>
  );
}

==== src/experimental/sse-handler/client.ts ====


==== src/experimental/sse-handler/route.ts ====


==== src/experimental/sse-handler/utils.ts ====


==== src/lib/mongodb.ts ====
import { MongoClient } from 'mongodb'

declare global {
  var _mongoClientPromise: Promise<MongoClient> | undefined;
}

if (!process.env.MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "MONGODB_URI"')
}

const uri = process.env.MONGODB_URI
const options = {}

let client
let clientPromise: Promise<MongoClient>

if (process.env.NODE_ENV === 'development') {
  if (!global._mongoClientPromise) {
    client = new MongoClient(uri, options)
    global._mongoClientPromise = client.connect()
  }
  clientPromise = global._mongoClientPromise
} else {
  client = new MongoClient(uri, options)
  clientPromise = client.connect()
}

export default clientPromise

==== src/types/index.ts ====
export type NavItem = {
  name: string;
  href: string;
  icon: React.ForwardRefExoticComponent<
    Omit<React.SVGProps<SVGSVGElement>, 'ref'> & {
      title?: string | undefined;
      titleId?: string | undefined;
    } & React.RefAttributes<SVGSVGElement>
  >;
};

export type ImageAreaProps = {
  title: string;
  id?: number;
  icon: React.ForwardRefExoticComponent<
    Omit<React.SVGProps<SVGSVGElement>, 'ref'> & {
      title?: string | undefined;
      titleId?: string | undefined;
    } & React.RefAttributes<SVGSVGElement>
  >;
};

export type Slug = "createVideo" | "freshink" | "hairStyle" | "upscaler" | "livePortrait" | "tryon"  | "EVF-SAM";

// Your type definitions
export type InputItem = {
  component: 'image' | 'prompt' | 'checkbox' | 'number' | 'video' | 'Textbox' | 'dropdown' | 'slider' | 'audio' | 'checkboxgroup';
  key: string;
  placeholder?: string;
  type: 'string' | 'array' | 'integer' | 'boolean';
  gradioName?: string;
  show?: boolean;
  label?: string;
  description?: string;
  value?: any;
  required?: boolean;
  // Properties for number and slider inputs
  min?: number;
  max?: number;
  step?: number;
  // Properties for dropdown and checkboxgroup inputs
  options?: string[];
};

export interface OutputItem {
  component: 'image' | 'prompt' | 'checkbox' | 'number' | 'video' | 'audio' | 'textbox';
  key: string;
  placeholder?: string;
  type: 'string' | 'number' | 'boolean' | 'array';
  show: boolean;
  title?: string;
  value?: string;
  typeItem?: 'string' | 'number' | 'boolean';
  format?: string;
  formatItem?: string;
}

// Function to infer component for OutputItem
const inferOutputComponent = (output: OutputItem): OutputItem => {
  if (output.type === 'array' && output.typeItem === 'string' && output.formatItem === 'string') {
    return { ...output, component: 'image' }; // Infer as image
  }
  return output; // Return unchanged if no inference
};

export type Configuration = {
  name: string;
  type: 'gradio' | 'replicate';
  client?: string;
  path?: string;
  endpoint?: string;
  model?: `${string}/${string}` | `${string}/${string}:${string}`;
  version?: string | null;
  inputs: InputItem[];
  outputs?: OutputItem[];
};

export type Configurations = Configuration[];

==== src/utils/gradio.ts ====
/**
 * Normalizes Gradio client URLs/identifiers to consistent format
 * @param inputClient - Client identifier (URL or path)
 * @returns Normalized client identifier
 */
export function fixClient(inputClient: string): string {
  // First check if it looks like a URL
  if (inputClient.includes('://') || inputClient.startsWith('http')) {
    try {
      const url = new URL(inputClient);
      if (url.hostname === "huggingface.co") {
        const parts = url.pathname.split('/').filter(Boolean);
        // Handle both direct model paths and spaces paths
        if (parts[0] === "spaces" && parts.length > 1) {
          return parts.slice(1).join('/');
        } else if (parts.length >= 2) {
          return parts.join('/');
        }
      }
    } catch (e) {
      console.debug('Input is not a valid URL, proceeding as plain client name');
    }
  }
  
  // Clean up non-URL inputs
  return inputClient.startsWith('/') ? inputClient.slice(1) : inputClient;
}

/**
 * Constructs the base URL for a Gradio space
 * @param client - Client identifier (from fixClient)
 * @returns Full base URL for the space
 */
export function getGradioBaseUrl(client: string): string {
  const fixedClient = fixClient(client);
  return `https://${fixedClient.replace(/\//g, '-')}.hf.space`;
}


==== src/utils/index.ts ====
export function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(' ');
}

export const sleep = (ms: number) => 
  new Promise((r) => setTimeout(r, ms));


==== tailwind.config.ts ====
import type { Config } from "tailwindcss"

const config: Config = {
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {
      // You can keep any custom extensions here if needed
    },
  },
  plugins: [],
}

export default config

==== tmp/gradio_test.ts ====
import { Client } from "@gradio/client";
import fs from 'fs';

interface ComponentInfo {
  label?: string;
  type?: string;
}

interface AppInfo {
  inputs: ComponentInfo[];
  outputs: ComponentInfo[];
  api_info?: Record<string, any>;
}

async function testGradioConnection() {
  try {
    // Replace with your actual Gradio URL
    const gradioUrl = '/fffiloni/KDTalker';
    console.log(`Connecting to Gradio at: ${gradioUrl}`);

    // Connect to Gradio
    const app = await Client.connect(gradioUrl);
    console.log('âœ… Gradio client connected successfully');

    // Get app info - handle Gradio API response
    const appInfo = await app.view_api();
    const formattedInfo: AppInfo = {
      inputs: [],
      outputs: [],
      api_info: appInfo
    };

    // Extract components from API response
    if (appInfo && typeof appInfo === 'object') {
      try {
        // Handle Gradio API response using type assertions
        const apiData = appInfo as any;
        
        // Get inputs/outputs either from root level or nested in api_data
        const possibleInputs = apiData.api_data?.input_components || 
                              apiData.input_components || 
                              [];
        
        const possibleOutputs = apiData.api_data?.output_components || 
                               apiData.output_components || 
                               [];

        formattedInfo.inputs = Array.isArray(possibleInputs)
          ? possibleInputs.map((comp: Record<string, any>) => ({
              label: comp.label || comp.component || '',
              type: comp.type || 'unknown'
            }))
          : [];

        formattedInfo.outputs = Array.isArray(possibleOutputs)
          ? possibleOutputs.map((comp: Record<string, any>) => ({
              label: comp.label || comp.component || '',
              type: comp.type || 'unknown'
            }))
          : [];
      } catch (err) {
        console.warn('Error processing API response:', err);
      }
    }
    
    fs.writeFileSync('tmp/response_app_info.json', JSON.stringify(formattedInfo, null, 2));
    console.log('ðŸ“„ App info saved to tmp/response_app_info.json');

    // Test prediction with sample data
    console.log('Testing prediction endpoint...');
    const result = await app.predict('/predict', {
      source_image: 'path_to_test_image.jpg', // Replace or read from file
      driven_audio: 'path_to_test_audio.wav'  // Replace or read from file
    });

    console.log('Prediction result:', result.data);
  } catch (error: unknown) {
    console.error('âŒ Gradio test failed');
    
    if (error instanceof Error) {
      console.error(error.message);
      // Write detailed error info
      fs.writeFileSync('tmp/error_log.json', 
        JSON.stringify({
          message: error.message,
          stack: error.stack,
          timestamp: new Date().toISOString()
        }, null, 2));
    } else {
      console.error('Unknown error occurred');
      fs.writeFileSync('tmp/error_log.json', 
        JSON.stringify({
          message: 'Unknown error',
          timestamp: new Date().toISOString()
        }, null, 2));
    }
  }
}

testGradioConnection();


==== tmp/playground.ts ====
type OutputItem = {
  key: string;
  type: 'string' | 'number' | 'boolean' | 'array';
  show: boolean;
  title: string;
  format?: string;
  typeItem?: 'string' | 'number' | 'boolean';
  formatItem?: string;
};

type PropertyValue = {
  type: string;
  items?: {
    type: string;
    format?: string;
  };
  title?: string;
  format?: string;
};

const processOutput = (key: string, value: PropertyValue): OutputItem => {

  console.log({key, value});

  let outputItem: OutputItem = {
    key,
    type: value.type as 'string' | 'number' | 'boolean' | 'array',
    show: true,
    title: value.title || key,
  };

  if (value.type === 'array' && value.items) {
    outputItem.typeItem = value.items.type as 'string' | 'number' | 'boolean';
    if (value.items.format) {
      outputItem.formatItem = value.items.format;
    }
  } else if (value.type === 'string' && value.format) {
    outputItem.format = value.format;
  }

  return outputItem;
};

const outputs1: Record<string, PropertyValue> = {
  "output": {
    "type": "array",
    "items": {
      "type": "string"
    }
  }
};

const outputs2: Record<string, PropertyValue> = {
  "output": {
    "type": "array",
    "items": {
      "type": "string",
      "format": "uri"
    },
    "title": "Output"
  }
};

const outputs3: Record<string, PropertyValue> = {
  "output": {
    "type": "array",
    "items": {
      "type": "string"
    },
    "title": "Output"
  }
};

const outputs4: Record<string, PropertyValue> = {
  "output": {
    "type": "string",
    "title": "Output"
  }
};

const testOutputs = (outputs: Record<string, PropertyValue>) => {
  return Object.entries(outputs).map(([key, value]) => processOutput(key, value));
};

// console.log("Test 1:", testOutputs(outputs1));
console.log("Test 2:", testOutputs(outputs2));
// console.log("Test 3:", testOutputs(outputs3));
// console.log("Test 4:", testOutputs(outputs4));

==== tmp/response_app_info.json ====
{
  "named_endpoints": {
      "/process": {
          "parameters": [
              {
                  "label": "Image",
                  "parameter_name": "input_fg",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "Blob | File | Buffer",
                  "python_type": {
                      "type": "filepath",
                      "description": ""
                  },
                  "component": "Image",
                  "example_input": {
                      "path": "https://raw.githubusercontent.com/gradio-app/gradio/main/test/test_files/bus.png",
                      "meta": {
                          "_type": "gradio.FileData"
                      },
                      "orig_name": "bus.png",
                      "url": "https://raw.githubusercontent.com/gradio-app/gradio/main/test/test_files/bus.png"
                  }
              },
              {
                  "label": "Initial Latent",
                  "parameter_name": "bg_source",
                  "parameter_has_default": true,
                  "parameter_default": "None",
                  "type": "string",
                  "python_type": {
                      "type": "Literal['None', 'Left Light', 'Right Light', 'Top Light', 'Bottom Light']",
                      "description": ""
                  },
                  "component": "Radio",
                  "example_input": "None"
              },
              {
                  "label": "Prompt",
                  "parameter_name": "prompt",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox",
                  "example_input": "Hello!!"
              },
              {
                  "label": "Image Width",
                  "parameter_name": "image_width",
                  "parameter_has_default": true,
                  "parameter_default": 896,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 256 and 4096"
                  },
                  "component": "Slider",
                  "example_input": 256,
                  "description": "numeric value between 256 and 4096"
              },
              {
                  "label": "Image Height",
                  "parameter_name": "image_height",
                  "parameter_has_default": true,
                  "parameter_default": 1152,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 256 and 4096"
                  },
                  "component": "Slider",
                  "example_input": 256,
                  "description": "numeric value between 256 and 4096"
              },
              {
                  "label": "Images",
                  "parameter_name": "num_samples",
                  "parameter_has_default": true,
                  "parameter_default": 1,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 1 and 12"
                  },
                  "component": "Slider",
                  "example_input": 1,
                  "description": "numeric value between 1 and 12"
              },
              {
                  "label": "Seed",
                  "parameter_name": "seed",
                  "parameter_has_default": true,
                  "parameter_default": 12345,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": ""
                  },
                  "component": "Number",
                  "example_input": 3
              },
              {
                  "label": "Steps",
                  "parameter_name": "steps",
                  "parameter_has_default": true,
                  "parameter_default": 25,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 1 and 100"
                  },
                  "component": "Slider",
                  "example_input": 1,
                  "description": "numeric value between 1 and 100"
              },
              {
                  "label": "Negative Prompt",
                  "parameter_name": "n_prompt",
                  "parameter_has_default": true,
                  "parameter_default": "",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox",
                  "example_input": "Hello!!"
              },
              {
                  "label": "CFG Scale",
                  "parameter_name": "cfg",
                  "parameter_has_default": true,
                  "parameter_default": 1,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 1.0 and 32.0"
                  },
                  "component": "Slider",
                  "example_input": 1,
                  "description": "numeric value between 1.0 and 32.0"
              },
              {
                  "label": "Distilled CFG Scale",
                  "parameter_name": "gs",
                  "parameter_has_default": true,
                  "parameter_default": 3.5,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 1.0 and 32.0"
                  },
                  "component": "Slider",
                  "example_input": 1,
                  "description": "numeric value between 1.0 and 32.0"
              },
              {
                  "label": "CFG Re-Scale",
                  "parameter_name": "rs",
                  "parameter_has_default": true,
                  "parameter_default": 1,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 0.0 and 1.0"
                  },
                  "component": "Slider",
                  "example_input": 0,
                  "description": "numeric value between 0.0 and 1.0"
              },
              {
                  "label": "Enable HR Fix",
                  "parameter_name": "enable_hr_fix",
                  "parameter_has_default": true,
                  "parameter_default": true,
                  "type": "boolean",
                  "python_type": {
                      "type": "bool",
                      "description": ""
                  },
                  "component": "Checkbox",
                  "example_input": true
              },
              {
                  "label": "HR Fix Down Scale",
                  "parameter_name": "hr_downscale",
                  "parameter_has_default": true,
                  "parameter_default": 0.5,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 0.1 and 1.0"
                  },
                  "component": "Slider",
                  "example_input": 0.1,
                  "description": "numeric value between 0.1 and 1.0"
              },
              {
                  "label": "Low Pass Denoise Strength",
                  "parameter_name": "lowres_denoise",
                  "parameter_has_default": true,
                  "parameter_default": 0.98,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 0.1 and 1.0"
                  },
                  "component": "Slider",
                  "example_input": 0.1,
                  "description": "numeric value between 0.1 and 1.0"
              },
              {
                  "label": "High Pass Denoise Strength",
                  "parameter_name": "highres_denoise",
                  "parameter_has_default": true,
                  "parameter_default": 0.95,
                  "type": "number",
                  "python_type": {
                      "type": "float",
                      "description": "numeric value between 0.1 and 1.0"
                  },
                  "component": "Slider",
                  "example_input": 0.1,
                  "description": "numeric value between 0.1 and 1.0"
              }
          ],
          "returns": [
              {
                  "label": "Outputs",
                  "type": "",
                  "python_type": {
                      "type": "List[Dict(image: filepath, caption: str | None)]",
                      "description": ""
                  },
                  "component": "Gallery"
              },
              {
                  "label": "Preprocessed Foreground",
                  "type": "string",
                  "python_type": {
                      "type": "filepath",
                      "description": ""
                  },
                  "component": "Image"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      },
      "/update_quick_prompt": {
          "parameters": [
              {
                  "label": "Prefix Quick List",
                  "parameter_name": "p",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Subject Quick List",
                  "parameter_name": "s",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Illumination Environment Quick List",
                  "parameter_name": "i",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Background Quick List",
                  "parameter_name": "b",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "component": "state",
                  "example": null,
                  "parameter_default": null,
                  "parameter_has_default": true,
                  "parameter_name": null,
                  "hidden": true,
                  "type": ""
              }
          ],
          "returns": [
              {
                  "label": "Prompt",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      },
      "/update_quick_prompt_1": {
          "parameters": [
              {
                  "label": "Prefix Quick List",
                  "parameter_name": "p",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Subject Quick List",
                  "parameter_name": "s",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Illumination Environment Quick List",
                  "parameter_name": "i",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Background Quick List",
                  "parameter_name": "b",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "component": "state",
                  "example": null,
                  "parameter_default": null,
                  "parameter_has_default": true,
                  "parameter_name": null,
                  "hidden": true,
                  "type": ""
              }
          ],
          "returns": [
              {
                  "label": "Prompt",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      },
      "/update_quick_prompt_2": {
          "parameters": [
              {
                  "label": "Prefix Quick List",
                  "parameter_name": "p",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Subject Quick List",
                  "parameter_name": "s",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Illumination Environment Quick List",
                  "parameter_name": "i",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Background Quick List",
                  "parameter_name": "b",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "component": "state",
                  "example": null,
                  "parameter_default": null,
                  "parameter_has_default": true,
                  "parameter_name": null,
                  "hidden": true,
                  "type": ""
              }
          ],
          "returns": [
              {
                  "label": "Prompt",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      },
      "/update_quick_prompt_3": {
          "parameters": [
              {
                  "label": "Prefix Quick List",
                  "parameter_name": "p",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Subject Quick List",
                  "parameter_name": "s",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Illumination Environment Quick List",
                  "parameter_name": "i",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "label": "Background Quick List",
                  "parameter_name": "b",
                  "parameter_has_default": false,
                  "parameter_default": null,
                  "type": "",
                  "python_type": {
                      "type": "int",
                      "description": "index of selected example"
                  },
                  "component": "Dataset",
                  "example_input": 0,
                  "description": "index of selected example"
              },
              {
                  "component": "state",
                  "example": null,
                  "parameter_default": null,
                  "parameter_has_default": true,
                  "parameter_name": null,
                  "hidden": true,
                  "type": ""
              }
          ],
          "returns": [
              {
                  "label": "Prompt",
                  "type": "string",
                  "python_type": {
                      "type": "str",
                      "description": ""
                  },
                  "component": "Textbox"
              }
          ],
          "type": {
              "generator": false,
              "cancel": false
          }
      }
  },
  "unnamed_endpoints": {}
}

==== tmp/test.ts ====
import { Client, handle_file } from "@gradio/client";

const app = await Client.connect("bytedance-research/UNO-FLUX");


const image1 = "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png";
const image2 = "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png";
					
await client.predict(
  "/load_example", {
    example_tuple: 3,
});
						
await client.predict(
  "/gradio_generate", {
    prompt: "The logo is printed on the cup",
    width: 512,
    height: 512,
    guidance: 4,
    num_steps: 25,
    seed: 61733557,
    image_prompt1: {"path":"/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png","url":"https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png","size":None,"orig_name":"ref1.png","mime_type":None,"is_stream":false,"meta":{"_type":"gradio.FileData"}},
    image_prompt2: {"path":"/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png","url":"https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png","size":None,"orig_name":"ref2.png","mime_type":None,"is_stream":false,"meta":{"_type":"gradio.FileData"}},
    image_prompt3: None,
    image_prompt4: None,
});


==== tmp/test2.ts ====
import { Client, handle_file } from "@gradio/client";

const image1 = "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png";
const image2 = "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png";

(async function() {
  const app = await Client.connect("bytedance-research/UNO-FLUX");

})();





          
await client.predict(
  "/load_example", {
    example_tuple: 3,
});
            
await client.predict(
  "/gradio_generate", {
    prompt: "The logo is printed on the cup",
    width: 512,
    height: 512,
    guidance: 4,
    num_steps: 25,
    seed: 61733557,
    image_prompt1: {"path":"/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png","url":"https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png","size":None,"orig_name":"ref1.png","mime_type":None,"is_stream":false,"meta":{"_type":"gradio.FileData"}},
    image_prompt2: {"path":"/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png","url":"https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png","size":None,"orig_name":"ref2.png","mime_type":None,"is_stream":false,"meta":{"_type":"gradio.FileData"}},
    image_prompt3: None,
    image_prompt4: None,
});


==== tmp/test3.ts ====
import { Client, handle_file } from "@gradio/client";


const CLIENT = "bytedance-research/UNO-FLUX";

const IMAGES = [
  "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/75299f1b597035b098682f77122c9434e726decc63ba23b186b105b6aebeaefc/ref1.png",
  "https://bytedance-research-uno-flux.hf.space/gradio_api/file=/tmp/gradio/77c8df1ea8c10af3986fc7e90a3ee943559b534e5cfbe9929f3cef4127f14908/ref2.png"
];



(async function () {
  try {
    // Fetch example images
    const responses = await Promise.all([
      fetch(IMAGES[0]),
      fetch(IMAGES[1])
    ]);
    
    const images = await Promise.all(responses.map(r => r.blob()));

    const endpoint = "/gradio_generate";
    const params = {
      prompt: "The logo is printed on the cup",
      width: 512,
      height: 512,
      guidance: 4,
      num_steps: 25,
      seed: 61733557,
      image_prompt1: handle_file(images[0]),
      image_prompt2: handle_file(images[1]),
    }

    // Connect to client
    const client = await Client.connect(CLIENT);
    
    // Make prediction
    const result = await client.predict(endpoint, params);

    console.log(result.data);
  } catch (error: any) {
    console.error("Error:", error.message);
  }
})();

==== tsconfig.json ====
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

